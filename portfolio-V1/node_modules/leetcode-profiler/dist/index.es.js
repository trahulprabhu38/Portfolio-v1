import './index.css';
var Bg = Object.defineProperty;
var Wg = (t, r, e) => r in t ? Bg(t, r, { enumerable: !0, configurable: !0, writable: !0, value: e }) : t[r] = e;
var Ge = (t, r, e) => (Wg(t, typeof r != "symbol" ? r + "" : r, e), e), Ha = (t, r, e) => {
  if (!r.has(t))
    throw TypeError("Cannot " + e);
};
var we = (t, r, e) => (Ha(t, r, "read from private field"), e ? e.call(t) : r.get(t)), _e = (t, r, e) => {
  if (r.has(t))
    throw TypeError("Cannot add the same private member more than once");
  r instanceof WeakSet ? r.add(t) : r.set(t, e);
}, qe = (t, r, e, i) => (Ha(t, r, "write to private field"), i ? i.call(t, e) : r.set(t, e), e);
var ws = (t, r, e, i) => ({
  set _(n) {
    qe(t, r, n, e);
  },
  get _() {
    return we(t, r, i);
  }
}), bt = (t, r, e) => (Ha(t, r, "access private method"), e);
import * as vr from "react";
import Qt, { useState as At, useMemo as Ri, createContext as Hg, useRef as Tr, useEffect as Nt, useContext as zg, useCallback as Yg, useImperativeHandle as Ug, useLayoutEffect as Gg, cloneElement as qg } from "react";
import { createPortal as Xg } from "react-dom";
var Mo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function To(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Qg(t) {
  if (t.__esModule)
    return t;
  var r = t.default;
  if (typeof r == "function") {
    var e = function i() {
      return this instanceof i ? Reflect.construct(r, arguments, this.constructor) : r.apply(this, arguments);
    };
    e.prototype = r.prototype;
  } else
    e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(t).forEach(function(i) {
    var n = Object.getOwnPropertyDescriptor(t, i);
    Object.defineProperty(e, i, n.get ? n : {
      enumerable: !0,
      get: function() {
        return t[i];
      }
    });
  }), e;
}
var Ja = { exports: {} }, An = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dc;
function Vg() {
  if (dc)
    return An;
  dc = 1;
  var t = Qt, r = Symbol.for("react.element"), e = Symbol.for("react.fragment"), i = Object.prototype.hasOwnProperty, n = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function l(m, A, Y) {
    var q, T = {}, B = null, O = null;
    Y !== void 0 && (B = "" + Y), A.key !== void 0 && (B = "" + A.key), A.ref !== void 0 && (O = A.ref);
    for (q in A)
      i.call(A, q) && !s.hasOwnProperty(q) && (T[q] = A[q]);
    if (m && m.defaultProps)
      for (q in A = m.defaultProps, A)
        T[q] === void 0 && (T[q] = A[q]);
    return { $$typeof: r, type: m, key: B, ref: O, props: T, _owner: n.current };
  }
  return An.Fragment = e, An.jsx = l, An.jsxs = l, An;
}
var En = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uc;
function Kg() {
  return uc || (uc = 1, process.env.NODE_ENV !== "production" && function() {
    var t = Qt, r = Symbol.for("react.element"), e = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), m = Symbol.for("react.context"), A = Symbol.for("react.forward_ref"), Y = Symbol.for("react.suspense"), q = Symbol.for("react.suspense_list"), T = Symbol.for("react.memo"), B = Symbol.for("react.lazy"), O = Symbol.for("react.offscreen"), b = Symbol.iterator, v = "@@iterator";
    function E(ue) {
      if (ue === null || typeof ue != "object")
        return null;
      var Oe = b && ue[b] || ue[v];
      return typeof Oe == "function" ? Oe : null;
    }
    var M = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function g(ue) {
      {
        for (var Oe = arguments.length, He = new Array(Oe > 1 ? Oe - 1 : 0), tt = 1; tt < Oe; tt++)
          He[tt - 1] = arguments[tt];
        C("error", ue, He);
      }
    }
    function C(ue, Oe, He) {
      {
        var tt = M.ReactDebugCurrentFrame, ct = tt.getStackAddendum();
        ct !== "" && (Oe += "%s", He = He.concat([ct]));
        var mt = He.map(function(ot) {
          return String(ot);
        });
        mt.unshift("Warning: " + Oe), Function.prototype.apply.call(console[ue], console, mt);
      }
    }
    var j = !1, D = !1, u = !1, R = !1, K = !1, I;
    I = Symbol.for("react.module.reference");
    function z(ue) {
      return !!(typeof ue == "string" || typeof ue == "function" || ue === i || ue === s || K || ue === n || ue === Y || ue === q || R || ue === O || j || D || u || typeof ue == "object" && ue !== null && (ue.$$typeof === B || ue.$$typeof === T || ue.$$typeof === l || ue.$$typeof === m || ue.$$typeof === A || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      ue.$$typeof === I || ue.getModuleId !== void 0));
    }
    function k(ue, Oe, He) {
      var tt = ue.displayName;
      if (tt)
        return tt;
      var ct = Oe.displayName || Oe.name || "";
      return ct !== "" ? He + "(" + ct + ")" : He;
    }
    function h(ue) {
      return ue.displayName || "Context";
    }
    function F(ue) {
      if (ue == null)
        return null;
      if (typeof ue.tag == "number" && g("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ue == "function")
        return ue.displayName || ue.name || null;
      if (typeof ue == "string")
        return ue;
      switch (ue) {
        case i:
          return "Fragment";
        case e:
          return "Portal";
        case s:
          return "Profiler";
        case n:
          return "StrictMode";
        case Y:
          return "Suspense";
        case q:
          return "SuspenseList";
      }
      if (typeof ue == "object")
        switch (ue.$$typeof) {
          case m:
            var Oe = ue;
            return h(Oe) + ".Consumer";
          case l:
            var He = ue;
            return h(He._context) + ".Provider";
          case A:
            return k(ue, ue.render, "ForwardRef");
          case T:
            var tt = ue.displayName || null;
            return tt !== null ? tt : F(ue.type) || "Memo";
          case B: {
            var ct = ue, mt = ct._payload, ot = ct._init;
            try {
              return F(ot(mt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var o = Object.assign, a = 0, c, d, S, P, G, x, Q;
    function J() {
    }
    J.__reactDisabledLog = !0;
    function ie() {
      {
        if (a === 0) {
          c = console.log, d = console.info, S = console.warn, P = console.error, G = console.group, x = console.groupCollapsed, Q = console.groupEnd;
          var ue = {
            configurable: !0,
            enumerable: !0,
            value: J,
            writable: !0
          };
          Object.defineProperties(console, {
            info: ue,
            log: ue,
            warn: ue,
            error: ue,
            group: ue,
            groupCollapsed: ue,
            groupEnd: ue
          });
        }
        a++;
      }
    }
    function te() {
      {
        if (a--, a === 0) {
          var ue = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: o({}, ue, {
              value: c
            }),
            info: o({}, ue, {
              value: d
            }),
            warn: o({}, ue, {
              value: S
            }),
            error: o({}, ue, {
              value: P
            }),
            group: o({}, ue, {
              value: G
            }),
            groupCollapsed: o({}, ue, {
              value: x
            }),
            groupEnd: o({}, ue, {
              value: Q
            })
          });
        }
        a < 0 && g("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var $ = M.ReactCurrentDispatcher, oe;
    function p(ue, Oe, He) {
      {
        if (oe === void 0)
          try {
            throw Error();
          } catch (ct) {
            var tt = ct.stack.trim().match(/\n( *(at )?)/);
            oe = tt && tt[1] || "";
          }
        return `
` + oe + ue;
      }
    }
    var W = !1, X;
    {
      var f = typeof WeakMap == "function" ? WeakMap : Map;
      X = new f();
    }
    function L(ue, Oe) {
      if (!ue || W)
        return "";
      {
        var He = X.get(ue);
        if (He !== void 0)
          return He;
      }
      var tt;
      W = !0;
      var ct = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var mt;
      mt = $.current, $.current = null, ie();
      try {
        if (Oe) {
          var ot = function() {
            throw Error();
          };
          if (Object.defineProperty(ot.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ot, []);
            } catch (kr) {
              tt = kr;
            }
            Reflect.construct(ue, [], ot);
          } else {
            try {
              ot.call();
            } catch (kr) {
              tt = kr;
            }
            ue.call(ot.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (kr) {
            tt = kr;
          }
          ue();
        }
      } catch (kr) {
        if (kr && tt && typeof kr.stack == "string") {
          for (var at = kr.stack.split(`
`), st = tt.stack.split(`
`), ft = at.length - 1, Pt = st.length - 1; ft >= 1 && Pt >= 0 && at[ft] !== st[Pt]; )
            Pt--;
          for (; ft >= 1 && Pt >= 0; ft--, Pt--)
            if (at[ft] !== st[Pt]) {
              if (ft !== 1 || Pt !== 1)
                do
                  if (ft--, Pt--, Pt < 0 || at[ft] !== st[Pt]) {
                    var Gt = `
` + at[ft].replace(" at new ", " at ");
                    return ue.displayName && Gt.includes("<anonymous>") && (Gt = Gt.replace("<anonymous>", ue.displayName)), typeof ue == "function" && X.set(ue, Gt), Gt;
                  }
                while (ft >= 1 && Pt >= 0);
              break;
            }
        }
      } finally {
        W = !1, $.current = mt, te(), Error.prepareStackTrace = ct;
      }
      var Er = ue ? ue.displayName || ue.name : "", Ur = Er ? p(Er) : "";
      return typeof ue == "function" && X.set(ue, Ur), Ur;
    }
    function w(ue, Oe, He) {
      return L(ue, !1);
    }
    function H(ue) {
      var Oe = ue.prototype;
      return !!(Oe && Oe.isReactComponent);
    }
    function U(ue, Oe, He) {
      if (ue == null)
        return "";
      if (typeof ue == "function")
        return L(ue, H(ue));
      if (typeof ue == "string")
        return p(ue);
      switch (ue) {
        case Y:
          return p("Suspense");
        case q:
          return p("SuspenseList");
      }
      if (typeof ue == "object")
        switch (ue.$$typeof) {
          case A:
            return w(ue.render);
          case T:
            return U(ue.type, Oe, He);
          case B: {
            var tt = ue, ct = tt._payload, mt = tt._init;
            try {
              return U(mt(ct), Oe, He);
            } catch {
            }
          }
        }
      return "";
    }
    var ee = Object.prototype.hasOwnProperty, ae = {}, ne = M.ReactDebugCurrentFrame;
    function he(ue) {
      if (ue) {
        var Oe = ue._owner, He = U(ue.type, ue._source, Oe ? Oe.type : null);
        ne.setExtraStackFrame(He);
      } else
        ne.setExtraStackFrame(null);
    }
    function me(ue, Oe, He, tt, ct) {
      {
        var mt = Function.call.bind(ee);
        for (var ot in ue)
          if (mt(ue, ot)) {
            var at = void 0;
            try {
              if (typeof ue[ot] != "function") {
                var st = Error((tt || "React class") + ": " + He + " type `" + ot + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ue[ot] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw st.name = "Invariant Violation", st;
              }
              at = ue[ot](Oe, ot, tt, He, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ft) {
              at = ft;
            }
            at && !(at instanceof Error) && (he(ct), g("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", tt || "React class", He, ot, typeof at), he(null)), at instanceof Error && !(at.message in ae) && (ae[at.message] = !0, he(ct), g("Failed %s type: %s", He, at.message), he(null));
          }
      }
    }
    var ve = Array.isArray;
    function Me(ue) {
      return ve(ue);
    }
    function Z(ue) {
      {
        var Oe = typeof Symbol == "function" && Symbol.toStringTag, He = Oe && ue[Symbol.toStringTag] || ue.constructor.name || "Object";
        return He;
      }
    }
    function V(ue) {
      try {
        return re(ue), !1;
      } catch {
        return !0;
      }
    }
    function re(ue) {
      return "" + ue;
    }
    function le(ue) {
      if (V(ue))
        return g("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Z(ue)), re(ue);
    }
    var be = M.ReactCurrentOwner, de = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ge, fe, ke;
    ke = {};
    function Pe(ue) {
      if (ee.call(ue, "ref")) {
        var Oe = Object.getOwnPropertyDescriptor(ue, "ref").get;
        if (Oe && Oe.isReactWarning)
          return !1;
      }
      return ue.ref !== void 0;
    }
    function Ae(ue) {
      if (ee.call(ue, "key")) {
        var Oe = Object.getOwnPropertyDescriptor(ue, "key").get;
        if (Oe && Oe.isReactWarning)
          return !1;
      }
      return ue.key !== void 0;
    }
    function Le(ue, Oe) {
      if (typeof ue.ref == "string" && be.current && Oe && be.current.stateNode !== Oe) {
        var He = F(be.current.type);
        ke[He] || (g('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', F(be.current.type), ue.ref), ke[He] = !0);
      }
    }
    function Ee(ue, Oe) {
      {
        var He = function() {
          ge || (ge = !0, g("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Oe));
        };
        He.isReactWarning = !0, Object.defineProperty(ue, "key", {
          get: He,
          configurable: !0
        });
      }
    }
    function Ye(ue, Oe) {
      {
        var He = function() {
          fe || (fe = !0, g("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Oe));
        };
        He.isReactWarning = !0, Object.defineProperty(ue, "ref", {
          get: He,
          configurable: !0
        });
      }
    }
    var We = function(ue, Oe, He, tt, ct, mt, ot) {
      var at = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: r,
        // Built-in properties that belong on the element
        type: ue,
        key: Oe,
        ref: He,
        props: ot,
        // Record the component responsible for creating this element.
        _owner: mt
      };
      return at._store = {}, Object.defineProperty(at._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(at, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: tt
      }), Object.defineProperty(at, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ct
      }), Object.freeze && (Object.freeze(at.props), Object.freeze(at)), at;
    };
    function Ne(ue, Oe, He, tt, ct) {
      {
        var mt, ot = {}, at = null, st = null;
        He !== void 0 && (le(He), at = "" + He), Ae(Oe) && (le(Oe.key), at = "" + Oe.key), Pe(Oe) && (st = Oe.ref, Le(Oe, ct));
        for (mt in Oe)
          ee.call(Oe, mt) && !de.hasOwnProperty(mt) && (ot[mt] = Oe[mt]);
        if (ue && ue.defaultProps) {
          var ft = ue.defaultProps;
          for (mt in ft)
            ot[mt] === void 0 && (ot[mt] = ft[mt]);
        }
        if (at || st) {
          var Pt = typeof ue == "function" ? ue.displayName || ue.name || "Unknown" : ue;
          at && Ee(ot, Pt), st && Ye(ot, Pt);
        }
        return We(ue, at, st, ct, tt, be.current, ot);
      }
    }
    var Xe = M.ReactCurrentOwner, et = M.ReactDebugCurrentFrame;
    function Ze(ue) {
      if (ue) {
        var Oe = ue._owner, He = U(ue.type, ue._source, Oe ? Oe.type : null);
        et.setExtraStackFrame(He);
      } else
        et.setExtraStackFrame(null);
    }
    var ut;
    ut = !1;
    function it(ue) {
      return typeof ue == "object" && ue !== null && ue.$$typeof === r;
    }
    function kt() {
      {
        if (Xe.current) {
          var ue = F(Xe.current.type);
          if (ue)
            return `

Check the render method of \`` + ue + "`.";
        }
        return "";
      }
    }
    function ze(ue) {
      {
        if (ue !== void 0) {
          var Oe = ue.fileName.replace(/^.*[\\\/]/, ""), He = ue.lineNumber;
          return `

Check your code at ` + Oe + ":" + He + ".";
        }
        return "";
      }
    }
    var nt = {};
    function jt(ue) {
      {
        var Oe = kt();
        if (!Oe) {
          var He = typeof ue == "string" ? ue : ue.displayName || ue.name;
          He && (Oe = `

Check the top-level render call using <` + He + ">.");
        }
        return Oe;
      }
    }
    function Vt(ue, Oe) {
      {
        if (!ue._store || ue._store.validated || ue.key != null)
          return;
        ue._store.validated = !0;
        var He = jt(Oe);
        if (nt[He])
          return;
        nt[He] = !0;
        var tt = "";
        ue && ue._owner && ue._owner !== Xe.current && (tt = " It was passed a child from " + F(ue._owner.type) + "."), Ze(ue), g('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', He, tt), Ze(null);
      }
    }
    function Be(ue, Oe) {
      {
        if (typeof ue != "object")
          return;
        if (Me(ue))
          for (var He = 0; He < ue.length; He++) {
            var tt = ue[He];
            it(tt) && Vt(tt, Oe);
          }
        else if (it(ue))
          ue._store && (ue._store.validated = !0);
        else if (ue) {
          var ct = E(ue);
          if (typeof ct == "function" && ct !== ue.entries)
            for (var mt = ct.call(ue), ot; !(ot = mt.next()).done; )
              it(ot.value) && Vt(ot.value, Oe);
        }
      }
    }
    function Ve(ue) {
      {
        var Oe = ue.type;
        if (Oe == null || typeof Oe == "string")
          return;
        var He;
        if (typeof Oe == "function")
          He = Oe.propTypes;
        else if (typeof Oe == "object" && (Oe.$$typeof === A || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Oe.$$typeof === T))
          He = Oe.propTypes;
        else
          return;
        if (He) {
          var tt = F(Oe);
          me(He, ue.props, "prop", tt, ue);
        } else if (Oe.PropTypes !== void 0 && !ut) {
          ut = !0;
          var ct = F(Oe);
          g("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ct || "Unknown");
        }
        typeof Oe.getDefaultProps == "function" && !Oe.getDefaultProps.isReactClassApproved && g("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Je(ue) {
      {
        for (var Oe = Object.keys(ue.props), He = 0; He < Oe.length; He++) {
          var tt = Oe[He];
          if (tt !== "children" && tt !== "key") {
            Ze(ue), g("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", tt), Ze(null);
            break;
          }
        }
        ue.ref !== null && (Ze(ue), g("Invalid attribute `ref` supplied to `React.Fragment`."), Ze(null));
      }
    }
    function Dt(ue, Oe, He, tt, ct, mt) {
      {
        var ot = z(ue);
        if (!ot) {
          var at = "";
          (ue === void 0 || typeof ue == "object" && ue !== null && Object.keys(ue).length === 0) && (at += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var st = ze(ct);
          st ? at += st : at += kt();
          var ft;
          ue === null ? ft = "null" : Me(ue) ? ft = "array" : ue !== void 0 && ue.$$typeof === r ? (ft = "<" + (F(ue.type) || "Unknown") + " />", at = " Did you accidentally export a JSX literal instead of a component?") : ft = typeof ue, g("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ft, at);
        }
        var Pt = Ne(ue, Oe, He, ct, mt);
        if (Pt == null)
          return Pt;
        if (ot) {
          var Gt = Oe.children;
          if (Gt !== void 0)
            if (tt)
              if (Me(Gt)) {
                for (var Er = 0; Er < Gt.length; Er++)
                  Be(Gt[Er], ue);
                Object.freeze && Object.freeze(Gt);
              } else
                g("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Be(Gt, ue);
        }
        return ue === i ? Je(Pt) : Ve(Pt), Pt;
      }
    }
    function It(ue, Oe, He) {
      return Dt(ue, Oe, He, !0);
    }
    function _t(ue, Oe, He) {
      return Dt(ue, Oe, He, !1);
    }
    var $t = _t, Bt = It;
    En.Fragment = i, En.jsx = $t, En.jsxs = Bt;
  }()), En;
}
process.env.NODE_ENV === "production" ? Ja.exports = Vg() : Ja.exports = Kg();
var se = Ja.exports;
const Et = ({ children: t, when: r }) => r ? /* @__PURE__ */ se.jsx(se.Fragment, { children: t }) : null, Zg = "data:image/png;base64,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", Jg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAEOXSURBVHgB7X0JlJ3Fdeatt/Vbuvv13q1Wq7UipBaSQMaAgbAbMBiwsbGTeAteiJP4OMskOU5mJseZk5lznPEkmUwWxzE2CbbjmARixwazg4RZZRCgXS2ptXS3et+3t/w191bVrar/9SohMOSkdJ7+t/xL/XXr3vvd7976G+A/23/oJuAd2O666640btKRXK68EIulIJ9Px2KxZBCNJmQ+nwAh6PdIIEQEgiAtpQzdZ2C2UYCcjERm1Hf5/JSIxYpRKWcKANP41XQQBJN43vGxsbHR++67bwK/k/AOa28rAd9xxx2Jxmx2eT4abRJBUBuJRBoDKVvwpzoc2WYUVp0UogE7TUKL4ff0itJW0lbKCG4jQn9PTUj9O4rGyUaa95IkL0TR/FKUeibQtgh6HhQkb1HwuB3BPvTiBOrD96fwuz4RjR6nbaRY7CkI0T8zM9OLk6EIb5P2cxHwnXfeWV8WiazGwVkpIpG1OIgbcODW4mi3CilT+DkJ+hWn/aWcrThyDoHN93voOyGUsPlX4e0r3Y7umMU/BzIIZvC8SutxO4y/H8PztuNM2YcT6BAK/QD+1vnzEPybLmDSyurq6iY0fashEvkF/OpaoPdCVOL7cjBC5FYqmEWFq7+w78Vc++B7HOh5J4U9hxF+6XlDx3j7lJ5nnuPyaIXG8KgBfL8dzf4zOLH3TE5OHnvggQd64U1uZ13AX/7ylyOnOjpaZVnZZtTKi3Bgr8CLrMOBaQQ2l/O0pWgqC2ouAUxNTUExKOJlA+Cfpf7PncP7n24/QucDLTcB6j+chxH9G26F+hydc6AWnUTcibDVIE8wJMjEAxxEi/UYvp6ZCYKeTZs29eL4BXAW21kRMAn1+PHj55TFYpdgp2/HG9qCJ27FnyKLHesPDG0TZSkow1csnoCyZBrS5ZWQKc9CLJaA4cFeOHnsAExPTdhj1RZfU5OTsHvfXiVcFjD94t7PblqQutG1/VdEbSO4j/kcjWIfYhCjbTwOCexfHD/HY3F1nii+p2OiUTeHWcBsWeZ1AUEwjNsOvJ/t6KZ+IqamXt2wbdupsyHsNyRgNL/lNdnsjehHP4+DsA2/ql7KcaQRyVQakukKKK/IQk1tE1TVNEBlVR0kkxlIJFNK0PF4mZr9eG4ZEP7BEeg6eUQ8+8QD0Nvdoc7FQkY/hwLeo7an0+SCuHjBH829RJRQo3hP0VgUEijwRFkZJMuSOFHL8B7iamJEvclUKugSTZ/Gd+342i4KhX8sRiI734jvPiMBk8b29PRcgIP7+zj7bkUBJOe9AHaatC+RTEJFRQ00Ll8JDQ0tUFldC9lsPaQy5erWzN4KyOobNjcurJUV+msJ/T2d8OSD98JAb2dIi0dHR+DAoYNQKBTgzWqzJ8T8k4CETwIuS5RBCu8/lUpBOp1RwqZJIYx78E8c0vYgGMDtf399z5679+7dm4MzaKctYNTaaF119Y349i+wh+vm2oduLJnKQHVdI7Su3ACNy1qhpq4JhVmBZiyitdHchD9g/FbK0KxGkCoF3zXv09dzEp568Nso5JMhMz86OgqHjx6BmdwSNVnO9dXimjvnqZy05t2HxiaRSCgNLy8vh4pMuZoEgjV89gwK8JsfTs/MfPEHP/jBCTjNdloCJs3t7eq6Di/4dRzRlaETob/KoL9ctW4TrFi1HpavWCvTaIJp7I0XMmGm8ICO01gtS8HCl0xO2PsVwuIXvb8Ufb0nYPuD37FC5jYxMQEHDx9Cc73QpD8zIVqkdBrHS+kdWNJoYpJ2k2ZXVlZCGl0Xm3OrzXgCHJdHi0Hwqfvvv78bTqNFT2fn9evXr8EefQs7td7/vjJbA1df/2G47OpbYP3GbVBbt0yiWVZaJ5UUgc0Rv1cWVwnXE1pgFFH7W3X39A0xDULqmSHUZ/N7KpOF+uZV0H3ioAVe1EgjKioqYGh4CK8RaIQ86yWW/NLDbF68mWtf86+0+ddz53Itjy5lcmoShoaGYGRsVAHDJApd728ELcRqBHE1e/bu/SGcRluygCmeLc9k/q+gONZ2XKBAL4Cbb/8sNOFAIyiSRmOFMBrH5jgwPlRrovau0ggx8KhEfbx5rwTrBkXa36XV7FSmElrXbpbHDr0qcjNTVpMJ5WYyGRgZGbUmfGnCnN0WmxgOQsDcwvcE6p9nlgElGq1YgPHxcRjHqCCdTiuAZkwZjcu5bW1tO9EfH4YltiUL+OorrvgQDtR/84/ZtPU9cN1NvyQTiaTqHQtR+9CwhoL6SgADJmN+jHCF9AXrzqFvW/1mJg5bADAWgX6OJ1Kidd0WON7+GpCQ9fFSgRsye6OjYzhwSwOiZzIR5hJ8SFP932cJe25B53N5GEdXk81mVfhlWhzfNTc0NHy3o6NjSSHUonEqNzQbn8RNgj83Nq9Ek3wrgoOoEmyghCktCWGFazRZm2DlSwQTEEX2v/5LTwAZGEdtjpUWkBmNJ+DFFoJkn6mshRs+8ptQjltutHsKfdraNWsVqFlQaCX/FmuLCV4TJDoujpoYmraRaEThFV/Ycwoa387kpqGnt6eU2Lm0trb2F2GJbUka/Ouf+cw67N0f03jRZ0KCl115q2xY1ir8m9KRXEgbpUa3xmyD8ylGm+0Ut1ptTTZpqBTgH2MBmrZz9jsDzBLJtFi+qk32dLaLyfERM4igBrcCEesw+uRgvsC31NUuYTLMeRoia9BypNE9VKL2VVfVQHU1vapRG6twwmVUf2gMi0TCeP3RQxk+L0UDhCdiGF8bqxenQUcz/c+whLYkAV940UU34eaX+OrVtY2w7ZJrBTJNOobVmijmiGOFM9tOYEa7/VDJmXatkeYnFp4+VkqHdPizNPQAA7REMiPqlq2G/u4OmJoYsfdAwIuQ6gjGylKeIYLm5k8CT9i0JRS8bFkzNDY2Ql1tPdQowWaVq8hWZaG2phYa6uuhuqYGJ0IcMBUZ6k+pkBWCxpurRCF7om/FHb/a19e3qN9ZkolG83yRv29dfTMyUNVsio15Fc6M+iYVuP9ylinW4NizPkap+ZzKFLMZtmaeP2uw5gE56wqqkUi59MZPQE39CjdQ+KK4cx2aa4pDz1rzhY0mmTS3vq4OLUYFYoCENc2a5oypLSFkEvy5689F0qdBn2ZOk63bxOSEwhDeeGc2bNiwdSndW5KA0Zxs9j83oP9lwBRIDfDYr5LnD5RmCclol7aBESgLjT4W3XslX+1XnXBDcS84Xw5KYwOl6XxuFr6eNEJW17fIS278OFTVt5gj9FVIw1avXK0A2FIB1VzAar5GhEXEsFQ6WRHe8nv+nEDLEhRp1ISdKPZc5j0Jd3p62l1Eo862pfRnKckAukqrf9FsdYMWbqDjUS00DXzAaJISgHRayPubcQZrxrXkhLMEVhagJwRYLWUQF+h4mCe03T8w7oH7U40afNlNd6KQlwPYc0tFLLS0tKhQ6nTafIInDU0mNQ1J/HPUE6QvUF+w9KJ4lyZEKk0JloRNfoT9u1D75Qr5UpO4Zil9XtQHHz16tBb9128JnbtVWZ5NWy/HLE9WAyKDfNiLsC9WHQPnW8GENjxTjT9VhwUObEn3HqQPvMxlnFYTcveuHcYAHCcLKEuVQ23TKuWTZyZH7X1RJogGdXJSpxjPtJFvr6tvQJ/bBLW1dZCtqFRCjpQIuVTgpJX0os+VlVmM2cvVDedyORu3qzswo5FBcJZGLtt6ayEO7Nu370eL9W9RDc7EYnXCC4/iaNpiGHJoTQmEdbB2Ynlm2L70G9JgNr0cMhVtuOP5WqXt2szTedVxQWC0XE0cMPhKqveeVTC/OUZRmesVcMkNn5RZY67pNxpY8pMrW1tPW5Pt4OE5alCoyxFU1SJoqspmFblSKlj/RY2SIfTK5/NqMiCBpI5tbm6GLAp7VlyMn/OowQ6sqEFpWVIfF9uhEI1SYFmmzy1RwEmVxgsNKpvosFCF9Z3YwaI13xI8ciPsXz1f6p/Xmm4ALzD2XALwV5K76cfe6vhsXYu4+HoEXk2r1RGsJRQfr1zRqjTxdFsUQVMVhj4kJNLGEydPQldXlzp3qWB9f8rCpe3AwAAcweTI4OCg6nB5eYVF1b4W0/5WuPrVvJQ+LirgeCRCAramnIQbxcEwvhCc1dTbEKJVmhhYAQVeYkF6gEgywvY0nj2yu6WQG7DXMz7cWoOAfTpoEOdPnGzdCnjXtb9kgRefj1BtS3OLyumeTotGdWaIBNjd3Q379+2F/oH+OQEW9dEXLL/v6+uFzs5OFb7RZ0LZRfxNyvC1OAXKX+MgL19KHxcVMI5QI3YuwbOKTDRSg1aoWtsMOSH4szGVKkq23LOHulnYMmyWwQhWOCHycX5j0RvB2slinIUMWRJwn6lV1bXAhdd/kjTaOxcoM7miZYWq0FhqI/BDyQwSorZuCZXs98EU78dCZcGyoKlfyWSZyhWzX/arUBhwEU7win7o/xrKDyzWx0UFXNQzxToFAldG7XiQHW0YmMSCF+44/+qE638PWgBW68Nqqtkvjc10ZQcSs2wibEID/DQjmEkF7lpgkb0O46rrW+W7b/iUzNYtt+QV7UBCbiVzvUQhk4AIpJEwm5qaFDoHzzzrsQhCgvUFTa8ABUfom1C4Pt+kGldLeJiRp/MUC0V/tkcxKdGwWB8XD5M8W68I/FS585UKCGlME7A2eRpTCpzYhwZmcjiQpXlp8HywbTo2lFTsHNGYXE9q659EKGGhePHAxdq+tZCe9VDm+r2fgvLqRvCZJDLXpMl+vdZ8jQZ9EE0yHU904qrVazhiUEJn4ZYKlj6TptI2ipOpHlE4++aRkREACCNoHvsCkx3mM5rzZYv1cUkm2v+cwiQ+gBaor4nGpGotFtZcgvQjGzMb9ITwNUzXBBiSxIZFykDhe2HIyYmxQTE5OkBXN7oqBSc1PKE6j+ADOgXKnWbT91UUJ3/gi5A2CQoGDikjZL+Abr42Nj4GnV2dakIQIqfj8hjqzOVvaZvzfiOhlmN4RNfMzcyoqlAqOyIGrJRY0ZRlwB/UBgXcuFj/YovtgKdq8p1guiJrmCqwBlE6z6+8LvjCMwMcMHDSvynzqky5Ps6EPc7Eaz9GxweEpOGVHf8udz3/sNqzZc0WuOi6j8hkukrNBtot4P4EYCcYTx4Jzn1Ib8DoPQpXXn7774gd9/8ZTI702/vMoNlsbWmFE50nFqzxIiEdO9ahaMhWFHB9fV1IW1lTWUP5O/5MJjqXK6hiwa7uLuQZYirjxH3Uw6NBmkp5+oCkWFw0VFpQg7981VUxQQL2WjJVCbLEl/LAcZiiY1Y3iJpWZL9tCgFY0632Wd7ZTBTJIA0G+07Cnp89iTMCAQje5PFDr8DTP/h7MT7Sh+a4oHyuYN8rTHilYmdz7sCFWuBbEuwLuYgUavBlt//OnJrcihpJyHahRgN/6NBB2LXrFWVifY2dy++WvghBd6EViFFV5lw8uQAnYHDAUJbIZq62oICPtLY2So/kIBaLULTvz8yFeExM9ojdqdJSMAyT2d+ZcO2veG7oMwmDyBk80ZeBmvVGi4zp6u08DM8+/B2JGSO0XfRbREo/vpahW2GNlhyqAYBXSSJkuqIWLrn1i1BZH0bXFCe3LG9Z1FzTmPT198FLO1+CQ+2HlKB9IfN71lwy1bRPZ+dJjIX7FfqeOwniTDUnHPiO0M7VwyJtwV5ffPHFq/D0n8YRS4PKcybhnM3vQT9cKWWYhgSX1tM3KxybJEzuVhiKUk0EsAGRYUKE8sPsfIGPoWqGRFlK9Jxoh/GRAXYLqk2M9Ivx4QFR09QqkIChdA7w4ZJpMDUZhaE8+dpQ4lr0MYlUuahqXA2DPUchx7QmhT8qA5RS/laWzBy/6Xg3wBTgKPT29UFfby+Mj0+o8ImuoMwwEiFEapBQJzFLRLXUTG2WVnyUNtqP6EozNrRn1/4DB74HC7QFNRhtG5mABN9oDLU3Ekt4hIQ1zZrkB0ch+VUXDr2GTTpv9fyQgitz/H3JhNI1L8XMUG2jTv/5Q3ACzfWzP74HhY9olmJF1koBLnth5p1vqi0QAwvQ1PUrMYS64NpPQUVd2L1l0mlYsXxxc+3IDR27Tk1PovbmlAaTgIdHhvHeiujqkirJQAyaz3Qt1CzZwZ3HzO1ixywoYBRSE5Ec/DmGLFYsVgY+fegAlUkfAqNqjVptqASMsaRF3AC2TAt0TCt13ZW5CRs7476ZbDVc8f47Ucg2sWUnSV8XmusH74HJsQFlrhlda+JEgzmfRbMhFAhDlNgyIzVBSMhbr/0VqKgNm2uVhWpePq+QIyozlFYhUwUmHSrxRds4ujZNakioqqpSFR5UAEC/UfVHqJXI2Zd7MLuu7I35YOwR2XgnYNSkaKLMaJc0xAFjY2e9NLCSfuZHeiGRETIbYyVorsTk27I+mieEEDGoqK6HK27+hKwxmuw72r7Odnj+J98WkxMjIB38BJ4wjvt2PjrwYm8FwL34uQJDqAtu+KwVMrcy9MnLGpfNKWQy41TN0dRkKjowvqUyHTyx0mAWMPn1hOL0Ewp9L6UGjBrHwWwS8XyLEh0L+uB3bdv2Adxczp8rMQ+8tu0SVj4v5LDAKrTsRDqSSJh31hcKzWDQ3pgSjSj7jC5UClOOI4wXj7D7xF0pz1qWyoj6ZSthdLAPxrywhhr6ZOWns7WNyp+isfRcgSkXEfxZ94hTjuzz7SQkdIkxf7ZxtRg+dVj5ZB5cEi4BoqnpqRCtSN9xXKvAFIErBFMEqBhczZh4lxbLEWtFiXyqu/LN9EL1XlT+I5wPLlvW3PyVjo6OwpkK+GO4OZ8/N65YByvWbpG+MFmJAm/tEAAvoxRWT8EzPspPaQKDqlxoLzExOgj5mSmRSCaFYIpOgF7SYQoq1Go/jBHTmHGpblgOJ4/uhZnpKdtfuuLo4CkSsqiqa4YyFJCZNQ50mQJAAPedQu56UnEO2taMJdKVItu0Bka6j8DM1KjtP60wpOoQKqdhIavKi6lpGJ8YV0toaIUFvUiQVNhOwqRXDgWay+VVwTulAcn0ciHefE1NeBwsMvsRgxYVYxaJ3N3e3j4833ELIgY8RYOffU+mKyEIlcO65SWaP42ohQSMo/VhkmugzeCY/TVBpW7uZ0/dJzuP7lFSXbPpYrnxwmtRkAmhyksh/HwNutFpHKxDrz2LPndkjk5L6D66W3V+yxUflBW1RKUbktO6hzDYM0ALLPQ3uIDxRUXtCth07Z2w96lvw0jPEWCTkkRU24zmuOtUlyEtAlc/tQDapsGIRMm+ULeiqrx2LuFyFgo8GXCRAH/G9wS0Oua71GJMVjWfiFqqvMpSiZbU8Koxikhw6CuD87JGulqoFK2SVoItWug9eQgOvf6cIjFo19eRrZoaHyVBo6ltktFYQu1XLJK5m1bx7/6Xd0BXxz6YK+Dl1n30dRzEmDj/ml9ETc7iQMTtZNOHCO+zKc+1YEvphnRkjBQVyF1vvPLjsPvxb8LYwEm7L9GKjehru3tO6RIc0u7YogThrLbghPD2IeYLZMy6nkQ0umAsvFhPGkNEPLFYoKTqLy8x1y5Z9gmelkgwvpSQLT3+RgoN74Tyo5JLZhRwK8LBV3dA++5noaKqQaTU4u84+q1xGB/C2HF8mNFuKNRCYToyxPx2sv0VWukg3/XeT4h0tg4HP+o6DBpQmfeg1VawdxE6/WkDBXUPGRTyedd9Rr7+6N1ibOCENZNkqpsamzD27T3jpashbTUYJ7yD3lAttf0J989LWbvQeRdLNtgF3XTSZKbSomGNlDm0YNLAQ7+Su6D7XdT0pU4AgA1XZO2yNcoylDYyRcP9XdCFfvbYoVeh7+RhK9ySe4ZEMgObLrkJqmqW2Ztn39F7fJ948aG7YXy4H69flIztJFsWLVzJRQaSS0SFdtXSK9ml79M1y0UbmmuFroXT+jQh6IamM9LexRuTN3MkHCKRBTV4XgHfddddVLbhTDS+ELQYVCydFrEEjUkL+TYdhgjO0fqpQ6oUJRIjU1UPF1z1YRRyycMBSgQZ8kXelhL3m3/hdtmwsg22Xf/LGC/XzdqnH0Oonz36jzA1PoSBb9FmqIwztTVkAF7Bgo6dwcxdyaCR9imva5Ubrv40pLPhZA4xTY0NjbQGGt6MFhKw6X4hCGoB5o+z5kXRmzdvbsCB+F31QdGFSVi39QpEj0nrcw1LITzAZUApaBilj7UjoztpfaAVQqqiBhpWbMCwIgdjQz2K7uMbCt2g9z6OWtu8/mJYueUqTBLUi1QmK2ldUlPrRjHQ0wHTvKrBnGNiuA/DqAGoazmH2DgEn1EVIsnAA3HCLaEpvS7jCamjB5FAv167agv0H30FCjOTLoSKxpSgCTUvxa+ebqMYmsCdvTchXkPS5NHu7u45F6PNK+Dzzz+/BefhF/gzmcF1m69QoIdvWILjjcF8JxwF7RMXNiEf9tM0STR/HEukRO3ytbKhtU0kUhWKEtWhQUShsniyAjWmHqqa16JgL5Gtm66A6qbVUJbJCuTGqX8CkyF4bDk0tm5QWusvXaEujA12w3DvSSVkNVGNpgX6d0dlWs/LpbpeqtHDGNGyNAr5Ahg4uguKuUl7KQqhiPUqjZPPtPlsFpX60oI695s4jhPq3w8fPpyf69h5HYaC394MjCdSIPUjZ6QM51Yl2KyMgju0FTZUM3G7HRxpQijtxIWNRGMJSc+pydavkMmKelHIz1DxmUQGSJkH5HWFCYxBIDomyjSOM1nTp3GKFxDAIWGC23S2AS55/13yuR99XQydOma1i7Z9x/fCzoe+Adtu/AxaDjTnImqqL6R7EgHHxOCsiF9lIj0hl5XXwpZbfw9e/eGfwvRov/seGb/G+kbo6es5q88MKfo+WAOzKpxE88tx3hMVi1l9Hu1riaKMRGIhkAWMniXrtFDCViQGGL0VOqwC6Vgic1rSHPJ56pSIqYQa7ChpYYVEn0wvlaNNV9aIDGovaXB5VYNEPyuTiK7jyXIponEdd+HpC0WpnkuI2QmZrqwTF17/K1BZO7u6dKDzEOx65B+RncJUoyyCw1xuZaNZScGWR4eGuv+GBrCWWyYr6+Smm34LMrWtDl2CZrYa6hqWVP6z1KYL/ULceVbqxzrO2ea9ckyIGt+DxFRxuJhV+qrLawCMogoM4GmsSZFUHVUhPwXdR14V3Ud2QW56QqoHlel6Z5txIsCFEbR6QKQEZZIxjIqJCJrReDINsbKMchHkd6P4XRQnQUQJlqZPBAgbk2CLRAQE9Gg56gFy1yjci2/+HFQ1tIZvDg/rO7EXXn3iO8igId0pCwZzSWFNkfDrtjVPDZyrBl2PFhjqk35LVzfLc66+ExCAhQAi+eOGunp/EfeS2nx0pYq1w19lM5nMvAKe1wdvO//8y/EmbwYwaBUHa8X6d4FihUx6T/GM0pTXRDT1SK8occv40+TYkHjuR9+AI69th67Du2Dg1FFRvewcYqk0hQg2XBIamemum9SdURNieaKKe0CaUk8pZMwsIJJsMqUivTgEE7oPApG/bFxxriCfPE1hlrk/2o4NdMHwqQ6oXbFRFfSTBQG3MkOAMTqBzV9zcsLkIvW1BfvvBAK9TMMaMdZzGPJEa3Iog3E8lcVOTk29IeBFY0RULa3I0Deh0Sqa7a8jXTk61zHzajDeZMgHR9HXBZryk7a+KZB27RCNLpnmaES/HxnoEs89eDcM9R63Zn741FE4dXw/Eu7TmBkJdDoQOGwKVIWl0mZTu67WRxNDZjSpWNThjFqVyGVBwHlo/ZEoR9onX8TzSaROIzFIVTWgJt8FVY0r/YFRbbC7HV5+6O8p1QiUagxVMkJg/LKZS9LFwwy21D2YylDakpleexWGULUrQuNJaUEy10sp5PNbaZ7YPabR3kPVGZloPLH1wQr+xzU0dw8JVDtJ4XHSXPA9OTYIz/7obhhBoqL0coV8QZHtgUrOm76CdClIrqGSmvWy9VVWYcAOrgNBOn4tamtA8bUy1QV6Fcn8o5DRf7/rBlppODufPNh1CF599B6YmRzBMDmvhpRcDJPS/stfquqX5vJ6KHpfXrdSnnPtr6KQW+30UDwC+uS6mrrTFrLflLKwkHlQMdE33/6RBU4UOgjDGAA/pwp68LkwPaIyRJJiQvHiI98Byg5JD3DQTuVI9cUz1YrYdyBB/SgtC8YvEa6t8pCrdIOqQQ6HN0GRC/dYyFRLrIrvpIzGZXlNM1zw3k9APcbc2raCvUD/sT2w5wns92AXeXKKxYWJfg2t6WEP3waEJps25LRvqqpZrrnSaTLvQz65pqpmcSGLeeUSQtL0GVF6er7TLGSik7LERBd5MZhN5gtlxhgx03DsfelR6Os+GuoQtXK80cb1lyLdWYXhTVLqS5tqC7vqUAuav2cK0dMaEWj7DTzBihb0uMVuXJ1pzLVC16jJgsx1BWrwpis/rITMg86t69BLsG/HfWJioFOhaxUNSH9wrSAF94uL/R2yddIn4a6+4jNKk+0JQFeG1NfWn74mG6EH3rM9VD4qGq2a75CF8HuVuzGpNViGNMmFQCYXk5sehyO7nwtNPiIqsk1ITmy6WqbVsykrFZOkl4F665mkv0qRTbIE97QdTjB4i9588wngBlrH2lL7dGlMtd4qIdeRkO9AIZ9rtZjvqefoq7B/x/dRyF00NegygiMF3ofXQ/kTzZpwfdcmExWRGbzWKhQygi8nI2IGaV1xibleuC7LUQ2BdCbaWMLy+Y5ayAeX+zM8imGSeULNrIE1F0OkegSIoPA1v7ymBRrXXiSTSO2RcONlKYqnmRb0NM/FlWzZ7VonS4c691CczXsrzWJ/rcIvbaqFDp8ol0qfyZ/EJQn53Pd8AIFX66x770UhH3ruATEzPqLWYNh43l3HDa4eLRtWeTei6sNpzNJ4rZWXfUqmUKN9i0Fxck11DSyl4A7sOGsfLD3fhcdXzLf/Qhqc9u0Nxp5g40ApfYBjfePwQMljFLHjtSs3AxWWpyqqIJHCOBYZKx1tas0F52tF+DENXKlpBovNdOBld9z3MuwbeZIITaQQIiciRGuzzBtzXbVsHWy76fMaXfvOHlt3+0549eGva3aqWGAQKd1WSGdF7LossGu0vMmoslC1WpNJyD6KJ265rqb2tJau6uIE4VuezHz7LiRgq/bUQSIWpHnSnPSWhgQGxWIuVuRnpkInoFi3jHjispQow3RanIRrZoS30p+XkerzcPmsZyVAlgjWDapbVAYATqgGgZu1yYHWYKXJyh8r8IUuAoWcrmqS227+vAuhzH3RyfqP74FXf/I11OQBaRyJYFMZgHMlbh2ypmEDLwIA6TJUqdqVcuUVn8Vtq7N8hK5RyLVLFbKU1oRq9VITLn76AqZid3AmOEKr+nnW6iUhodpljIKp0M07XKpEfm5iUBV3C7eizBOGnY2SyQIAnxLUgi6yIIH9XBjQSK+M1/lH8PPOimCm02thUwhFIEyo2D6FaT8Schrj5XAgLGGo8yC8/sg3RG5iSKEFVuJIKOnkM3wyZAx49UTRTMhkbats/YXPQlm2KeTKyFyTkBcz19qKBb5rpC/OIEyiP1XjmWihFjmDQ9JgwxHye2rQsvWz/VnnvmdhaqRP2qjRS0tYIr9ozsk5Y1vHbHTJDFpgTZJZLejq46SHuDl9CeAKEKTxy2D8cgh4YaZDUm73otu+gLTmStd5M9gDSGvue/JemJkYFELlk3U1pp5UDtTZenCwJU2qD4HejRfsiSTmk9fc8F8gUWHq1o1WUhH8fEIOEzBuYqh71n+hZs62kAY7E40v9J1htCitFpvFnEJmkfNNVYQT97mpMQw9vi+GutpxbHK2XNEsFgvHkLyQXP/GdcoWYDkhukngvexSUZOodyDOQ+ZqQZoVsjLZmrsmdF3bAu++5dehGs21LBmOU+0vwe6H/w6mkfFCR4LmFAG5G34pnZl2S1rxY5EW3gXKZEs9CfS+8fI6WPu+LwFt/UY+ebEQyiYcWPnORMDSe4EFEGC3vFqeNFjHmVIR/OvfffOscxFDtPep7yKZsBeRbE6fNRKxsaM1pXaweLmnkCHUajQkbH6lJ0ihVjJa6tAK3Boi6eJXM0F1SKMsEPohZaYvvu03MNe8ygcxqg2gT9798N/AzJgGXlzfLb3KT+vz/f7qK5uH1DgsEUPhrrn5D6QVsukkrYUidP1GGC9uC2lwxmd6RKzM/QLWz6kZSa+iHiyob22TLW2XzjpdPjcFB356HwydOkzLBekowexIRMfSSoaB/p7lCRK8FfygBwh47gmLnjUat8Bem0m7+l/wRNGxKSPvQPlOZ/pVGiwagwwK+ZJbfhUt0uwVFENIa+559O9FfpLqw4quiB+MQeL+eCZZ3QPoVKqnOKq/8UwdrLrhd2WyptWEjtLEyeiTq2eba+mBLCeE4IxQdNynGqki0YZH4ABE4CcJlBJFxdoL3gvL1m1TjxqeJeQd/0y1xaJYyOv8kfDNmhYko2yfNQvCvt8gMP+mQaN8cKCLSRL1I9Vsg9Zw4QyTSZgIM+IaJau/ClNepQrnQ4NrtqTJB5/CfPJ4PwVfjvABK1wWhIkI/NDOTkQdK2J/EtllYvnlCLyqvQllfDLRmnPmk4WwLu7MUPTsZk2nT7IzaKHQMq/MdFRi/laec9Et0NJ2GVVfuIMB1NPm9j79XcwstSO4mvGGzZo3RT8ChPKxPGY+crbhCE8Ahwm9Z0oDA0NNOligGPjI3E1cmnU0WXc+9C3R07E3pL128EH75D0P/i2a6wGIGCFLaZXYCtOtsNQL8LTgLT6w91KGoVPz5Z+DsppWOxbUqP5KMV6esoS0eJG2oID55q0v4gBfumwKgIdQDXAhw0VJ+pVbroYVGy9VQnbrboAqKWDfU/dinLkXM3Q5EyVFpN3BC5X80lzgASoJk8BPTAhdgG9pTevLjcLwBHEX05kjnTBR2taxewec3P+iHgQuMptD0MPdB2DvT/4GgZfSZKETUGYZ1hwmOXCTUwtbcNJGf09CXoZCTtQ47pp+V5pMPrnEItp+LfTHv+b7ATsRehpXIZ+zGsHPwJLShEkEKij/6qXoZERpshLysnXvosp01yk638wkHHnh39CnHVBCJlPFDJEx18qc6kM0MtbXd5QlRyo+gJIeggYv6yWtTwfp98OUcnDZoKB+HXzhx+DHqPRbVfM6oGxUqc5Q/w88fjcUpkZ1gkKNqrda1upICGXrbZiV05qMwm2+8te1Jnv+l7jr6qoqSCfTCmmbO9ZjqZ52NXebF6Zt3bqVKiozPBhN6y6EZEWtlK44zb+GYbekzfupuYxIORKNivLa5VBE/zs+3KOgDTfirScGO1XhWrK8RlVzgRaO8EIeXZ+r+V5wj2Cw+Ve3WMzmpvVHZt7MPZiAWa+KUjlfleIkDaaVi/rP2fV2vAZHX34kpLGp6kZYd8ntUNPahrHwEMb1/ebe9T5TeF8Y64vymuUQS5frwTBBOghPuIIDRAHgleea0nFGmjKSrIBU/Vox1dsOxakR7r8qqqfKEFplyRIwlvWRI0eOPA6nJeAtWz4qvWdkVTWtoZSfYaIMvpZufS0Lhk2nQqs6o0LP9ZDZ+lWqRGO0/4QTMu6Yn55QQo4lK0VZRQ2o2h879bncVgqDMAWPm7O5RleMsMETpnlvxpgpFiFNClsLF9+RcM1L7v/p/WK07wT4+rt883VQuewcyFQvk9nGNWJipBemRvvsHrTvJN7D9FifqsmKoYBAlRnRE3F1WROfzP9s+y5dlaq6OYK0qSpI1q+Dqd5DaB1c+a93I3YM8Zh/Onr06EtwOgLesmXLFXjwFv6cRNalumWD9kmBs388EIF09lKtMgRrC6mYSj3fsqJuuVpk5guZ9sljmnHk1CFIVjVBIl1NPluyhnrgyc14fm8ssbqkfeSw8PolpBO0rtkCmxlS2iucgNHO5afF/u3fh/zMpB3MZLYB6tuuhnimRtJ64WSmRlRi+DSptTY0ZpNDp5Q/JiHHy8pFYGq+pZRevTWwm9GlBM7CmC1bIdTYVFYJeWbgGBQmh/TB3r72hEHwv490dByDOdq8Phh/eM3/PIZCCQpFW40R+E7NDKiOJxFT6tBJkyCkpco/R0QskYHWzVdD4+rzZ12PfN+Jl38M0xPDUCzk2ESIkgGQvr9ilkpd2zFb4MCUB3KkBTrCf6SDbTgpx4d60G1Mu4GjeBTdRyRRTiQIovuoUJUh9avkuvd8CCobV9t92VwPHH0Fjr3wr5BHrYuqONm5M+DhktJFBdw/7rN5yDqDwUTNSln3njshUbXCIf0w8B3MSzmncI0c526yUNjuLq4FnJsacZpJHdIPBPeS8ioZrSozzJNfpV6DBAZdR9B8laM/uxWWb7yM6pdDAzQ1fAp69++AQm4aQ6iCZa191Fy0a4YMgDQD4T832stUqcNDJa8lEYGbAIGYGhvUT3rlMSDQU9moGC7AUDNAkeUR9xUAcUXTObD5pi9oIZe0vvYX4cAjfwM5NNmRoKhrIri8mON9jS3C98CKYkbFhHUiUd0KtRd/EsmmpBkR8PtIcH/4tAU8XSzuxE6d4lErIEjqbn/ZodrAVTZSPy3CZvMoXUWFJkFoH7qnmIyjkNdceCO0nne5FrLXBo7uxGtNEIgnDyyFKewz2c9wNkr4mM6GlNa3WWED2CoQi7y9h5Pbe6LlpzJcd6ziePrbUGhuc3iSHFqjvCnkS2ab5Hkk5IZVPNr2uKHjr8P+R/4as2kDyFkH2j/oEBBAuDyx7a/0681LUqO4TdSulsmG9fqLcMbrwauuumoUTlfA6m/WSvljO6D46jn0AuSmJ22mh7+3jyT0eGRP01SIUyBzjRIuFEnKUVXEvur8a6F2ufkDpqbTBQRdU0PdIijMCMN0aegJoQemWP9shKQfQmpoTJdw16YvKBlAXjmoEg96f02umL/8zYNPLaC/lUAMmIqvdQYqr7JQxGFFUcOb4Lybv4AcdqO9Bz52BEOo9se+JgpIa0Zk0ZQ3CWdlPQsSsAXUkAKYEOF7AaSKo+lajcSl48gTAD9c6A9JL0x0CPFv2KExnmZkQukRBi5gh1D1gs8maZIB9AoAo8WuIA7UMhhaZNa41vhj6bIjCjVSWg6HNSpUCCN1cX3EqojkRAT4fTD5VxFKIWqhA9jHKQWW6VR91DRrAAzw9Hwz15lBM0sJcJNMFjSXKdbPkaDRyBTRIiUqGmHLLb8NFazJtpNSafKRp74p8lMkZEpQBN6DYNjfyvCiejmbYQuQhyhMDjgroX97/sEnnji2kAwXFHBnZ+dPcPMif6Za5s7dT0KR/36A58cC5l3BywqBATbmczFgwsFkeiie81esc6dwrxgCcVoFEyNcI3RII/y/nuaZVzfjPYsiXT21rqwAR3YYzVf4QEpbYpvGeJ0six583aYHT6KQB/WDukGzZFyOm1cmm4QcRx65BTX5iyjk2T65v/0FaH/kryCP3DUtWo2YR0aF6BDdL7ATUEIIWefGemD61L6QdcH2NVikLZiPoj+AuLmtDW9B3IpnVZNhBlEu3USysp7DFc90huM5yaMPYIviQa+A0J9xrxO7t8PYQGfoupND3XDq4POi5+DzMIaJCczaiLJMtWbDIjbEtYkHDoe0W1Zy99G3BA5NwKBU0Idzf7hv9KKYfLTnqO1LgKiaplWmYR1IlVHTTzwNBF/TXDYaldFEWtSs3ISm+aAaJ79NjfTARO8RyK44D3A/aRbMAZMxzqWYzhlso9wPKtbwrn8Ruf7DVoPx/1OIgT630COUFhUwtXedc86JIBa7HW+hTpMNgYpba9dso7tS8g2MqTEXZm5YgP+ndCSvfsB0hDa5AgdPdux6TOTo4WXmenQgxqMqXCngdSaGulToMYpxMk0sXYAfgYDLZNx1fZIDjG7oK1pe2ATBKi+o+yUMe6yIZBp2BE99R3YSindaPHQSc7f1GKoswx3iwBWhkmmpCN8vLbNNQ9Xyc2HkxD6MOkad0PAYyiNPDZyAqpVbEZgnKKQE45S1FdI+XGhvJsCYbzEz2AHDO78tZPjP//zJk08++TQs0hYV8K79+6c3tbWl8HLXgDHpHMwns42CBWeQoWOewvlbYdaKCc6Sk8mdHh8Ux155RNVu+cjVohCzpXc51IjhE7shU78S4vQwGKE1ST93GtzTfNQldfmPZUJ4AgqPVZIGuDlEqo6OpSthtPswTKPGudlDUzgCqaY2zKIgrFHrJoXwfaQ2K1pIFCVUr2iDse52mBkfYt5P7UfnnRlFWrNpnaCVkiZUUn2RLgXKLJ2gheXDL90L+eFOf4gG41NTv3L45MkpeKMCpraxrW0/DuQN+HYZMynE2tStuVDSel6+QZtg5xsWfONmdPnp7WamjqNp7jn4XPhicxWdMfjCUG305D6RrG4W9GgkMtlS2QLj+wMzSGadsnUhfBpgLpgnnpO1MfdEeEACY9/RE3vU0lduido1UFa/VkZjScXMeYIFFoy2/kLRlMRksbnOTQyFbmcStXii5zBkWzfTUwKksTIWVPHEpPfjh56G8YOPC4/5o5KYrz62Y8dPYAltSQLeu3fv1JbzzsN0CdyEV47ThTF7giHTmCCfYgcNwvSlFrre6PhNj7BlkdDcDR55WZlkvyUyNVCG1Cgh2tLf6PPIyT2IARpxn1r794utzzfXNQoNTCVZM61nqCf0iE3rBWb5abSsEmKZWpgZ6VYgkISbWXUxancNal2Kqj6oilQ67TOTRNhab5XBoGxadesmQeGSErIDR6jZ/VbIEbVqRFskfQ86cTM90AEjr/wTBJxw0JHGk4np6d9bivZSW3LRT0tr66FkIkExzUb+bhrDpiT6pWR2mRkssB1hhBC4AbB+kGc+kRxUj0SAJBLPQLppA9SsvxyqV16AA7MZzdx5yjwSQHF/pwFUenG897AqPaXJoCs+9QCD5GlkZewoSQHWgMiS3wNwlRdk8alfyWWbIdl8HpQ1bZTog0U8Va40GLQGC3BWyk0saarsNQZBi56G6uXr0ey3z9JkYrrQJ4uq1q1IhieMCzHWpJAXIy9/D2Z693tjCgX8/9cef+aZPbDEtmQBt7e3Fzedd94evNL7gJ+Ah76T4sTKpvUQRb8jS4TLiNYL7m02SBMTRKhXoW/bgMI9F6guKV5eK+n5kIlUJcbJlaKiYSXe7DSS+6dCyyaLmGqcwhAmUYHgp1xloZS5lrwDuGgzIiLakBuMBSbZ4CyOpgQV2yb5u4gmF8rKUcMyIlaWJvSLViWqf5Pg53KlV+juJrrySpqerWxaizxCN0xzFspo8/TIKRzDXkxJtuAYVtJzUBTLNnH0ORjb+2PFB4BzzPdcedVVf/nUU09JWGI7rbK9PXv29LVt2DCFGnM9yYbGilayU6KgonkjrX6wmRDrm8D6KPveltqwEkTjqMFJHMAUouS0IKRMj2+Ixcsw9EiKysY1kkKlcZOF4rsjlD01eALi6SqVU9aaxVEQKGSs/qC6Ru6WMDFZfrPCwvelbvmpRr4RhZrVE3/oqQRRfX4dahlZcmZL+kybt65YP41AxNNZmalvFUrImG70sQbF2nkErmU1KyGCvntm8DgMvfAtCKZHfavYgWP2kXvuuWcCTqOddl0mavFe7NpKvOJW9rDTo73K3GYa1gr7lAuLqsHGqPol/fJY9mWC/G0kmpD0bA4lKKEfn6QSetG4qKhfSVwxCvk4+KlGEvJY9wGkDBuM344CPxqf5BnRTBhEo/TMEKGhHuGA/JSxLhFdOutzwWCSF6D7JjU1YUIxwUWywo8SPBQPnryBc9k0IGiZcIxWSqJiSci+GpK/pyI+smiDz38TCkhseL/nEUF++qmnn34FTrOdtoARcBXO27x5N3b8w8KsLCdTTVUNlM8l8GMmr3/TNjY1bwXnj1WIQ0KW5s/FAg+ysCZdPXU2Fofy2haqqBBTg10+m0Or8pFEOAxppAoTOED0HIuIqdAg4caUcPV0CWYm4NRrP4Ge1x4WUxhjx5FmRDusJmYp4eBPTLDg0aJzAEug6PCIfC9HGQoxiBAIk/QMkDgKOZ1tEhP9HSr081sOhZzvPQAhSlKIGTzB15BY+WsinuA02xlVVqOpHtq4ceOhSCTyIWnOQX5ytGsfmuo28iVMOhjhmqExyW8dQno37+I/ozmGYBd2IZnOK8VQkxvXquL5KQyxpFcZQuh6vGs/lKOQyzKVqmicKzXoWdtEd5KGHH3m29Cz5wkEOL0w2YtxKlqfsmXnSf1wmYgzz8AytZUqku/BzF1hdwCb1JcMIk23tOClLf9Vj4qKl1cjo7VZjHbvhzwCL95fPTM6CP0haCLLH8G7/G30u+NwBu2MS+c/+tGPtvf39uJUg2vBPASkSOj21EGoWrWNHnfkCA87i51vBhfWGBPO1Q2eJnk5Uy3wCK1TluW1K6m4FSb6j2shG4aa4uSxzn3qeRy02DxmhEzaTCzS0Z9+D1mxn4EZPbUpzoxDWcuFisAgNyMtOcLC49SdhrhSay1LGiyjpZur+wIXEjq8wTMGJyuGUBXLz4NxFDJlm2IUVpkHmQpX7/xaJBr9AjJWR+EM2xkLmJDcuy+66PX89DSV31/MMFnRi8i5Vq29RCjiy/ouZ/5UuGORta2zMiGUNuPghTeBR/BIFV3FIVPXKpHqFJN9x2z4RI00ebQTNbm+FYVcJ+lPwBZmxuDw0/eKfoy5Pe1ULVa9GhINGyXGt0I9VM30wVgQcMDJHcfkjWQlthks9aMovYbz6xGTEhRCPVE5nsbooQ0mTryCmpsz2MG2oZgQv/nYE09shzfQ3tDil127dhXWb9jwIvq6y/AuWvn73Pgg5CaHoByRNT0ZjUMjMCSDnskaybLkwoMorA+WZiQD1izJ1ZpKyCKHSHNq0EtWkLlGSzJ07HUqhBODJ/ZCx/P3i5HuQ/Z3e/Pof1PnXIt51moRRY1SGuwJ1fSFDRBbIavAhhI1/XeUp7VU4F760tLkrW2iAhVihJgqHR04ZE3lLH8+PDZ293wPGV1qE3AW2u23374S5+bD2MFz7Zd4B9XrLoXmSz6mwiA1MpYalmHGy5IgEBpccxoOo0H/TSINmChGiwhM4aGJ7Xn9YejZ/ThwOYe1Et5WOr+mttHyBshsug2imTr15B+qhNQmGsAmS0LHAXjVm+47pkXNFrSGmrs1+5lwShlng6pJlsWJftn70B9jnnfQZKd1w5/+z8jY2B/t3Llzyj1J8MzaG1++hm3fvn0jGzdteh5v8HowD2+hXlGMShUameY2CYZEciaOBRtOOfKx0rvhwGm2lJZg0OiaYtRM/RqhkHTf0Vl9m2t0ouWNkD7vAzJe3iBimSoq0Bf6CQYhjMDGxmWnvH6wu5AeDaoziYbfNly3tDqvDzT+WOaRIOp/5E8ECjnUNxTo36bLy/8AXeD0GxWuulc4Sw2F3NW2bt3D6PR+GT+m1Jc4IpPIp9JfEE03nKNIeDCFARq/2KpH6flqKXkf6ed4Q+jUhli61CMK6frValJM9nWAL9aQicL4Ol63DlLrb0DNrRcxJEiIZRL6+SPsUy1eAA8HWAAIYV/rWR82GAZAehy4F07ROfKDHWJ4+5+LwrgjPGgnRCz/Ultf/2sPPPDADGVT4Sy0s2Ki/fbBD37wGjzpD/BOy63JQRKjduN1ULf1Vltk5wggv5CuxASqgznKkjau5k6zuVbcflBU2Z8JRPEjHS/BVP8xKFI+lmqh4siMZeohXn8ugqpVEElXyximHIk1oz+4hTGV+SOa+tSBpzcu3laJCGn7pTvsIgF3U94+bLrdfeYHj8Ho838HheHjITyA736Kod1tjz/++ACcxXbWBUzttttu+ygCr28BabJnaqvXXwkN7/4oaYzzucrsBr7WQKkvlrwkRTnkiLSiB70ygYZVZWjpL24jR53HHGoeSQQqYC+aPyknqeSUBB1NIrecxlcSlHCFmIWSdV/MZDPZBBn6rbSP0tvPaqQMIWp8Uxgi4X4dikMdpe7oCRTup59YpL7qTNqbImASBgKvj+LJvxoEwXL/t8rVF0PjRQi8Einp7x8SqIRZQEsKT5mMv1M3YJL4wmp2gMRaUZBgqXYsoCXlVK9LbBnSHWpyiZihyPhP0vKCNQleJQW4tU4waxKYpIr+1fvzO3MDRgm5nj0wvvNeKIx22hOxcJPJ5B0PP/zwILwJ7U0RMDW62Q994AMfwZv4C3w1WUOHN1feug0aLv44MV7WTEvfLIIZA5OU4rjZDpqBMha5qhMz0DGnoOI42lWtWVZ8iCsEMEtrQtdSqI2OmyOOne1OQn0BmMsC2HGA6WPPwcSu74KcGvYsg2o/Q8294WybZb+9OX8eBDQw2nLBBfcVpfwS3tVRMPCXbmwMA/vuZ75BBLstPucQyq8odA9lMWGLXapiap0Dl/1RtdgA0hTaiwLtTpVxahGYSjsoJBeotCII+wrMKgPp11IDI3Yb79rVEoF0z62QXv8AQs8woW0Rd5o5/qKcePnbECAv4PPnOCtoNeCH30zhmuu8+e2WW265DX3lV/CtipPZFKZq10LN+R+AVOMG41VZm9iX2RIWY/7ce3UeH6Z4cWtYO3VMypOIzUKpxnrncf6WNN7/nRk4OymNZgdcA+ZpbjEnpg89Lid33y9kLpzhw8nyLVSA38dQqB/e5HbWwqSF2sGDBw+sX79+J76lR8Yv4+/zGOBP9x+BWKZGZ3WA65KMcHmw/HW16nvJDpgXa83pJ73v+HdhJC7CE0XIOfhl99nlQlSZqPSYObde2qNW81Ni8tXvw/S+fxeyEC45wsP/Fv//Igp33uUmZ7O9JQKmhkI+2bZ+/fOYr70SB7beQBRF9s+gkDFZCvEq/dfEQkyRegOaEnRLZISXwQHehZ1liT93iXiGPGwKwF7HFOuBOwcwEubkQTj7ZY83GI+tASbpxeTP7oXckafpaUIc2dGW/oDwvalU6ncfe+yx00rav5H2lphov73//e9fjlj2PjRT7wn9gGRFtu1GqNp8Cz3a1vvTPQ6VWhsowtoH4GuvQ7K8uxWsPdesxIDR4ED4CYSQ2TZ/Tsh+p4CbuYapBSuMnISpV74LuVOvhZAyvu/DPn+lt7f3/2E+PQdvYXvLNJgbavLYlrVrf5jXfxZ1o7CPTAxguvcgxq8DUFa3FvmQpNNekBb4uDCGNVCpnQBrN32T7AsWQol60BqowZvwkLT5fQ5UHOINze7aiiOay538mZzc+S1R6D9UesuHZbH4R5gg+fpLL72Uh7e4veUCpra3vX3y0ubmhycTCWT35RX+b7mhEzCDgi6rXQORZBaktZKWJ7TmcQ5Ty8u5LNXJTJiRuT1Oes/z8MywniOyNLtlt9JNOMc5zxx8BCZ33o3medh1RCf6OzGfe9dTTz/9r2dSjXE22s9FwNR2dXQUtm7dur1YLHbhUFGSIsphRBHjRcqRxrPNyBk3gAVFYZ7Y+Un9ZUj7+BgGVfZYvb+Q/v5cbhtKHvgTxyLz0FIZCq6ndn1HTO++H7gY0PhbavtRuHcgO/UM/BzbW+6D52ji5ptvvh5HkVbKreIvle1E3rpy861QvuFGjNhjYHldvYNfChT2qdJpnfnoTwqPECth0Hx/r6Tlf/Z8Ku5XHDqGYOofoNB/wPseWHv/Ad/9FiLleVfev1Xt7SBg1W666aYmjA3vRX92nSz5rayxDbIXIvNV0QQwK851+/lEBRgBcbouhIoZqNF+4Ti4FHy587Kwacno8WcRTN0LEiMAq7Xad+Rwv/+KYOov32owNV972wiYGiLsNPLIf4Vv7+TvGDmTP66+7PMyUb9e6HJW3iFELTKYAqdvWklDMS/Tm1Cqtby/PkHgPVdDfS7OyOm9PxS5fT8iDhRcF9Ru9Dfef/upHTv+GcIG5Ofafm4+eK6GCDu/vKXl4XgsRms8LpDe3yKQhRmYPv4SUo9xTPmt1AvALMnPaToPIBlX6wAUcLgD4Py0NDE24zWdePDMM+9b6G+HqZ3fFIXjz1nh8uTD1wuYu/zgU9u3PwVvs/a2EjA1WtD8sY9//IXuU6eeASquR+aLDar6EwGn9mBO9aiMVa8AUVapwZMeaS3IMPINMVNGyCGCw0wFEYq1fa0OCjJ3+Ekxves7UBw+Bv6T+qjqBl/fiMbjn3nyySdPwNuwva1MdGl73/ve14Jm73/g21/GwXYPrMZXpKwCMps/BMnVlwP/eVkbwrAGggFSMAtoMRALm3r2tfSRkheT/TCz+1+h0LkTpLeU1PjbgxgBfCVTUfGdhx56aAbepu1tLWBq5JdxIH8Nk7pfwo91Psii7ifXXQ2ptltkJFUNYdCkkww+5wxOky2Y0hsoAW5SFnr2oNYi5hvtDmmt2icIfiqKxV994pln9p6Nuqk3s73tBUzty1/+cuTZZ5+9HDv7p/jx3WDSnBoNRyFauQzSm++AePMW6VQXQpkf9ZVwKNrTYjBvNbAqTksEUSJ34CHMCJUoppQ5PPZbhSD4g2eeeWYI3gHtHSFgbmSyUZt/DzH05xDhpny+V0TLoAzNdXLjreSbGUxppCW9QnaDqP24mE17oXevnHn9PlEcaHcXlVxSJfchh/4lvO5DGN+evb/Z/ia3d5SAqaGQy4J8/kYZifwhDvtFfhKdWrSqFRKrfwFiTVshkq5XS45CJtjGx2BSjVKBp1z7o1A48QL46T3la4WYwX2/FwTBH2/fvv0ovMPaO07A3G64+upNQSz2v1AK9OyQEACjeulodjnEVlwCsfo2EJk69UcpAfRzlqFYUDFtMHgMtRZReeeLQk66kigmL/DcXWSSZ/L5P3vuuefelJqpN7u9YwVM7Y6rriofisW+EBHiNzD92OKvDjBIV+cbaNVCskqZcYWyZ8YgmBpSsbVPhXFcS1qL7x7Dc/7Pq6+++oWFHhX4dm/vaAFTIwCG2rUGU3JfRYFch19lLAHhtxD69kiK0C5KuiehWPwziEa/caZLNt9O7R0vYL9df80170MQ9If49lJpnsznmVtHdnALJ+XzmLP980Kh8A87duzYV7rrO7X9hxIwt2uuuWYbmuuPIX14Dcasm8Fn7MKaPIDv6UFdVOF4z9sh+3O2239IAfvtqquuoqdor0MJtyCDnNRPxgsGo9Ho8dra2pPqscn/2f6zvVPb/wfvreZgQ6SUOwAAAABJRU5ErkJggg==";
var ah = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
}, fc = Qt.createContext && /* @__PURE__ */ Qt.createContext(ah), _g = ["attr", "size", "title"];
function $g(t, r) {
  if (t == null)
    return {};
  var e = em(t, r), i, n;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(t);
    for (n = 0; n < s.length; n++)
      i = s[n], !(r.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(t, i) && (e[i] = t[i]);
  }
  return e;
}
function em(t, r) {
  if (t == null)
    return {};
  var e = {}, i = Object.keys(t), n, s;
  for (s = 0; s < i.length; s++)
    n = i[s], !(r.indexOf(n) >= 0) && (e[n] = t[n]);
  return e;
}
function Es() {
  return Es = Object.assign ? Object.assign.bind() : function(t) {
    for (var r = 1; r < arguments.length; r++) {
      var e = arguments[r];
      for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    }
    return t;
  }, Es.apply(this, arguments);
}
function pc(t, r) {
  var e = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    r && (i = i.filter(function(n) {
      return Object.getOwnPropertyDescriptor(t, n).enumerable;
    })), e.push.apply(e, i);
  }
  return e;
}
function Ps(t) {
  for (var r = 1; r < arguments.length; r++) {
    var e = arguments[r] != null ? arguments[r] : {};
    r % 2 ? pc(Object(e), !0).forEach(function(i) {
      tm(t, i, e[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(e)) : pc(Object(e)).forEach(function(i) {
      Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(e, i));
    });
  }
  return t;
}
function tm(t, r, e) {
  return r = rm(r), r in t ? Object.defineProperty(t, r, { value: e, enumerable: !0, configurable: !0, writable: !0 }) : t[r] = e, t;
}
function rm(t) {
  var r = im(t, "string");
  return typeof r == "symbol" ? r : String(r);
}
function im(t, r) {
  if (typeof t != "object" || t === null)
    return t;
  var e = t[Symbol.toPrimitive];
  if (e !== void 0) {
    var i = e.call(t, r || "default");
    if (typeof i != "object")
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(t);
}
function oh(t) {
  return t && t.map((r, e) => /* @__PURE__ */ Qt.createElement(r.tag, Ps({
    key: e
  }, r.attr), oh(r.child)));
}
function kn(t) {
  return (r) => /* @__PURE__ */ Qt.createElement(nm, Es({
    attr: Ps({}, t.attr)
  }, r), oh(t.child));
}
function nm(t) {
  var r = (e) => {
    var {
      attr: i,
      size: n,
      title: s
    } = t, l = $g(t, _g), m = n || e.size || "1em", A;
    return e.className && (A = e.className), t.className && (A = (A ? A + " " : "") + t.className), /* @__PURE__ */ Qt.createElement("svg", Es({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, e.attr, i, l, {
      className: A,
      style: Ps(Ps({
        color: t.color || e.color
      }, e.style), t.style),
      height: m,
      width: m,
      xmlns: "http://www.w3.org/2000/svg"
    }), s && /* @__PURE__ */ Qt.createElement("title", null, s), t.children);
  };
  return fc !== void 0 ? /* @__PURE__ */ Qt.createElement(fc.Consumer, null, (e) => r(e)) : r(ah);
}
function sm(t) {
  return kn({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l128 128c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 288 480 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-370.7 0 73.4-73.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-128 128z" }, child: [] }] })(t);
}
function am(t) {
  return kn({ tag: "svg", attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M502.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-128-128c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l370.7 0-73.4 73.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l128-128z" }, child: [] }] })(t);
}
function om(t) {
  return kn({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M384 352c-17.7 0-32 14.3-32 32s14.3 32 32 32H544c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32s-32 14.3-32 32v82.7L342.6 137.4c-12.5-12.5-32.8-12.5-45.3 0L192 242.7 54.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0L320 205.3 466.7 352H384z" }, child: [] }] })(t);
}
function lm(t) {
  return kn({ tag: "svg", attr: { viewBox: "0 0 576 512" }, child: [{ tag: "path", attr: { d: "M384 160c-17.7 0-32-14.3-32-32s14.3-32 32-32H544c17.7 0 32 14.3 32 32V288c0 17.7-14.3 32-32 32s-32-14.3-32-32V205.3L342.6 374.6c-12.5 12.5-32.8 12.5-45.3 0L192 269.3 54.6 406.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l160-160c12.5-12.5 32.8-12.5 45.3 0L320 306.7 466.7 160H384z" }, child: [] }] })(t);
}
function cm(t) {
  return kn({ tag: "svg", attr: { fill: "currentColor", viewBox: "0 0 16 16" }, child: [{ tag: "path", attr: { d: "M3 9.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3m5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3" }, child: [] }] })(t);
}
function lh(t) {
  return kn({ tag: "svg", attr: { viewBox: "0 0 15 15", fill: "none" }, child: [{ tag: "path", attr: { fillRule: "evenodd", clipRule: "evenodd", d: "M12.8536 2.85355C13.0488 2.65829 13.0488 2.34171 12.8536 2.14645C12.6583 1.95118 12.3417 1.95118 12.1464 2.14645L7.5 6.79289L2.85355 2.14645C2.65829 1.95118 2.34171 1.95118 2.14645 2.14645C1.95118 2.34171 1.95118 2.65829 2.14645 2.85355L6.79289 7.5L2.14645 12.1464C1.95118 12.3417 1.95118 12.6583 2.14645 12.8536C2.34171 13.0488 2.65829 13.0488 2.85355 12.8536L7.5 8.20711L12.1464 12.8536C12.3417 13.0488 12.6583 13.0488 12.8536 12.8536C13.0488 12.6583 13.0488 12.3417 12.8536 12.1464L8.20711 7.5L12.8536 2.85355Z", fill: "currentColor" }, child: [] }] })(t);
}
const hm = ({ badge: t, className: r }) => /* @__PURE__ */ se.jsx(
  "img",
  {
    src: `https://leetcode.com${t.icon}`,
    alt: t.name,
    className: r
  }
), dm = ({ name: t }) => {
  const r = {
    Knight: Zg,
    Guardian: Jg
  };
  return /* @__PURE__ */ se.jsx(se.Fragment, { children: /* @__PURE__ */ se.jsx("img", { src: r[t], alt: t, className: "h-auto w-full min-w-[30px] max-w-[40px]" }) });
}, um = ({ direction: t, className: r }) => {
  if (t === "NONE")
    return null;
  const e = t === "UP" ? lm : om;
  return /* @__PURE__ */ se.jsx("div", { children: /* @__PURE__ */ se.jsx(e, { className: `${t === "UP" ? "text-green-500" : "text-red-500"} ${r || ""}` }) });
}, fm = ({
  size: t = 80,
  solvedProblems: r,
  totalProblems: e,
  trackWidth: i = 4,
  trackColor: n = "#ddd",
  indicatorWidth: s = 5,
  indicatorColor: l = "#07c",
  indicatorCap: m = "round",
  label: A = "Loading...",
  labelColor: Y = "#333",
  spinnerMode: q = !1
}) => {
  const [T, B] = At(!1), O = () => B((u) => !u), b = (r / e * 100).toFixed(1), v = t / 2, E = v - (i > s ? i : s), M = 2 * Math.PI * E, g = M * ((100 - Number(b)) / 100);
  let C = !!(t < 100 || !A.length || q);
  const j = b.split(".")[0], D = b.split(".")[1];
  return /* @__PURE__ */ se.jsx(se.Fragment, { children: /* @__PURE__ */ se.jsxs("div", { className: "relative", style: { width: t, height: t }, onMouseOver: O, onMouseOut: O, children: [
    /* @__PURE__ */ se.jsxs("svg", { className: "-rotate-90", style: { width: t, height: t }, children: [
      /* @__PURE__ */ se.jsx(
        "circle",
        {
          className: "svg-pi-track",
          cx: v,
          cy: v,
          fill: "transparent",
          r: E,
          stroke: n,
          strokeWidth: i
        }
      ),
      /* @__PURE__ */ se.jsx(
        "circle",
        {
          cx: v,
          cy: v,
          fill: "transparent",
          r: E,
          stroke: l,
          strokeWidth: s,
          strokeDasharray: M,
          strokeDashoffset: g,
          strokeLinecap: m
        }
      )
    ] }),
    !C && /* @__PURE__ */ se.jsxs(
      "div",
      {
        className: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 text-center",
        style: { color: Y },
        children: [
          /* @__PURE__ */ se.jsx("div", { className: "text-[24px] font-medium text-dark-label-1", children: T ? /* @__PURE__ */ se.jsxs("span", { children: [
            j,
            /* @__PURE__ */ se.jsxs("span", { className: "text-xs", children: [
              ".",
              D,
              "%"
            ] })
          ] }) : r }),
          /* @__PURE__ */ se.jsx("div", { className: "whitespace-nowrap text-xs text-dark-label-3", children: A })
        ]
      }
    )
  ] }) });
}, pm = ({ width: t, level: r }) => {
  const e = {
    Easy: {
      track: "bg-dark-green-1",
      indicator: "bg-dark-olive"
    },
    Medium: {
      track: "bg-dark-yellow-1",
      indicator: "bg-dark-yellow"
    },
    Hard: {
      track: "bg-dark-red-1",
      indicator: "bg-dark-red-s"
    }
  };
  return /* @__PURE__ */ se.jsxs("div", { className: "relative h-2 w-full overflow-hidden rounded-full h-1 max-w-none", children: [
    /* @__PURE__ */ se.jsx("div", { className: `absolute h-full w-full bg-dark-green-1 ${e[r].track}` }),
    /* @__PURE__ */ se.jsx(
      "div",
      {
        className: `absolute h-full rounded-full transition-all duration-300 ease-out bg-dark-olive ${e[r].indicator}`,
        style: {
          width: `${t}%`
        }
      }
    )
  ] });
}, gm = () => /* @__PURE__ */ se.jsx("span", { className: "text-dark-blue flex items-center pr-2 visible", children: /* @__PURE__ */ se.jsx(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: "1em",
    height: "1em",
    fill: "currentColor",
    className: "w-4 h-4",
    "aria-hidden": "true",
    children: /* @__PURE__ */ se.jsx(
      "path",
      {
        fillRule: "evenodd",
        d: "M9.688 15.898l-3.98-3.98a1 1 0 00-1.415 1.414L8.98 18.02a1 1 0 001.415 0L20.707 7.707a1 1 0 00-1.414-1.414l-9.605 9.605z",
        clipRule: "evenodd"
      }
    )
  }
) }), mm = ({
  options: t,
  onOptionClick: r,
  selectedOption: e
}) => {
  const [i, n] = At(!0), s = () => n((l) => !l);
  return /* @__PURE__ */ se.jsx("div", { className: "ml-[21px]", children: /* @__PURE__ */ se.jsxs("div", { className: "relative", children: [
    /* @__PURE__ */ se.jsxs(
      "button",
      {
        className: "flex cursor-pointer items-center rounded px-3 py-1.5 text-left focus:outline-none whitespace-nowrap bg-dark-fill-3 text-dark-label-2 hover:bg-[#ffffff24] active:bg-dark-fill-3",
        id: "drop-down",
        type: "button",
        "aria-haspopup": "true",
        "aria-expanded": "false",
        onClick: s,
        children: [
          e.name,
          /* @__PURE__ */ se.jsx(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              viewBox: "0 0 24 24",
              width: "1em",
              height: "1em",
              fill: "currentColor",
              className: "pointer-events-none ml-3",
              "aria-hidden": "true",
              children: /* @__PURE__ */ se.jsx(
                "path",
                {
                  fillRule: "evenodd",
                  d: "M4.929 7.913l7.078 7.057 7.064-7.057a1 1 0 111.414 1.414l-7.77 7.764a1 1 0 01-1.415 0L3.515 9.328a1 1 0 011.414-1.414z",
                  clipRule: "evenodd"
                }
              )
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ se.jsx(
      "ul",
      {
        className: "absolute max-h-56 overflow-auto rounded-lg p-2 z-dropdown focus:outline-none bg-dark-overlay-3 right-0 mt-2 shadow-dark-level3 dropdown-filter",
        "aria-labelledby": "headlessui-listbox-button-:r1qj:",
        "aria-orientation": "vertical",
        id: "headlessui-listbox-options-:r2hi:",
        role: "listbox",
        tabIndex: -1,
        hidden: i,
        children: t.map(({ name: l, value: m }) => /* @__PURE__ */ se.jsxs(
          "li",
          {
            className: "relative flex h-8 cursor-pointer select-none py-1.5 pl-2 text-dark-label-2 hover:text-[#ffffff] hover:rounded hover:bg-[#ffffff1a]",
            id: m,
            role: "option",
            tabIndex: -1,
            "aria-selected": "true",
            onClick: () => {
              r({ name: l, value: m }), s();
            },
            children: [
              /* @__PURE__ */ se.jsx("div", { className: "flex h-5 flex-1 items-center pr-2 font-medium", children: /* @__PURE__ */ se.jsx("div", { className: "whitespace-nowrap", children: l }) }),
              /* @__PURE__ */ se.jsx(Et, { when: e.value === m, children: /* @__PURE__ */ se.jsx(gm, {}) })
            ]
          },
          crypto.randomUUID()
        ))
      }
    )
  ] }) });
}, ym = () => /* @__PURE__ */ se.jsxs(
  "div",
  {
    className: "max-w-sm p-4 rounded shadow animate-pulse md:p-6 border-[#ffffff14] h-80",
    children: [
      /* @__PURE__ */ se.jsx("div", { className: "h-2.5 rounded-full bg-[#ffffff14] w-32 mb-2.5" }),
      /* @__PURE__ */ se.jsx("div", { className: "w-48 h-2 mb-10 rounded-full bg-[#ffffff14]" }),
      /* @__PURE__ */ se.jsxs("div", { className: "flex items-baseline", children: [
        /* @__PURE__ */ se.jsx("div", { className: "w-full h-32 bg-[#ffffff14]" }),
        /* @__PURE__ */ se.jsx("div", { className: "w-full h-40 ms-4 bg-[#ffffff14]" }),
        /* @__PURE__ */ se.jsx("div", { className: "w-full h-32 ms-4 bg-[#ffffff14]" }),
        /* @__PURE__ */ se.jsx("div", { className: "w-full h-44 ms-4 bg-[#ffffff14]" }),
        /* @__PURE__ */ se.jsx("div", { className: "w-full h-40 ms-4 bg-[#ffffff14]" }),
        /* @__PURE__ */ se.jsx("div", { className: "w-full h-32 ms-4 bg-[#ffffff14]" }),
        /* @__PURE__ */ se.jsx("div", { className: "w-full h-40 ms-4 bg-[#ffffff14]" })
      ] })
    ]
  }
), bm = () => /* @__PURE__ */ se.jsxs("div", { className: "w-full flex flex-col rounded shadow animate-pulse border-gray-700", children: [
  /* @__PURE__ */ se.jsx("div", { className: "h-3.5 rounded-full bg-[#ffffff14] w-40 mb-2.5" }),
  /* @__PURE__ */ se.jsxs("div", { className: "flex gap-6 w-full", children: [
    /* @__PURE__ */ se.jsx("div", { className: "w-[100px] h-[100px] rounded-full bg-[#ffffff14] mt-4 mr-2" }),
    /* @__PURE__ */ se.jsxs("div", { className: "flex flex-col w-[80%] gap-4", children: [
      /* @__PURE__ */ se.jsxs("div", { className: "w-full flex flex-col gap-2", children: [
        /* @__PURE__ */ se.jsxs("div", { className: "w-full h-3.5 flex justify-between", children: [
          /* @__PURE__ */ se.jsx("div", { className: "w-32 h-full bg-[#ffffff14] rounded-full" }),
          /* @__PURE__ */ se.jsx("div", { className: "w-32 h-full bg-[#ffffff14] rounded-full" })
        ] }),
        /* @__PURE__ */ se.jsx("div", { className: "w-full h-3 bg-[#ffffff14] rounded-full" })
      ] }),
      /* @__PURE__ */ se.jsxs("div", { className: "w-full flex flex-col gap-2", children: [
        /* @__PURE__ */ se.jsxs("div", { className: "w-full h-3.5 flex justify-between", children: [
          /* @__PURE__ */ se.jsx("div", { className: "w-32 h-full bg-[#ffffff14] rounded-full" }),
          /* @__PURE__ */ se.jsx("div", { className: "w-32 h-full bg-[#ffffff14] rounded-full" })
        ] }),
        /* @__PURE__ */ se.jsx("div", { className: "w-full h-3 bg-[#ffffff14] rounded-full" })
      ] }),
      /* @__PURE__ */ se.jsxs("div", { className: "w-full flex flex-col gap-2", children: [
        /* @__PURE__ */ se.jsxs("div", { className: "w-full h-3.5 flex justify-between", children: [
          /* @__PURE__ */ se.jsx("div", { className: "w-32 h-full bg-[#ffffff14] rounded-full" }),
          /* @__PURE__ */ se.jsx("div", { className: "w-32 h-full bg-[#ffffff14] rounded-full" })
        ] }),
        /* @__PURE__ */ se.jsx("div", { className: "w-full h-3 bg-[#ffffff14] rounded-full" })
      ] })
    ] })
  ] })
] }), vm = ({
  userContestDetails: t
}) => {
  var l;
  const {
    attendedContestsCount: r,
    rating: e,
    globalRanking: i,
    totalParticipants: n
  } = t || {}, s = ((l = t == null ? void 0 : t.badge) == null ? void 0 : l.name) || "";
  return /* @__PURE__ */ se.jsxs("div", { className: "flex ", children: [
    " ",
    /* @__PURE__ */ se.jsxs("div", { className: "flex gap-4 items-start", children: [
      /* @__PURE__ */ se.jsxs("div", { className: "flex flex-col", children: [
        /* @__PURE__ */ se.jsx("div", { className: "text-xs text-dark-label-3 font-medium", children: "Contest Rating" }),
        /* @__PURE__ */ se.jsx("div", { className: "text-dark-label-1 text-xl md:text-2xl", children: Math.round(e || 0).toLocaleString("en-US") })
      ] }),
      s && /* @__PURE__ */ se.jsxs("div", { className: "flex items-center gap-1", children: [
        /* @__PURE__ */ se.jsx(dm, { name: s }),
        /* @__PURE__ */ se.jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ se.jsx("div", { className: "text-xs text-dark-label-3 font-medium", children: "Level" }),
          /* @__PURE__ */ se.jsx("div", { className: "text-sm leading-[22px] text-dark-blue-s", children: s })
        ] })
      ] }),
      /* @__PURE__ */ se.jsxs("div", { className: "text-xs", children: [
        /* @__PURE__ */ se.jsx("div", { className: "text-dark-label-3 font-medium", children: "Global Ranking" }),
        /* @__PURE__ */ se.jsxs("div", { className: "text-dark-label-1 font-medium leading-[22px]", children: [
          i == null ? void 0 : i.toLocaleString("en-US"),
          /* @__PURE__ */ se.jsxs("span", { className: "text-dark-label-4 font-medium", children: [
            "/",
            n == null ? void 0 : n.toLocaleString("en-US")
          ] })
        ] })
      ] }),
      /* @__PURE__ */ se.jsxs("div", { className: "hidden md:block text-xs", children: [
        /* @__PURE__ */ se.jsx("div", { className: "text-dark-label-3 font-medium", children: "Attended" }),
        /* @__PURE__ */ se.jsx("div", { className: "text-dark-label-1 font-medium leading-[22px]", children: r == null ? void 0 : r.toLocaleString("en-US") })
      ] })
    ] })
  ] });
};
var ch = { exports: {} };
(function(t) {
  /**
  * Highcharts JS v11.4.1 (2024-04-04)
  *
  * (c) 2009-2024 Torstein Honsi
  *
  * License: www.highcharts.com/license
  */
  (function(r, e) {
    t.exports ? (e.default = e, t.exports = r && r.document ? e(r) : e) : (r.Highcharts && r.Highcharts.error(16, !0), r.Highcharts = e(r));
  })(typeof window < "u" ? window : Mo, function(r) {
    var e = {};
    function i(n, s, l, m) {
      n.hasOwnProperty(s) || (n[s] = m.apply(null, l), typeof CustomEvent == "function" && r.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: s, module: n[s] } })));
    }
    return i(e, "Core/Globals.js", [], function() {
      var n, s;
      return (s = n || (n = {})).SVG_NS = "http://www.w3.org/2000/svg", s.product = "Highcharts", s.version = "11.4.1", s.win = r !== void 0 ? r : {}, s.doc = s.win.document, s.svg = s.doc && s.doc.createElementNS && !!s.doc.createElementNS(s.SVG_NS, "svg").createSVGRect, s.userAgent = s.win.navigator && s.win.navigator.userAgent || "", s.isChrome = s.userAgent.indexOf("Chrome") !== -1, s.isFirefox = s.userAgent.indexOf("Firefox") !== -1, s.isMS = /(edge|msie|trident)/i.test(s.userAgent) && !s.win.opera, s.isSafari = !s.isChrome && s.userAgent.indexOf("Safari") !== -1, s.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(s.userAgent), s.isWebKit = s.userAgent.indexOf("AppleWebKit") !== -1, s.deg2rad = 2 * Math.PI / 360, s.hasBidiBug = s.isFirefox && 4 > parseInt(s.userAgent.split("Firefox/")[1], 10), s.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"], s.noop = function() {
      }, s.supportsPassiveEvents = function() {
        let l = !1;
        if (!s.isMS) {
          let m = Object.defineProperty({}, "passive", { get: function() {
            l = !0;
          } });
          s.win.addEventListener && s.win.removeEventListener && (s.win.addEventListener("testPassive", s.noop, m), s.win.removeEventListener("testPassive", s.noop, m));
        }
        return l;
      }(), s.charts = [], s.composed = [], s.dateFormats = {}, s.seriesTypes = {}, s.symbolSizes = {}, s.chartCount = 0, n;
    }), i(e, "Core/Utilities.js", [e["Core/Globals.js"]], function(n) {
      let s, { charts: l, doc: m, win: A } = n;
      function Y(o, a, c, d) {
        let S = a ? "Highcharts error" : "Highcharts warning";
        o === 32 && (o = `${S}: Deprecated member`);
        let P = E(o), G = P ? `${S} #${o}: www.highcharts.com/errors/${o}/` : o.toString();
        if (d !== void 0) {
          let x = "";
          P && (G += "?"), z(d, function(Q, J) {
            x += `
 - ${J}: ${Q}`, P && (G += encodeURI(J) + "=" + encodeURI(Q));
          }), G += x;
        }
        h(n, "displayError", { chart: c, code: o, message: G, params: d }, function() {
          if (a)
            throw Error(G);
          A.console && Y.messages.indexOf(G) === -1 && console.warn(G);
        }), Y.messages.push(G);
      }
      function q(o, a) {
        return parseInt(o, a || 10);
      }
      function T(o) {
        return typeof o == "string";
      }
      function B(o) {
        let a = Object.prototype.toString.call(o);
        return a === "[object Array]" || a === "[object Array Iterator]";
      }
      function O(o, a) {
        return !!o && typeof o == "object" && (!a || !B(o));
      }
      function b(o) {
        return O(o) && typeof o.nodeType == "number";
      }
      function v(o) {
        let a = o && o.constructor;
        return !!(O(o, !0) && !b(o) && a && a.name && a.name !== "Object");
      }
      function E(o) {
        return typeof o == "number" && !isNaN(o) && o < 1 / 0 && o > -1 / 0;
      }
      function M(o) {
        return o != null;
      }
      function g(o, a, c) {
        let d, S = T(a) && !M(c), P = (G, x) => {
          M(G) ? o.setAttribute(x, G) : S ? (d = o.getAttribute(x)) || x !== "class" || (d = o.getAttribute(x + "Name")) : o.removeAttribute(x);
        };
        return T(a) ? P(c, a) : z(a, P), d;
      }
      function C(o) {
        return B(o) ? o : [o];
      }
      function j(o, a) {
        let c;
        for (c in o || (o = {}), a)
          o[c] = a[c];
        return o;
      }
      function D() {
        let o = arguments, a = o.length;
        for (let c = 0; c < a; c++) {
          let d = o[c];
          if (d != null)
            return d;
        }
      }
      function u(o, a) {
        j(o.style, a);
      }
      function R(o) {
        return Math.pow(10, Math.floor(Math.log(o) / Math.LN10));
      }
      function K(o, a) {
        return o > 1e14 ? o : parseFloat(o.toPrecision(a || 14));
      }
      (Y || (Y = {})).messages = [], Math.easeInOutSine = function(o) {
        return -0.5 * (Math.cos(Math.PI * o) - 1);
      };
      let I = Array.prototype.find ? function(o, a) {
        return o.find(a);
      } : function(o, a) {
        let c, d = o.length;
        for (c = 0; c < d; c++)
          if (a(o[c], c))
            return o[c];
      };
      function z(o, a, c) {
        for (let d in o)
          Object.hasOwnProperty.call(o, d) && a.call(c || o[d], o[d], d, o);
      }
      function k(o, a, c) {
        function d(G, x) {
          let Q = o.removeEventListener;
          Q && Q.call(o, G, x, !1);
        }
        function S(G) {
          let x, Q;
          o.nodeName && (a ? (x = {})[a] = !0 : x = G, z(x, function(J, ie) {
            if (G[ie])
              for (Q = G[ie].length; Q--; )
                d(ie, G[ie][Q].fn);
          }));
        }
        let P = typeof o == "function" && o.prototype || o;
        if (Object.hasOwnProperty.call(P, "hcEvents")) {
          let G = P.hcEvents;
          if (a) {
            let x = G[a] || [];
            c ? (G[a] = x.filter(function(Q) {
              return c !== Q.fn;
            }), d(a, c)) : (S(G), G[a] = []);
          } else
            S(G), delete P.hcEvents;
        }
      }
      function h(o, a, c, d) {
        if (c = c || {}, m.createEvent && (o.dispatchEvent || o.fireEvent && o !== n)) {
          let S = m.createEvent("Events");
          S.initEvent(a, !0, !0), c = j(S, c), o.dispatchEvent ? o.dispatchEvent(c) : o.fireEvent(a, c);
        } else if (o.hcEvents) {
          c.target || j(c, { preventDefault: function() {
            c.defaultPrevented = !0;
          }, target: o, type: a });
          let S = [], P = o, G = !1;
          for (; P.hcEvents; )
            Object.hasOwnProperty.call(P, "hcEvents") && P.hcEvents[a] && (S.length && (G = !0), S.unshift.apply(S, P.hcEvents[a])), P = Object.getPrototypeOf(P);
          G && S.sort((x, Q) => x.order - Q.order), S.forEach((x) => {
            x.fn.call(o, c) === !1 && c.preventDefault();
          });
        }
        d && !c.defaultPrevented && d.call(o, c);
      }
      z({ map: "map", each: "forEach", grep: "filter", reduce: "reduce", some: "some" }, function(o, a) {
        n[a] = function(c) {
          return Y(32, !1, void 0, { [`Highcharts.${a}`]: `use Array.${o}` }), Array.prototype[o].apply(c, [].slice.call(arguments, 1));
        };
      });
      let F = function() {
        let o = Math.random().toString(36).substring(2, 9) + "-", a = 0;
        return function() {
          return "highcharts-" + (s ? "" : o) + a++;
        };
      }();
      return A.jQuery && (A.jQuery.fn.highcharts = function() {
        let o = [].slice.call(arguments);
        if (this[0])
          return o[0] ? (new n[T(o[0]) ? o.shift() : "Chart"](this[0], o[0], o[1]), this) : l[g(this[0], "data-highcharts-chart")];
      }), { addEvent: function(o, a, c, d = {}) {
        let S = typeof o == "function" && o.prototype || o;
        Object.hasOwnProperty.call(S, "hcEvents") || (S.hcEvents = {});
        let P = S.hcEvents;
        n.Point && o instanceof n.Point && o.series && o.series.chart && (o.series.chart.runTrackerClick = !0);
        let G = o.addEventListener;
        G && G.call(o, a, c, !!n.supportsPassiveEvents && { passive: d.passive === void 0 ? a.indexOf("touch") !== -1 : d.passive, capture: !1 }), P[a] || (P[a] = []);
        let x = { fn: c, order: typeof d.order == "number" ? d.order : 1 / 0 };
        return P[a].push(x), P[a].sort((Q, J) => Q.order - J.order), function() {
          k(o, a, c);
        };
      }, arrayMax: function(o) {
        let a = o.length, c = o[0];
        for (; a--; )
          o[a] > c && (c = o[a]);
        return c;
      }, arrayMin: function(o) {
        let a = o.length, c = o[0];
        for (; a--; )
          o[a] < c && (c = o[a]);
        return c;
      }, attr: g, clamp: function(o, a, c) {
        return o > a ? o < c ? o : c : a;
      }, clearTimeout: function(o) {
        M(o) && clearTimeout(o);
      }, correctFloat: K, createElement: function(o, a, c, d, S) {
        let P = m.createElement(o);
        return a && j(P, a), S && u(P, { padding: "0", border: "none", margin: "0" }), c && u(P, c), d && d.appendChild(P), P;
      }, css: u, defined: M, destroyObjectProperties: function(o, a, c) {
        z(o, function(d, S) {
          d !== a && (d != null && d.destroy) && d.destroy(), (d != null && d.destroy || !c) && delete o[S];
        });
      }, diffObjects: function(o, a, c, d) {
        let S = {};
        return function P(G, x, Q, J) {
          let ie = c ? x : G;
          z(G, function(te, $) {
            if (!J && d && d.indexOf($) > -1 && x[$]) {
              te = C(te), Q[$] = [];
              for (let oe = 0; oe < Math.max(te.length, x[$].length); oe++)
                x[$][oe] && (te[oe] === void 0 ? Q[$][oe] = x[$][oe] : (Q[$][oe] = {}, P(te[oe], x[$][oe], Q[$][oe], J + 1)));
            } else
              O(te, !0) && !te.nodeType ? (Q[$] = B(te) ? [] : {}, P(te, x[$] || {}, Q[$], J + 1), Object.keys(Q[$]).length !== 0 || $ === "colorAxis" && J === 0 || delete Q[$]) : (G[$] !== x[$] || $ in G && !($ in x)) && $ !== "__proto__" && $ !== "constructor" && (Q[$] = ie[$]);
          });
        }(o, a, S, 0), S;
      }, discardElement: function(o) {
        o && o.parentElement && o.parentElement.removeChild(o);
      }, erase: function(o, a) {
        let c = o.length;
        for (; c--; )
          if (o[c] === a) {
            o.splice(c, 1);
            break;
          }
      }, error: Y, extend: j, extendClass: function(o, a) {
        let c = function() {
        };
        return c.prototype = new o(), j(c.prototype, a), c;
      }, find: I, fireEvent: h, getClosestDistance: function(o, a) {
        let c, d, S, P = !a;
        return o.forEach((G) => {
          if (G.length > 1)
            for (S = G.length - 1; S > 0; S--)
              (d = G[S] - G[S - 1]) < 0 && !P ? (a == null || a(), a = void 0) : d && (c === void 0 || d < c) && (c = d);
        }), c;
      }, getMagnitude: R, getNestedProperty: function(o, a) {
        let c = o.split(".");
        for (; c.length && M(a); ) {
          let d = c.shift();
          if (d === void 0 || d === "__proto__")
            return;
          if (d === "this") {
            let P;
            return O(a) && (P = a["@this"]), P ?? a;
          }
          let S = a[d];
          if (!M(S) || typeof S == "function" || typeof S.nodeType == "number" || S === A)
            return;
          a = S;
        }
        return a;
      }, getStyle: function o(a, c, d) {
        let S;
        if (c === "width") {
          let G = Math.min(a.offsetWidth, a.scrollWidth), x = a.getBoundingClientRect && a.getBoundingClientRect().width;
          return x < G && x >= G - 1 && (G = Math.floor(x)), Math.max(0, G - (o(a, "padding-left", !0) || 0) - (o(a, "padding-right", !0) || 0));
        }
        if (c === "height")
          return Math.max(0, Math.min(a.offsetHeight, a.scrollHeight) - (o(a, "padding-top", !0) || 0) - (o(a, "padding-bottom", !0) || 0));
        let P = A.getComputedStyle(a, void 0);
        return P && (S = P.getPropertyValue(c), D(d, c !== "opacity") && (S = q(S))), S;
      }, inArray: function(o, a, c) {
        return Y(32, !1, void 0, { "Highcharts.inArray": "use Array.indexOf" }), a.indexOf(o, c);
      }, insertItem: function(o, a) {
        let c, d = o.options.index, S = a.length;
        for (c = o.options.isInternal ? S : 0; c < S + 1; c++)
          if (!a[c] || E(d) && d < D(a[c].options.index, a[c]._i) || a[c].options.isInternal) {
            a.splice(c, 0, o);
            break;
          }
        return c;
      }, isArray: B, isClass: v, isDOMElement: b, isFunction: function(o) {
        return typeof o == "function";
      }, isNumber: E, isObject: O, isString: T, keys: function(o) {
        return Y(32, !1, void 0, { "Highcharts.keys": "use Object.keys" }), Object.keys(o);
      }, merge: function() {
        let o, a = arguments, c = {}, d = function(P, G) {
          return typeof P != "object" && (P = {}), z(G, function(x, Q) {
            Q !== "__proto__" && Q !== "constructor" && (!O(x, !0) || v(x) || b(x) ? P[Q] = G[Q] : P[Q] = d(P[Q] || {}, x));
          }), P;
        };
        a[0] === !0 && (c = a[1], a = Array.prototype.slice.call(a, 2));
        let S = a.length;
        for (o = 0; o < S; o++)
          c = d(c, a[o]);
        return c;
      }, normalizeTickInterval: function(o, a, c, d, S) {
        let P, G = o;
        c = D(c, R(o));
        let x = o / c;
        for (!a && (a = S ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], d === !1 && (c === 1 ? a = a.filter(function(Q) {
          return Q % 1 == 0;
        }) : c <= 0.1 && (a = [1 / c]))), P = 0; P < a.length && (G = a[P], (!S || !(G * c >= o)) && (S || !(x <= (a[P] + (a[P + 1] || a[P])) / 2))); P++)
          ;
        return K(G * c, -Math.round(Math.log(1e-3) / Math.LN10));
      }, objectEach: z, offset: function(o) {
        let a = m.documentElement, c = o.parentElement || o.parentNode ? o.getBoundingClientRect() : { top: 0, left: 0, width: 0, height: 0 };
        return { top: c.top + (A.pageYOffset || a.scrollTop) - (a.clientTop || 0), left: c.left + (A.pageXOffset || a.scrollLeft) - (a.clientLeft || 0), width: c.width, height: c.height };
      }, pad: function(o, a, c) {
        return Array((a || 2) + 1 - String(o).replace("-", "").length).join(c || "0") + o;
      }, pick: D, pInt: q, pushUnique: function(o, a) {
        return 0 > o.indexOf(a) && !!o.push(a);
      }, relativeLength: function(o, a, c) {
        return /%$/.test(o) ? a * parseFloat(o) / 100 + (c || 0) : parseFloat(o);
      }, removeEvent: k, replaceNested: function(o, ...a) {
        let c, d;
        do
          for (d of (c = o, a))
            o = o.replace(d[0], d[1]);
        while (o !== c);
        return o;
      }, splat: C, stableSort: function(o, a) {
        let c, d, S = o.length;
        for (d = 0; d < S; d++)
          o[d].safeI = d;
        for (o.sort(function(P, G) {
          return (c = a(P, G)) === 0 ? P.safeI - G.safeI : c;
        }), d = 0; d < S; d++)
          delete o[d].safeI;
      }, syncTimeout: function(o, a, c) {
        return a > 0 ? setTimeout(o, a, c) : (o.call(0, c), -1);
      }, timeUnits: { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 24192e5, year: 314496e5 }, uniqueKey: F, useSerialIds: function(o) {
        return s = D(o, s);
      }, wrap: function(o, a, c) {
        let d = o[a];
        o[a] = function() {
          let S = arguments, P = this;
          return c.apply(this, [function() {
            return d.apply(P, arguments.length ? arguments : S);
          }].concat([].slice.call(arguments)));
        };
      } };
    }), i(e, "Core/Chart/ChartDefaults.js", [], function() {
      return { alignThresholds: !1, panning: { enabled: !1, type: "x" }, styledMode: !1, borderRadius: 0, colorCount: 10, allowMutatingData: !0, ignoreHiddenSeries: !0, spacing: [10, 10, 15, 10], resetZoomButton: { theme: {}, position: {} }, reflow: !0, type: "line", zooming: { singleTouch: !1, resetButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } } }, width: null, height: null, borderColor: "#334eff", backgroundColor: "#ffffff", plotBorderColor: "#cccccc" };
    }), i(e, "Core/Color/Palettes.js", [], function() {
      return { colors: ["#2caffe", "#544fc5", "#00e272", "#fe6a35", "#6b8abc", "#d568fb", "#2ee0ca", "#fa4b42", "#feb56a", "#91e8e1"] };
    }), i(e, "Core/Time.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(n, s) {
      let { win: l } = n, { defined: m, error: A, extend: Y, isNumber: q, isObject: T, merge: B, objectEach: O, pad: b, pick: v, splat: E, timeUnits: M } = s, g = n.isSafari && l.Intl && l.Intl.DateTimeFormat.prototype.formatRange, C = n.isSafari && l.Intl && !l.Intl.DateTimeFormat.prototype.formatRange;
      class j {
        constructor(u) {
          this.options = {}, this.useUTC = !1, this.variableTimezone = !1, this.Date = l.Date, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.update(u);
        }
        get(u, R) {
          if (this.variableTimezone || this.timezoneOffset) {
            let K = R.getTime(), I = K - this.getTimezoneOffset(R);
            R.setTime(I);
            let z = R["getUTC" + u]();
            return R.setTime(K), z;
          }
          return this.useUTC ? R["getUTC" + u]() : R["get" + u]();
        }
        set(u, R, K) {
          if (this.variableTimezone || this.timezoneOffset) {
            if (u === "Milliseconds" || u === "Seconds" || u === "Minutes" && this.getTimezoneOffset(R) % 36e5 == 0)
              return R["setUTC" + u](K);
            let I = this.getTimezoneOffset(R), z = R.getTime() - I;
            R.setTime(z), R["setUTC" + u](K);
            let k = this.getTimezoneOffset(R);
            return z = R.getTime() + k, R.setTime(z);
          }
          return this.useUTC || g && u === "FullYear" ? R["setUTC" + u](K) : R["set" + u](K);
        }
        update(u = {}) {
          let R = v(u.useUTC, !0);
          this.options = u = B(!0, this.options, u), this.Date = u.Date || l.Date || Date, this.useUTC = R, this.timezoneOffset = R && u.timezoneOffset || void 0, this.getTimezoneOffset = this.timezoneOffsetFunction(), this.variableTimezone = R && !!(u.getTimezoneOffset || u.timezone);
        }
        makeTime(u, R, K, I, z, k) {
          let h, F, o;
          return this.useUTC ? (h = this.Date.UTC.apply(0, arguments), F = this.getTimezoneOffset(h), h += F, F !== (o = this.getTimezoneOffset(h)) ? h += o - F : F - 36e5 !== this.getTimezoneOffset(h - 36e5) || C || (h -= 36e5)) : h = new this.Date(u, R, v(K, 1), v(I, 0), v(z, 0), v(k, 0)).getTime(), h;
        }
        timezoneOffsetFunction() {
          let u = this, R = this.options, K = R.getTimezoneOffset;
          return this.useUTC ? R.timezone ? (I) => {
            try {
              let z = `shortOffset,${R.timezone || ""}`, [k, h, F, o, a = 0] = (j.formatCache[z] = j.formatCache[z] || Intl.DateTimeFormat("en", { timeZone: R.timezone, timeZoneName: "shortOffset" })).format(I).split(/(GMT|:)/).map(Number), c = -(36e5 * (F + a / 60));
              if (q(c))
                return c;
            } catch {
              A(34);
            }
            return 0;
          } : this.useUTC && K ? (I) => 6e4 * K(I.valueOf()) : () => 6e4 * (u.timezoneOffset || 0) : (I) => 6e4 * new Date(I.toString()).getTimezoneOffset();
        }
        dateFormat(u, R, K) {
          if (!m(R) || isNaN(R))
            return n.defaultOptions.lang && n.defaultOptions.lang.invalidDate || "";
          u = v(u, "%Y-%m-%d %H:%M:%S");
          let I = this, z = new this.Date(R), k = this.get("Hours", z), h = this.get("Day", z), F = this.get("Date", z), o = this.get("Month", z), a = this.get("FullYear", z), c = n.defaultOptions.lang, d = c && c.weekdays, S = c && c.shortWeekdays;
          return O(Y({ a: S ? S[h] : d[h].substr(0, 3), A: d[h], d: b(F), e: b(F, 2, " "), w: h, b: c.shortMonths[o], B: c.months[o], m: b(o + 1), o: o + 1, y: a.toString().substr(2, 2), Y: a, H: b(k), k, I: b(k % 12 || 12), l: k % 12 || 12, M: b(this.get("Minutes", z)), p: k < 12 ? "AM" : "PM", P: k < 12 ? "am" : "pm", S: b(this.get("Seconds", z)), L: b(Math.floor(R % 1e3), 3) }, n.dateFormats), function(P, G) {
            for (; u.indexOf("%" + G) !== -1; )
              u = u.replace("%" + G, typeof P == "function" ? P.call(I, R) : P);
          }), K ? u.substr(0, 1).toUpperCase() + u.substr(1) : u;
        }
        resolveDTLFormat(u) {
          return T(u, !0) ? u : { main: (u = E(u))[0], from: u[1], to: u[2] };
        }
        getTimeTicks(u, R, K, I) {
          let z, k, h, F, o = this, a = o.Date, c = [], d = {}, S = new a(R), P = u.unitRange, G = u.count || 1;
          if (I = v(I, 1), m(R)) {
            o.set("Milliseconds", S, P >= M.second ? 0 : G * Math.floor(o.get("Milliseconds", S) / G)), P >= M.second && o.set("Seconds", S, P >= M.minute ? 0 : G * Math.floor(o.get("Seconds", S) / G)), P >= M.minute && o.set("Minutes", S, P >= M.hour ? 0 : G * Math.floor(o.get("Minutes", S) / G)), P >= M.hour && o.set("Hours", S, P >= M.day ? 0 : G * Math.floor(o.get("Hours", S) / G)), P >= M.day && o.set("Date", S, P >= M.month ? 1 : Math.max(1, G * Math.floor(o.get("Date", S) / G))), P >= M.month && (o.set("Month", S, P >= M.year ? 0 : G * Math.floor(o.get("Month", S) / G)), k = o.get("FullYear", S)), P >= M.year && (k -= k % G, o.set("FullYear", S, k)), P === M.week && (F = o.get("Day", S), o.set("Date", S, o.get("Date", S) - F + I + (F < I ? -7 : 0))), k = o.get("FullYear", S);
            let x = o.get("Month", S), Q = o.get("Date", S), J = o.get("Hours", S);
            R = S.getTime(), (o.variableTimezone || !o.useUTC) && m(K) && (h = K - R > 4 * M.month || o.getTimezoneOffset(R) !== o.getTimezoneOffset(K));
            let ie = S.getTime();
            for (z = 1; ie < K; )
              c.push(ie), P === M.year ? ie = o.makeTime(k + z * G, 0) : P === M.month ? ie = o.makeTime(k, x + z * G) : h && (P === M.day || P === M.week) ? ie = o.makeTime(k, x, Q + z * G * (P === M.day ? 1 : 7)) : h && P === M.hour && G > 1 ? ie = o.makeTime(k, x, Q, J + z * G) : ie += P * G, z++;
            c.push(ie), P <= M.hour && c.length < 1e4 && c.forEach(function(te) {
              te % 18e5 == 0 && o.dateFormat("%H%M%S%L", te) === "000000000" && (d[te] = "day");
            });
          }
          return c.info = Y(u, { higherRanks: d, totalRange: P * G }), c;
        }
        getDateFormat(u, R, K, I) {
          let z = this.dateFormat("%m-%d %H:%M:%S.%L", R), k = "01-01 00:00:00.000", h = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 }, F = "millisecond", o = F;
          for (F in M) {
            if (u === M.week && +this.dateFormat("%w", R) === K && z.substr(6) === k.substr(6)) {
              F = "week";
              break;
            }
            if (M[F] > u) {
              F = o;
              break;
            }
            if (h[F] && z.substr(h[F]) !== k.substr(h[F]))
              break;
            F !== "week" && (o = F);
          }
          return this.resolveDTLFormat(I[F]).main;
        }
      }
      return j.formatCache = {}, j;
    }), i(e, "Core/Defaults.js", [e["Core/Chart/ChartDefaults.js"], e["Core/Globals.js"], e["Core/Color/Palettes.js"], e["Core/Time.js"], e["Core/Utilities.js"]], function(n, s, l, m, A) {
      let { isTouchDevice: Y, svg: q } = s, { merge: T } = A, B = { colors: l.colors, symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: { loading: "Loading...", months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], decimalPoint: ".", numericSymbols: ["k", "M", "G", "T", "P", "E"], resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: " " }, global: {}, time: { Date: void 0, getTimezoneOffset: void 0, timezone: void 0, timezoneOffset: 0, useUTC: !0 }, chart: n, title: { style: { color: "#333333", fontWeight: "bold" }, text: "Chart title", align: "center", margin: 15, widthAdjust: -44 }, subtitle: { style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "center", widthAdjust: -44 }, caption: { margin: 15, style: { color: "#666666", fontSize: "0.8em" }, text: "", align: "left", verticalAlign: "bottom" }, plotOptions: {}, legend: { enabled: !0, align: "center", alignColumns: !0, className: "highcharts-no-tooltip", layout: "horizontal", itemMarginBottom: 2, itemMarginTop: 2, labelFormatter: function() {
        return this.name;
      }, borderColor: "#999999", borderRadius: 0, navigation: { style: { fontSize: "0.8em" }, activeColor: "#0022ff", inactiveColor: "#cccccc" }, itemStyle: { color: "#333333", cursor: "pointer", fontSize: "0.8em", textDecoration: "none", textOverflow: "ellipsis" }, itemHoverStyle: { color: "#000000" }, itemHiddenStyle: { color: "#666666", textDecoration: "line-through" }, shadow: !1, itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" }, squareSymbol: !0, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: { style: { fontSize: "0.8em", fontWeight: "bold" } } }, loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: { position: "absolute", backgroundColor: "#ffffff", opacity: 0.5, textAlign: "center" } }, tooltip: { enabled: !0, animation: q, borderRadius: 3, dateTimeLabelFormats: { millisecond: "%A, %e %b, %H:%M:%S.%L", second: "%A, %e %b, %H:%M:%S", minute: "%A, %e %b, %H:%M", hour: "%A, %e %b, %H:%M", day: "%A, %e %b %Y", week: "Week from %A, %e %b %Y", month: "%B %Y", year: "%Y" }, footerFormat: "", headerShape: "callout", hideDelay: 500, padding: 8, shape: "callout", shared: !1, snap: Y ? 25 : 10, headerFormat: '<span style="font-size: 0.8em">{point.key}</span><br/>', pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>', backgroundColor: "#ffffff", borderWidth: void 0, shadow: !0, stickOnContact: !1, style: { color: "#333333", cursor: "default", fontSize: "0.8em" }, useHTML: !1 }, credits: { enabled: !0, href: "https://www.highcharts.com?credits", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#999999", fontSize: "0.6em" }, text: "Highcharts.com" } };
      B.chart.styledMode = !1;
      let O = new m(B.time);
      return { defaultOptions: B, defaultTime: O, getOptions: function() {
        return B;
      }, setOptions: function(b) {
        return T(!0, B, b), (b.time || b.global) && (s.time ? s.time.update(T(B.global, B.time, b.global, b.time)) : s.time = O), B;
      } };
    }), i(e, "Core/Color/Color.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(n, s) {
      let { isNumber: l, merge: m, pInt: A } = s;
      class Y {
        static parse(T) {
          return T ? new Y(T) : Y.None;
        }
        constructor(T) {
          let B, O, b, v;
          this.rgba = [NaN, NaN, NaN, NaN], this.input = T;
          let E = n.Color;
          if (E && E !== Y)
            return new E(T);
          if (typeof T == "object" && T.stops !== void 0)
            this.stops = T.stops.map((M) => new Y(M[1]));
          else if (typeof T == "string") {
            if (this.input = T = Y.names[T.toLowerCase()] || T, T.charAt(0) === "#") {
              let M = T.length, g = parseInt(T.substr(1), 16);
              M === 7 ? O = [(16711680 & g) >> 16, (65280 & g) >> 8, 255 & g, 1] : M === 4 && (O = [(3840 & g) >> 4 | (3840 & g) >> 8, (240 & g) >> 4 | 240 & g, (15 & g) << 4 | 15 & g, 1]);
            }
            if (!O)
              for (b = Y.parsers.length; b-- && !O; )
                (B = (v = Y.parsers[b]).regex.exec(T)) && (O = v.parse(B));
          }
          O && (this.rgba = O);
        }
        get(T) {
          let B = this.input, O = this.rgba;
          if (typeof B == "object" && this.stops !== void 0) {
            let b = m(B);
            return b.stops = [].slice.call(b.stops), this.stops.forEach((v, E) => {
              b.stops[E] = [b.stops[E][0], v.get(T)];
            }), b;
          }
          return O && l(O[0]) ? T !== "rgb" && (T || O[3] !== 1) ? T === "a" ? `${O[3]}` : "rgba(" + O.join(",") + ")" : "rgb(" + O[0] + "," + O[1] + "," + O[2] + ")" : B;
        }
        brighten(T) {
          let B = this.rgba;
          if (this.stops)
            this.stops.forEach(function(O) {
              O.brighten(T);
            });
          else if (l(T) && T !== 0)
            for (let O = 0; O < 3; O++)
              B[O] += A(255 * T), B[O] < 0 && (B[O] = 0), B[O] > 255 && (B[O] = 255);
          return this;
        }
        setOpacity(T) {
          return this.rgba[3] = T, this;
        }
        tweenTo(T, B) {
          let O = this.rgba, b = T.rgba;
          if (!l(O[0]) || !l(b[0]))
            return T.input || "none";
          let v = b[3] !== 1 || O[3] !== 1;
          return (v ? "rgba(" : "rgb(") + Math.round(b[0] + (O[0] - b[0]) * (1 - B)) + "," + Math.round(b[1] + (O[1] - b[1]) * (1 - B)) + "," + Math.round(b[2] + (O[2] - b[2]) * (1 - B)) + (v ? "," + (b[3] + (O[3] - b[3]) * (1 - B)) : "") + ")";
        }
      }
      return Y.names = { white: "#ffffff", black: "#000000" }, Y.parsers = [{ regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, parse: function(q) {
        return [A(q[1]), A(q[2]), A(q[3]), parseFloat(q[4], 10)];
      } }, { regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, parse: function(q) {
        return [A(q[1]), A(q[2]), A(q[3]), 1];
      } }], Y.None = new Y(""), Y;
    }), i(e, "Core/Animation/Fx.js", [e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function(n, s, l) {
      let { parse: m } = n, { win: A } = s, { isNumber: Y, objectEach: q } = l;
      class T {
        constructor(O, b, v) {
          this.pos = NaN, this.options = b, this.elem = O, this.prop = v;
        }
        dSetter() {
          let O = this.paths, b = O && O[0], v = O && O[1], E = this.now || 0, M = [];
          if (E !== 1 && b && v)
            if (b.length === v.length && E < 1)
              for (let g = 0; g < v.length; g++) {
                let C = b[g], j = v[g], D = [];
                for (let u = 0; u < j.length; u++) {
                  let R = C[u], K = j[u];
                  Y(R) && Y(K) && !(j[0] === "A" && (u === 4 || u === 5)) ? D[u] = R + E * (K - R) : D[u] = K;
                }
                M.push(D);
              }
            else
              M = v;
          else
            M = this.toD || [];
          this.elem.attr("d", M, void 0, !0);
        }
        update() {
          let O = this.elem, b = this.prop, v = this.now, E = this.options.step;
          this[b + "Setter"] ? this[b + "Setter"]() : O.attr ? O.element && O.attr(b, v, null, !0) : O.style[b] = v + this.unit, E && E.call(O, v, this);
        }
        run(O, b, v) {
          let E = this, M = E.options, g = function(D) {
            return !g.stopped && E.step(D);
          }, C = A.requestAnimationFrame || function(D) {
            setTimeout(D, 13);
          }, j = function() {
            for (let D = 0; D < T.timers.length; D++)
              T.timers[D]() || T.timers.splice(D--, 1);
            T.timers.length && C(j);
          };
          O !== b || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +/* @__PURE__ */ new Date(), this.start = O, this.end = b, this.unit = v, this.now = this.start, this.pos = 0, g.elem = this.elem, g.prop = this.prop, g() && T.timers.push(g) === 1 && C(j)) : (delete M.curAnim[this.prop], M.complete && Object.keys(M.curAnim).length === 0 && M.complete.call(this.elem));
        }
        step(O) {
          let b, v, E = +/* @__PURE__ */ new Date(), M = this.options, g = this.elem, C = M.complete, j = M.duration, D = M.curAnim;
          return g.attr && !g.element ? b = !1 : O || E >= j + this.startTime ? (this.now = this.end, this.pos = 1, this.update(), D[this.prop] = !0, v = !0, q(D, function(u) {
            u !== !0 && (v = !1);
          }), v && C && C.call(g), b = !1) : (this.pos = M.easing((E - this.startTime) / j), this.now = this.start + (this.end - this.start) * this.pos, this.update(), b = !0), b;
        }
        initPath(O, b, v) {
          let E = O.startX, M = O.endX, g = v.slice(), C = O.isArea, j = C ? 2 : 1, D, u, R, K, I = b && b.slice();
          if (!I)
            return [g, g];
          function z(h, F) {
            for (; h.length < u; ) {
              let o = h[0], a = F[u - h.length];
              if (a && o[0] === "M" && (a[0] === "C" ? h[0] = ["C", o[1], o[2], o[1], o[2], o[1], o[2]] : h[0] = ["L", o[1], o[2]]), h.unshift(o), C) {
                let c = h.pop();
                h.push(h[h.length - 1], c);
              }
            }
          }
          function k(h) {
            for (; h.length < u; ) {
              let F = h[Math.floor(h.length / j) - 1].slice();
              if (F[0] === "C" && (F[1] = F[5], F[2] = F[6]), C) {
                let o = h[Math.floor(h.length / j)].slice();
                h.splice(h.length / 2, 0, F, o);
              } else
                h.push(F);
            }
          }
          if (E && M && M.length) {
            for (R = 0; R < E.length; R++) {
              if (E[R] === M[0]) {
                D = R;
                break;
              }
              if (E[0] === M[M.length - E.length + R]) {
                D = R, K = !0;
                break;
              }
              if (E[E.length - 1] === M[M.length - E.length + R]) {
                D = E.length - R;
                break;
              }
            }
            D === void 0 && (I = []);
          }
          return I.length && Y(D) && (u = g.length + D * j, K ? (z(I, g), k(g)) : (z(g, I), k(I))), [I, g];
        }
        fillSetter() {
          T.prototype.strokeSetter.apply(this, arguments);
        }
        strokeSetter() {
          this.elem.attr(this.prop, m(this.start).tweenTo(m(this.end), this.pos), void 0, !0);
        }
      }
      return T.timers = [], T;
    }), i(e, "Core/Animation/AnimationUtilities.js", [e["Core/Animation/Fx.js"], e["Core/Utilities.js"]], function(n, s) {
      let { defined: l, getStyle: m, isArray: A, isNumber: Y, isObject: q, merge: T, objectEach: B, pick: O } = s;
      function b(E) {
        return q(E) ? T({ duration: 500, defer: 0 }, E) : { duration: E ? 500 : 0, defer: 0 };
      }
      function v(E, M) {
        let g = n.timers.length;
        for (; g--; )
          n.timers[g].elem !== E || M && M !== n.timers[g].prop || (n.timers[g].stopped = !0);
      }
      return { animate: function(E, M, g) {
        let C, j = "", D, u, R;
        q(g) || (R = arguments, g = { duration: R[2], easing: R[3], complete: R[4] }), Y(g.duration) || (g.duration = 400), g.easing = typeof g.easing == "function" ? g.easing : Math[g.easing] || Math.easeInOutSine, g.curAnim = T(M), B(M, function(K, I) {
          v(E, I), u = new n(E, g, I), D = void 0, I === "d" && A(M.d) ? (u.paths = u.initPath(E, E.pathArray, M.d), u.toD = M.d, C = 0, D = 1) : E.attr ? C = E.attr(I) : (C = parseFloat(m(E, I)) || 0, I !== "opacity" && (j = "px")), D || (D = K), typeof D == "string" && D.match("px") && (D = D.replace(/px/g, "")), u.run(C, D, j);
        });
      }, animObject: b, getDeferredAnimation: function(E, M, g) {
        let C = b(M), j = g ? [g] : E.series, D = 0, u = 0;
        return j.forEach((R) => {
          let K = b(R.options.animation);
          D = q(M) && l(M.defer) ? C.defer : Math.max(D, K.duration + K.defer), u = Math.min(C.duration, K.duration);
        }), E.renderer.forExport && (D = 0), { defer: Math.max(0, D - u), duration: Math.min(D, u) };
      }, setAnimation: function(E, M) {
        M.renderer.globalAnimation = O(E, M.options.chart.animation, !0);
      }, stop: v };
    }), i(e, "Core/Renderer/HTML/AST.js", [e["Core/Globals.js"], e["Core/Utilities.js"]], function(n, s) {
      let { SVG_NS: l, win: m } = n, { attr: A, createElement: Y, css: q, error: T, isFunction: B, isString: O, objectEach: b, splat: v } = s, { trustedTypes: E } = m, M = E && B(E.createPolicy) && E.createPolicy("highcharts", { createHTML: (D) => D }), g = M ? M.createHTML("") : "", C = function() {
        try {
          return !!new DOMParser().parseFromString(g, "text/html");
        } catch {
          return !1;
        }
      }();
      class j {
        static filterUserAttributes(u) {
          return b(u, (R, K) => {
            let I = !0;
            j.allowedAttributes.indexOf(K) === -1 && (I = !1), ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(K) !== -1 && (I = O(R) && j.allowedReferences.some((z) => R.indexOf(z) === 0)), I || (T(33, !1, void 0, { "Invalid attribute in config": `${K}` }), delete u[K]), O(R) && u[K] && (u[K] = R.replace(/</g, "&lt;"));
          }), u;
        }
        static parseStyle(u) {
          return u.split(";").reduce((R, K) => {
            let I = K.split(":").map((k) => k.trim()), z = I.shift();
            return z && I.length && (R[z.replace(/-([a-z])/g, (k) => k[1].toUpperCase())] = I.join(":")), R;
          }, {});
        }
        static setElementHTML(u, R) {
          u.innerHTML = j.emptyHTML, R && new j(R).addToDOM(u);
        }
        constructor(u) {
          this.nodes = typeof u == "string" ? this.parseMarkup(u) : u;
        }
        addToDOM(u) {
          return function R(K, I) {
            let z;
            return v(K).forEach(function(k) {
              let h, F = k.tagName, o = k.textContent ? n.doc.createTextNode(k.textContent) : void 0, a = j.bypassHTMLFiltering;
              if (F)
                if (F === "#text")
                  h = o;
                else if (j.allowedTags.indexOf(F) !== -1 || a) {
                  let c = F === "svg" ? l : I.namespaceURI || l, d = n.doc.createElementNS(c, F), S = k.attributes || {};
                  b(k, function(P, G) {
                    G !== "tagName" && G !== "attributes" && G !== "children" && G !== "style" && G !== "textContent" && (S[G] = P);
                  }), A(d, a ? S : j.filterUserAttributes(S)), k.style && q(d, k.style), o && d.appendChild(o), R(k.children || [], d), h = d;
                } else
                  T(33, !1, void 0, { "Invalid tagName in config": F });
              h && I.appendChild(h), z = h;
            }), z;
          }(this.nodes, u);
        }
        parseMarkup(u) {
          let R, K = [];
          if (u = u.trim().replace(/ style=(["'])/g, " data-style=$1"), C)
            R = new DOMParser().parseFromString(M ? M.createHTML(u) : u, "text/html");
          else {
            let z = Y("div");
            z.innerHTML = u, R = { body: z };
          }
          let I = (z, k) => {
            let h = z.nodeName.toLowerCase(), F = { tagName: h };
            h === "#text" && (F.textContent = z.textContent || "");
            let o = z.attributes;
            if (o) {
              let a = {};
              [].forEach.call(o, (c) => {
                c.name === "data-style" ? F.style = j.parseStyle(c.value) : a[c.name] = c.value;
              }), F.attributes = a;
            }
            if (z.childNodes.length) {
              let a = [];
              [].forEach.call(z.childNodes, (c) => {
                I(c, a);
              }), a.length && (F.children = a);
            }
            k.push(F);
          };
          return [].forEach.call(R.body.childNodes, (z) => I(z, K)), K;
        }
      }
      return j.allowedAttributes = ["alt", "aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup", "aria-hidden", "aria-label", "aria-labelledby", "aria-live", "aria-pressed", "aria-readonly", "aria-roledescription", "aria-selected", "class", "clip-path", "color", "colspan", "cx", "cy", "d", "dx", "dy", "disabled", "fill", "filterUnits", "flood-color", "flood-opacity", "height", "href", "id", "in", "markerHeight", "markerWidth", "offset", "opacity", "orient", "padding", "paddingLeft", "paddingRight", "patternUnits", "r", "refX", "refY", "role", "scope", "slope", "src", "startOffset", "stdDeviation", "stroke", "stroke-linecap", "stroke-width", "style", "tableValues", "result", "rowspan", "summary", "target", "tabindex", "text-align", "text-anchor", "textAnchor", "textLength", "title", "type", "valign", "width", "x", "x1", "x2", "xlink:href", "y", "y1", "y2", "zIndex"], j.allowedReferences = ["https://", "http://", "mailto:", "/", "../", "./", "#"], j.allowedTags = ["a", "abbr", "b", "br", "button", "caption", "circle", "clipPath", "code", "dd", "defs", "div", "dl", "dt", "em", "feComponentTransfer", "feDropShadow", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feOffset", "feMerge", "feMergeNode", "filter", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "i", "img", "li", "linearGradient", "marker", "ol", "p", "path", "pattern", "pre", "rect", "small", "span", "stop", "strong", "style", "sub", "sup", "svg", "table", "text", "textPath", "thead", "title", "tbody", "tspan", "td", "th", "tr", "u", "ul", "#text"], j.emptyHTML = g, j.bypassHTMLFiltering = !1, j;
    }), i(e, "Core/Templating.js", [e["Core/Defaults.js"], e["Core/Utilities.js"]], function(n, s) {
      let { defaultOptions: l, defaultTime: m } = n, { extend: A, getNestedProperty: Y, isArray: q, isNumber: T, isObject: B, pick: O, pInt: b } = s, v = { add: (g, C) => g + C, divide: (g, C) => C !== 0 ? g / C : "", eq: (g, C) => g == C, each: function(g) {
        let C = arguments[arguments.length - 1];
        return !!q(g) && g.map((j, D) => E(C.body, A(B(j) ? j : { "@this": j }, { "@index": D, "@first": D === 0, "@last": D === g.length - 1 }))).join("");
      }, ge: (g, C) => g >= C, gt: (g, C) => g > C, if: (g) => !!g, le: (g, C) => g <= C, lt: (g, C) => g < C, multiply: (g, C) => g * C, ne: (g, C) => g != C, subtract: (g, C) => g - C, unless: (g) => !g };
      function E(g = "", C, j) {
        let D = /\{([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= #\(\)]+)\}/g, u = /\(([a-zA-Z0-9\:\.\,;\-\/<>%_@"'= ]+)\)/g, R = [], K = /f$/, I = /\.([0-9])/, z = l.lang, k = j && j.time || m, h = j && j.numberFormatter || M, F = (S = "") => {
          let P;
          return S === "true" || S !== "false" && ((P = Number(S)).toString() === S ? P : Y(S, C));
        }, o, a, c = 0, d;
        for (; (o = D.exec(g)) !== null; ) {
          let S = u.exec(o[1]);
          S && (o = S, d = !0), a && a.isBlock || (a = { ctx: C, expression: o[1], find: o[0], isBlock: o[1].charAt(0) === "#", start: o.index, startInner: o.index + o[0].length, length: o[0].length });
          let P = o[1].split(" ")[0].replace("#", "");
          v[P] && (a.isBlock && P === a.fn && c++, a.fn || (a.fn = P));
          let G = o[1] === "else";
          if (a.isBlock && a.fn && (o[1] === `/${a.fn}` || G))
            if (c)
              !G && c--;
            else {
              let x = a.startInner, Q = g.substr(x, o.index - x);
              a.body === void 0 ? (a.body = Q, a.startInner = o.index + o[0].length) : a.elseBody = Q, a.find += Q + o[0], G || (R.push(a), a = void 0);
            }
          else
            a.isBlock || R.push(a);
          if (S && !(a != null && a.isBlock))
            break;
        }
        return R.forEach((S) => {
          let P, G, { body: x, elseBody: Q, expression: J, fn: ie } = S;
          if (ie) {
            let te = [S], $ = J.split(" ");
            for (G = v[ie].length; G--; )
              te.unshift(F($[G + 1]));
            P = v[ie].apply(C, te), S.isBlock && typeof P == "boolean" && (P = E(P ? x : Q, C));
          } else {
            let te = J.split(":");
            if (P = F(te.shift() || ""), te.length && typeof P == "number") {
              let $ = te.join(":");
              if (K.test($)) {
                let oe = parseInt(($.match(I) || ["", "-1"])[1], 10);
                P !== null && (P = h(P, oe, z.decimalPoint, $.indexOf(",") > -1 ? z.thousandsSep : ""));
              } else
                P = k.dateFormat($, P);
            }
          }
          g = g.replace(S.find, O(P, ""));
        }), d ? E(g, C, j) : g;
      }
      function M(g, C, j, D) {
        let u, R;
        g = +g || 0, C = +C;
        let K = l.lang, I = (g.toString().split(".")[1] || "").split("e")[0].length, z = g.toString().split("e"), k = C;
        C === -1 ? C = Math.min(I, 20) : T(C) ? C && z[1] && z[1] < 0 && ((R = C + +z[1]) >= 0 ? (z[0] = (+z[0]).toExponential(R).split("e")[0], C = R) : (z[0] = z[0].split(".")[0] || 0, g = C < 20 ? (z[0] * Math.pow(10, z[1])).toFixed(C) : 0, z[1] = 0)) : C = 2;
        let h = (Math.abs(z[1] ? z[0] : g) + Math.pow(10, -Math.max(C, I) - 1)).toFixed(C), F = String(b(h)), o = F.length > 3 ? F.length % 3 : 0;
        return j = O(j, K.decimalPoint), D = O(D, K.thousandsSep), u = (g < 0 ? "-" : "") + (o ? F.substr(0, o) + D : ""), 0 > +z[1] && !k ? u = "0" : u += F.substr(o).replace(/(\d{3})(?=\d)/g, "$1" + D), C && (u += j + h.slice(-C)), z[1] && +u != 0 && (u += "e" + z[1]), u;
      }
      return { dateFormat: function(g, C, j) {
        return m.dateFormat(g, C, j);
      }, format: E, helpers: v, numberFormat: M };
    }), i(e, "Core/Renderer/RendererRegistry.js", [e["Core/Globals.js"]], function(n) {
      var s, l;
      let m;
      return (l = s || (s = {})).rendererTypes = {}, l.getRendererType = function(A = m) {
        return l.rendererTypes[A] || l.rendererTypes[m];
      }, l.registerRendererType = function(A, Y, q) {
        l.rendererTypes[A] = Y, (!m || q) && (m = A, n.Renderer = Y);
      }, s;
    }), i(e, "Core/Renderer/RendererUtilities.js", [e["Core/Utilities.js"]], function(n) {
      var s;
      let { clamp: l, pick: m, pushUnique: A, stableSort: Y } = n;
      return (s || (s = {})).distribute = function q(T, B, O) {
        let b = T, v = b.reducedLen || B, E = (F, o) => F.target - o.target, M = [], g = T.length, C = [], j = M.push, D, u, R, K = !0, I, z, k = 0, h;
        for (D = g; D--; )
          k += T[D].size;
        if (k > v) {
          for (Y(T, (F, o) => (o.rank || 0) - (F.rank || 0)), R = (h = T[0].rank === T[T.length - 1].rank) ? g / 2 : -1, u = h ? R : g - 1; R && k > v; )
            I = T[D = Math.floor(u)], A(C, D) && (k -= I.size), u += R, h && u >= T.length && (R /= 2, u = R);
          C.sort((F, o) => o - F).forEach((F) => j.apply(M, T.splice(F, 1)));
        }
        for (Y(T, E), T = T.map((F) => ({ size: F.size, targets: [F.target], align: m(F.align, 0.5) })); K; ) {
          for (D = T.length; D--; )
            I = T[D], z = (Math.min.apply(0, I.targets) + Math.max.apply(0, I.targets)) / 2, I.pos = l(z - I.size * I.align, 0, B - I.size);
          for (D = T.length, K = !1; D--; )
            D > 0 && T[D - 1].pos + T[D - 1].size > T[D].pos && (T[D - 1].size += T[D].size, T[D - 1].targets = T[D - 1].targets.concat(T[D].targets), T[D - 1].align = 0.5, T[D - 1].pos + T[D - 1].size > B && (T[D - 1].pos = B - T[D - 1].size), T.splice(D, 1), K = !0);
        }
        return j.apply(b, M), D = 0, T.some((F) => {
          let o = 0;
          return (F.targets || []).some(() => (b[D].pos = F.pos + o, O !== void 0 && Math.abs(b[D].pos - b[D].target) > O ? (b.slice(0, D + 1).forEach((a) => delete a.pos), b.reducedLen = (b.reducedLen || B) - 0.1 * B, b.reducedLen > 0.1 * B && q(b, B, O), !0) : (o += b[D].size, D++, !1)));
        }), Y(b, E), b;
      }, s;
    }), i(e, "Core/Renderer/SVG/SVGElement.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function(n, s, l, m) {
      let { animate: A, animObject: Y, stop: q } = n, { deg2rad: T, doc: B, svg: O, SVG_NS: b, win: v } = l, { addEvent: E, attr: M, createElement: g, css: C, defined: j, erase: D, extend: u, fireEvent: R, isArray: K, isFunction: I, isObject: z, isString: k, merge: h, objectEach: F, pick: o, pInt: a, replaceNested: c, syncTimeout: d, uniqueKey: S } = m;
      class P {
        _defaultGetter(x) {
          let Q = o(this[x + "Value"], this[x], this.element ? this.element.getAttribute(x) : null, 0);
          return /^[\-0-9\.]+$/.test(Q) && (Q = parseFloat(Q)), Q;
        }
        _defaultSetter(x, Q, J) {
          J.setAttribute(Q, x);
        }
        add(x) {
          let Q, J = this.renderer, ie = this.element;
          return x && (this.parentGroup = x), this.textStr !== void 0 && this.element.nodeName === "text" && J.buildText(this), this.added = !0, (!x || x.handleZ || this.zIndex) && (Q = this.zIndexSetter()), Q || (x ? x.element : J.box).appendChild(ie), this.onAdd && this.onAdd(), this;
        }
        addClass(x, Q) {
          let J = Q ? "" : this.attr("class") || "";
          return (x = (x || "").split(/ /g).reduce(function(ie, te) {
            return J.indexOf(te) === -1 && ie.push(te), ie;
          }, J ? [J] : []).join(" ")) !== J && this.attr("class", x), this;
        }
        afterSetters() {
          this.doTransform && (this.updateTransform(), this.doTransform = !1);
        }
        align(x, Q, J, ie = !0) {
          let te, $, oe, p, W, X = {}, f = this.renderer, L = f.alignedObjects;
          x ? (this.alignOptions = x, this.alignByTranslate = Q, (!J || k(J)) && (this.alignTo = oe = J || "renderer", D(L, this), L.push(this), J = void 0)) : (x = this.alignOptions, Q = this.alignByTranslate, oe = this.alignTo), J = o(J, f[oe], f);
          let w = x.align, H = x.verticalAlign;
          return te = (J.x || 0) + (x.x || 0), $ = (J.y || 0) + (x.y || 0), w === "right" ? p = 1 : w === "center" && (p = 2), p && (te += (J.width - (x.width || 0)) / p), X[Q ? "translateX" : "x"] = Math.round(te), H === "bottom" ? W = 1 : H === "middle" && (W = 2), W && ($ += (J.height - (x.height || 0)) / W), X[Q ? "translateY" : "y"] = Math.round($), ie && (this[this.placed ? "animate" : "attr"](X), this.placed = !0), this.alignAttr = X, this;
        }
        alignSetter(x) {
          let Q = { left: "start", center: "middle", right: "end" };
          Q[x] && (this.alignValue = x, this.element.setAttribute("text-anchor", Q[x]));
        }
        animate(x, Q, J) {
          let ie = Y(o(Q, this.renderer.globalAnimation, !0)), te = ie.defer;
          return B.hidden && (ie.duration = 0), ie.duration !== 0 ? (J && (ie.complete = J), d(() => {
            this.element && A(this, x, ie);
          }, te)) : (this.attr(x, void 0, J || ie.complete), F(x, function($, oe) {
            ie.step && ie.step.call(this, $, { prop: oe, pos: 1, elem: this });
          }, this)), this;
        }
        applyTextOutline(x) {
          let Q = this.element;
          x.indexOf("contrast") !== -1 && (x = x.replace(/contrast/g, this.renderer.getContrast(Q.style.fill)));
          let J = x.split(" "), ie = J[J.length - 1], te = J[0];
          if (te && te !== "none" && l.svg) {
            this.fakeTS = !0, te = te.replace(/(^[\d\.]+)(.*?)$/g, function(X, f, L) {
              return 2 * Number(f) + L;
            }), this.removeTextOutline();
            let $ = B.createElementNS(b, "tspan");
            M($, { class: "highcharts-text-outline", fill: ie, stroke: ie, "stroke-width": te, "stroke-linejoin": "round" });
            let oe = Q.querySelector("textPath") || Q;
            [].forEach.call(oe.childNodes, (X) => {
              let f = X.cloneNode(!0);
              f.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach((L) => f.removeAttribute(L)), $.appendChild(f);
            });
            let p = 0;
            [].forEach.call(oe.querySelectorAll("text tspan"), (X) => {
              p += Number(X.getAttribute("dy"));
            });
            let W = B.createElementNS(b, "tspan");
            W.textContent = "​", M(W, { x: Number(Q.getAttribute("x")), dy: -p }), $.appendChild(W), oe.insertBefore($, oe.firstChild);
          }
        }
        attr(x, Q, J, ie) {
          let te = this.element, $ = P.symbolCustomAttribs, oe, p, W = this, X;
          return typeof x == "string" && Q !== void 0 && (oe = x, (x = {})[oe] = Q), typeof x == "string" ? W = (this[x + "Getter"] || this._defaultGetter).call(this, x, te) : (F(x, function(f, L) {
            X = !1, ie || q(this, L), this.symbolName && $.indexOf(L) !== -1 && (p || (this.symbolAttr(x), p = !0), X = !0), this.rotation && (L === "x" || L === "y") && (this.doTransform = !0), X || (this[L + "Setter"] || this._defaultSetter).call(this, f, L, te);
          }, this), this.afterSetters()), J && J.call(this), W;
        }
        clip(x) {
          if (x && !x.clipPath) {
            let Q = S() + "-", J = this.renderer.createElement("clipPath").attr({ id: Q }).add(this.renderer.defs);
            u(x, { clipPath: J, id: Q, count: 0 }), x.add(J);
          }
          return this.attr("clip-path", x ? `url(${this.renderer.url}#${x.id})` : "none");
        }
        crisp(x, Q) {
          let J = Math.round(Q = Q || x.strokeWidth || 0) % 2 / 2;
          return x.x = Math.floor(x.x || this.x || 0) + J, x.y = Math.floor(x.y || this.y || 0) + J, x.width = Math.floor((x.width || this.width || 0) - 2 * J), x.height = Math.floor((x.height || this.height || 0) - 2 * J), j(x.strokeWidth) && (x.strokeWidth = Q), x;
        }
        complexColor(x, Q, J) {
          let ie = this.renderer, te, $, oe, p, W, X, f, L, w, H, U = [], ee;
          R(this.renderer, "complexColor", { args: arguments }, function() {
            if (x.radialGradient ? $ = "radialGradient" : x.linearGradient && ($ = "linearGradient"), $) {
              if (oe = x[$], W = ie.gradients, X = x.stops, w = J.radialReference, K(oe) && (x[$] = oe = { x1: oe[0], y1: oe[1], x2: oe[2], y2: oe[3], gradientUnits: "userSpaceOnUse" }), $ === "radialGradient" && w && !j(oe.gradientUnits) && (p = oe, oe = h(oe, ie.getRadialAttr(w, p), { gradientUnits: "userSpaceOnUse" })), F(oe, function(ae, ne) {
                ne !== "id" && U.push(ne, ae);
              }), F(X, function(ae) {
                U.push(ae);
              }), W[U = U.join(",")])
                H = W[U].attr("id");
              else {
                oe.id = H = S();
                let ae = W[U] = ie.createElement($).attr(oe).add(ie.defs);
                ae.radAttr = p, ae.stops = [], X.forEach(function(ne) {
                  ne[1].indexOf("rgba") === 0 ? (f = (te = s.parse(ne[1])).get("rgb"), L = te.get("a")) : (f = ne[1], L = 1);
                  let he = ie.createElement("stop").attr({ offset: ne[0], "stop-color": f, "stop-opacity": L }).add(ae);
                  ae.stops.push(he);
                });
              }
              ee = "url(" + ie.url + "#" + H + ")", J.setAttribute(Q, ee), J.gradient = U, x.toString = function() {
                return ee;
              };
            }
          });
        }
        css(x) {
          let Q = this.styles, J = {}, ie = this.element, te, $ = !Q;
          if (Q && F(x, function(oe, p) {
            Q && Q[p] !== oe && (J[p] = oe, $ = !0);
          }), $) {
            Q && (x = u(Q, J)), x.width === null || x.width === "auto" ? delete this.textWidth : ie.nodeName.toLowerCase() === "text" && x.width && (te = this.textWidth = a(x.width)), u(this.styles, x), te && !O && this.renderer.forExport && delete x.width;
            let oe = h(x);
            ie.namespaceURI === this.SVG_NS && (["textOutline", "textOverflow", "width"].forEach((p) => oe && delete oe[p]), oe.color && (oe.fill = oe.color)), C(ie, oe);
          }
          return this.added && (this.element.nodeName === "text" && this.renderer.buildText(this), x.textOutline && this.applyTextOutline(x.textOutline)), this;
        }
        dashstyleSetter(x) {
          let Q, J = this["stroke-width"];
          if (J === "inherit" && (J = 1), x = x && x.toLowerCase()) {
            let ie = x.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
            for (Q = ie.length; Q--; )
              ie[Q] = "" + a(ie[Q]) * o(J, NaN);
            x = ie.join(",").replace(/NaN/g, "none"), this.element.setAttribute("stroke-dasharray", x);
          }
        }
        destroy() {
          var p;
          let x = this, Q = x.element || {}, J = x.renderer, ie = Q.ownerSVGElement, te = Q.nodeName === "SPAN" && x.parentGroup || void 0, $, oe;
          if (Q.onclick = Q.onmouseout = Q.onmouseover = Q.onmousemove = Q.point = null, q(x), x.clipPath && ie) {
            let W = x.clipPath;
            [].forEach.call(ie.querySelectorAll("[clip-path],[CLIP-PATH]"), function(X) {
              X.getAttribute("clip-path").indexOf(W.element.id) > -1 && X.removeAttribute("clip-path");
            }), x.clipPath = W.destroy();
          }
          if (x.connector = (p = x.connector) == null ? void 0 : p.destroy(), x.stops) {
            for (oe = 0; oe < x.stops.length; oe++)
              x.stops[oe].destroy();
            x.stops.length = 0, x.stops = void 0;
          }
          for (x.safeRemoveChild(Q); te && te.div && te.div.childNodes.length === 0; )
            $ = te.parentGroup, x.safeRemoveChild(te.div), delete te.div, te = $;
          x.alignTo && D(J.alignedObjects, x), F(x, function(W, X) {
            x[X] && x[X].parentGroup === x && x[X].destroy && x[X].destroy(), delete x[X];
          });
        }
        dSetter(x, Q, J) {
          K(x) && (typeof x[0] == "string" && (x = this.renderer.pathToSegments(x)), this.pathArray = x, x = x.reduce((ie, te, $) => te && te.join ? ($ ? ie + " " : "") + te.join(" ") : (te || "").toString(), "")), /(NaN| {2}|^$)/.test(x) && (x = "M 0 0"), this[Q] !== x && (J.setAttribute(Q, x), this[Q] = x);
        }
        fillSetter(x, Q, J) {
          typeof x == "string" ? J.setAttribute(Q, x) : x && this.complexColor(x, Q, J);
        }
        hrefSetter(x, Q, J) {
          J.setAttributeNS("http://www.w3.org/1999/xlink", Q, x);
        }
        getBBox(x, Q) {
          let J, ie, te, $, { alignValue: oe, element: p, renderer: W, styles: X, textStr: f } = this, { cache: L, cacheKeys: w } = W, H = p.namespaceURI === this.SVG_NS, U = o(Q, this.rotation, 0), ee = W.styledMode ? p && P.prototype.getStyle.call(p, "font-size") : X.fontSize;
          if (j(f) && (($ = f.toString()).indexOf("<") === -1 && ($ = $.replace(/[0-9]/g, "0")), $ += ["", W.rootFontSize, ee, U, this.textWidth, oe, X.textOverflow, X.fontWeight].join(",")), $ && !x && (J = L[$]), !J) {
            if (H || W.forExport) {
              try {
                te = this.fakeTS && function(ae) {
                  let ne = p.querySelector(".highcharts-text-outline");
                  ne && C(ne, { display: ae });
                }, I(te) && te("none"), J = p.getBBox ? u({}, p.getBBox()) : { width: p.offsetWidth, height: p.offsetHeight, x: 0, y: 0 }, I(te) && te("");
              } catch {
              }
              (!J || J.width < 0) && (J = { x: 0, y: 0, width: 0, height: 0 });
            } else
              J = this.htmlGetBBox();
            ie = J.height, H && (J.height = ie = { "11px,17": 14, "13px,20": 16 }[`${ee || ""},${Math.round(ie)}`] || ie), U && (J = this.getRotatedBox(J, U));
          }
          if ($ && (f === "" || J.height > 0)) {
            for (; w.length > 250; )
              delete L[w.shift()];
            L[$] || w.push($), L[$] = J;
          }
          return J;
        }
        getRotatedBox(x, Q) {
          let { x: J, y: ie, width: te, height: $ } = x, { alignValue: oe, translateY: p, rotationOriginX: W = 0, rotationOriginY: X = 0 } = this, f = { right: 1, center: 0.5 }[oe || 0] || 0, L = Number(this.element.getAttribute("y") || 0) - (p ? 0 : ie), w = Q * T, H = (Q - 90) * T, U = Math.cos(w), ee = Math.sin(w), ae = te * U, ne = te * ee, he = Math.cos(H), me = Math.sin(H), [[ve, Me], [Z, V]] = [W, X].map((We) => [We - We * U, We * ee]), re = J + f * (te - ae) + ve + V + L * he, le = re + ae, be = le - $ * he, de = be - ae, ge = ie + L - f * ne - Me + Z + L * me, fe = ge + ne, ke = fe - $ * me, Pe = ke - ne, Ae = Math.min(re, le, be, de), Le = Math.min(ge, fe, ke, Pe), Ee = Math.max(re, le, be, de) - Ae, Ye = Math.max(ge, fe, ke, Pe) - Le;
          return { x: Ae, y: Le, width: Ee, height: Ye };
        }
        getStyle(x) {
          return v.getComputedStyle(this.element || this, "").getPropertyValue(x);
        }
        hasClass(x) {
          return ("" + this.attr("class")).split(" ").indexOf(x) !== -1;
        }
        hide() {
          return this.attr({ visibility: "hidden" });
        }
        htmlGetBBox() {
          return { height: 0, width: 0, x: 0, y: 0 };
        }
        constructor(x, Q) {
          this.onEvents = {}, this.opacity = 1, this.SVG_NS = b, this.element = Q === "span" || Q === "body" ? g(Q) : B.createElementNS(this.SVG_NS, Q), this.renderer = x, this.styles = {}, R(this, "afterInit");
        }
        on(x, Q) {
          let { onEvents: J } = this;
          return J[x] && J[x](), J[x] = E(this.element, x, Q), this;
        }
        opacitySetter(x, Q, J) {
          let ie = Number(Number(x).toFixed(3));
          this.opacity = ie, J.setAttribute(Q, ie);
        }
        removeClass(x) {
          return this.attr("class", ("" + this.attr("class")).replace(k(x) ? RegExp(`(^| )${x}( |$)`) : x, " ").replace(/ +/g, " ").trim());
        }
        removeTextOutline() {
          let x = this.element.querySelector("tspan.highcharts-text-outline");
          x && this.safeRemoveChild(x);
        }
        safeRemoveChild(x) {
          let Q = x.parentNode;
          Q && Q.removeChild(x);
        }
        setRadialReference(x) {
          let Q = this.element.gradient && this.renderer.gradients[this.element.gradient];
          return this.element.radialReference = x, Q && Q.radAttr && Q.animate(this.renderer.getRadialAttr(x, Q.radAttr)), this;
        }
        setTextPath(x, Q) {
          Q = h(!0, { enabled: !0, attributes: { dy: -5, startOffset: "50%", textAnchor: "middle" } }, Q);
          let J = this.renderer.url, ie = this.text || this, te = ie.textPath, { attributes: $, enabled: oe } = Q;
          if (x = x || te && te.path, te && te.undo(), x && oe) {
            let p = E(ie, "afterModifyTree", (W) => {
              if (x && oe) {
                let X = x.attr("id");
                X || x.attr("id", X = S());
                let f = { x: 0, y: 0 };
                j($.dx) && (f.dx = $.dx, delete $.dx), j($.dy) && (f.dy = $.dy, delete $.dy), ie.attr(f), this.attr({ transform: "" }), this.box && (this.box = this.box.destroy());
                let L = W.nodes.slice(0);
                W.nodes.length = 0, W.nodes[0] = { tagName: "textPath", attributes: u($, { "text-anchor": $.textAnchor, href: `${J}#${X}` }), children: L };
              }
            });
            ie.textPath = { path: x, undo: p };
          } else
            ie.attr({ dx: 0, dy: 0 }), delete ie.textPath;
          return this.added && (ie.textCache = "", this.renderer.buildText(ie)), this;
        }
        shadow(x) {
          var te;
          let { renderer: Q } = this, J = h(((te = this.parentGroup) == null ? void 0 : te.rotation) === 90 ? { offsetX: -1, offsetY: -1 } : {}, z(x) ? x : {}), ie = Q.shadowDefinition(J);
          return this.attr({ filter: x ? `url(${Q.url}#${ie})` : "none" });
        }
        show(x = !0) {
          return this.attr({ visibility: x ? "inherit" : "visible" });
        }
        "stroke-widthSetter"(x, Q, J) {
          this[Q] = x, J.setAttribute(Q, x);
        }
        strokeWidth() {
          if (!this.renderer.styledMode)
            return this["stroke-width"] || 0;
          let x = this.getStyle("stroke-width"), Q = 0, J;
          return /px$/.test(x) ? Q = a(x) : x !== "" && (M(J = B.createElementNS(b, "rect"), { width: x, "stroke-width": 0 }), this.element.parentNode.appendChild(J), Q = J.getBBox().width, J.parentNode.removeChild(J)), Q;
        }
        symbolAttr(x) {
          let Q = this;
          P.symbolCustomAttribs.forEach(function(J) {
            Q[J] = o(x[J], Q[J]);
          }), Q.attr({ d: Q.renderer.symbols[Q.symbolName](Q.x, Q.y, Q.width, Q.height, Q) });
        }
        textSetter(x) {
          x !== this.textStr && (delete this.textPxLength, this.textStr = x, this.added && this.renderer.buildText(this));
        }
        titleSetter(x) {
          let Q = this.element, J = Q.getElementsByTagName("title")[0] || B.createElementNS(this.SVG_NS, "title");
          Q.insertBefore ? Q.insertBefore(J, Q.firstChild) : Q.appendChild(J), J.textContent = c(o(x, ""), [/<[^>]*>/g, ""]).replace(/&lt;/g, "<").replace(/&gt;/g, ">");
        }
        toFront() {
          let x = this.element;
          return x.parentNode.appendChild(x), this;
        }
        translate(x, Q) {
          return this.attr({ translateX: x, translateY: Q });
        }
        updateTransform(x = "transform") {
          var L;
          let { element: Q, matrix: J, rotation: ie = 0, rotationOriginX: te, rotationOriginY: $, scaleX: oe, scaleY: p, translateX: W = 0, translateY: X = 0 } = this, f = ["translate(" + W + "," + X + ")"];
          j(J) && f.push("matrix(" + J.join(",") + ")"), ie && (f.push("rotate(" + ie + " " + o(te, Q.getAttribute("x"), 0) + " " + o($, Q.getAttribute("y") || 0) + ")"), ((L = this.text) == null ? void 0 : L.element.tagName) === "SPAN" && this.text.attr({ rotation: ie, rotationOriginX: (te || 0) - this.padding, rotationOriginY: ($ || 0) - this.padding })), (j(oe) || j(p)) && f.push("scale(" + o(oe, 1) + " " + o(p, 1) + ")"), f.length && !(this.text || this).textPath && Q.setAttribute(x, f.join(" "));
        }
        visibilitySetter(x, Q, J) {
          x === "inherit" ? J.removeAttribute(Q) : this[Q] !== x && J.setAttribute(Q, x), this[Q] = x;
        }
        xGetter(x) {
          return this.element.nodeName === "circle" && (x === "x" ? x = "cx" : x === "y" && (x = "cy")), this._defaultGetter(x);
        }
        zIndexSetter(x, Q) {
          let J = this.renderer, ie = this.parentGroup, te = (ie || J).element || J.box, $ = this.element, oe = te === J.box, p, W, X, f = !1, L, w = this.added, H;
          if (j(x) ? ($.setAttribute("data-z-index", x), x = +x, this[Q] === x && (w = !1)) : j(this[Q]) && $.removeAttribute("data-z-index"), this[Q] = x, w) {
            for ((x = this.zIndex) && ie && (ie.handleZ = !0), H = (p = te.childNodes).length - 1; H >= 0 && !f; H--)
              L = !j(X = (W = p[H]).getAttribute("data-z-index")), W !== $ && (x < 0 && L && !oe && !H ? (te.insertBefore($, p[H]), f = !0) : (a(X) <= x || L && (!j(x) || x >= 0)) && (te.insertBefore($, p[H + 1]), f = !0));
            f || (te.insertBefore($, p[oe ? 3 : 0]), f = !0);
          }
          return f;
        }
      }
      return P.symbolCustomAttribs = ["anchorX", "anchorY", "clockwise", "end", "height", "innerR", "r", "start", "width", "x", "y"], P.prototype.strokeSetter = P.prototype.fillSetter, P.prototype.yGetter = P.prototype.xGetter, P.prototype.matrixSetter = P.prototype.rotationOriginXSetter = P.prototype.rotationOriginYSetter = P.prototype.rotationSetter = P.prototype.scaleXSetter = P.prototype.scaleYSetter = P.prototype.translateXSetter = P.prototype.translateYSetter = P.prototype.verticalAlignSetter = function(G, x) {
        this[x] = G, this.doTransform = !0;
      }, P;
    }), i(e, "Core/Renderer/SVG/SVGLabel.js", [e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function(n, s) {
      let { defined: l, extend: m, isNumber: A, merge: Y, pick: q, removeEvent: T } = s;
      class B extends n {
        constructor(b, v, E, M, g, C, j, D, u, R) {
          let K;
          super(b, "g"), this.paddingLeftSetter = this.paddingSetter, this.paddingRightSetter = this.paddingSetter, this.textStr = v, this.x = E, this.y = M, this.anchorX = C, this.anchorY = j, this.baseline = u, this.className = R, this.addClass(R === "button" ? "highcharts-no-tooltip" : "highcharts-label"), R && this.addClass("highcharts-" + R), this.text = b.text(void 0, 0, 0, D).attr({ zIndex: 1 }), typeof g == "string" && ((K = /^url\((.*?)\)$/.test(g)) || this.renderer.symbols[g]) && (this.symbolKey = g), this.bBox = B.emptyBBox, this.padding = 3, this.baselineOffset = 0, this.needsBox = b.styledMode || K, this.deferredAttr = {}, this.alignFactor = 0;
        }
        alignSetter(b) {
          let v = { left: 0, center: 0.5, right: 1 }[b];
          v !== this.alignFactor && (this.alignFactor = v, this.bBox && A(this.xSetting) && this.attr({ x: this.xSetting }));
        }
        anchorXSetter(b, v) {
          this.anchorX = b, this.boxAttr(v, Math.round(b) - this.getCrispAdjust() - this.xSetting);
        }
        anchorYSetter(b, v) {
          this.anchorY = b, this.boxAttr(v, b - this.ySetting);
        }
        boxAttr(b, v) {
          this.box ? this.box.attr(b, v) : this.deferredAttr[b] = v;
        }
        css(b) {
          if (b) {
            let v = {};
            b = Y(b), B.textProps.forEach((E) => {
              b[E] !== void 0 && (v[E] = b[E], delete b[E]);
            }), this.text.css(v), "fontSize" in v || "fontWeight" in v ? this.updateTextPadding() : ("width" in v || "textOverflow" in v) && this.updateBoxSize();
          }
          return n.prototype.css.call(this, b);
        }
        destroy() {
          T(this.element, "mouseenter"), T(this.element, "mouseleave"), this.text && this.text.destroy(), this.box && (this.box = this.box.destroy()), n.prototype.destroy.call(this);
        }
        fillSetter(b, v) {
          b && (this.needsBox = !0), this.fill = b, this.boxAttr(v, b);
        }
        getBBox(b, v) {
          this.textStr && this.bBox.width === 0 && this.bBox.height === 0 && this.updateBoxSize();
          let { padding: E, height: M = 0, translateX: g = 0, translateY: C = 0, width: j = 0 } = this, D = q(this.paddingLeft, E), u = v ?? (this.rotation || 0), R = { width: j, height: M, x: g + this.bBox.x - D, y: C + this.bBox.y - E + this.baselineOffset };
          return u && (R = this.getRotatedBox(R, u)), R;
        }
        getCrispAdjust() {
          return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
        }
        heightSetter(b) {
          this.heightSetting = b;
        }
        onAdd() {
          this.text.add(this), this.attr({ text: q(this.textStr, ""), x: this.x || 0, y: this.y || 0 }), this.box && l(this.anchorX) && this.attr({ anchorX: this.anchorX, anchorY: this.anchorY });
        }
        paddingSetter(b, v) {
          A(b) ? b !== this[v] && (this[v] = b, this.updateTextPadding()) : this[v] = void 0;
        }
        rSetter(b, v) {
          this.boxAttr(v, b);
        }
        strokeSetter(b, v) {
          this.stroke = b, this.boxAttr(v, b);
        }
        "stroke-widthSetter"(b, v) {
          b && (this.needsBox = !0), this["stroke-width"] = b, this.boxAttr(v, b);
        }
        "text-alignSetter"(b) {
          this.textAlign = b;
        }
        textSetter(b) {
          b !== void 0 && this.text.attr({ text: b }), this.updateTextPadding();
        }
        updateBoxSize() {
          let b, v = this.text, E = {}, M = this.padding, g = this.bBox = (!A(this.widthSetting) || !A(this.heightSetting) || this.textAlign) && l(v.textStr) ? v.getBBox(void 0, 0) : B.emptyBBox;
          this.width = this.getPaddedWidth(), this.height = (this.heightSetting || g.height || 0) + 2 * M;
          let C = this.renderer.fontMetrics(v);
          if (this.baselineOffset = M + Math.min((this.text.firstLineMetrics || C).b, g.height || 1 / 0), this.heightSetting && (this.baselineOffset += (this.heightSetting - C.h) / 2), this.needsBox && !v.textPath) {
            if (!this.box) {
              let j = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
              j.addClass((this.className === "button" ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), j.add(this);
            }
            b = this.getCrispAdjust(), E.x = b, E.y = (this.baseline ? -this.baselineOffset : 0) + b, E.width = Math.round(this.width), E.height = Math.round(this.height), this.box.attr(m(E, this.deferredAttr)), this.deferredAttr = {};
          }
        }
        updateTextPadding() {
          let b = this.text;
          if (!b.textPath) {
            this.updateBoxSize();
            let v = this.baseline ? 0 : this.baselineOffset, E = q(this.paddingLeft, this.padding);
            l(this.widthSetting) && this.bBox && (this.textAlign === "center" || this.textAlign === "right") && (E += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width)), (E !== b.x || v !== b.y) && (b.attr("x", E), b.hasBoxWidthChanged && (this.bBox = b.getBBox(!0)), v !== void 0 && b.attr("y", v)), b.x = E, b.y = v;
          }
        }
        widthSetter(b) {
          this.widthSetting = A(b) ? b : void 0;
        }
        getPaddedWidth() {
          let b = this.padding, v = q(this.paddingLeft, b), E = q(this.paddingRight, b);
          return (this.widthSetting || this.bBox.width || 0) + v + E;
        }
        xSetter(b) {
          this.x = b, this.alignFactor && (b -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = !0), this.xSetting = Math.round(b), this.attr("translateX", this.xSetting);
        }
        ySetter(b) {
          this.ySetting = this.y = Math.round(b), this.attr("translateY", this.ySetting);
        }
      }
      return B.emptyBBox = { width: 0, height: 0, x: 0, y: 0 }, B.textProps = ["color", "direction", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "textAlign", "textDecoration", "textOutline", "textOverflow", "whiteSpace", "width"], B;
    }), i(e, "Core/Renderer/SVG/Symbols.js", [e["Core/Utilities.js"]], function(n) {
      let { defined: s, isNumber: l, pick: m } = n;
      function A(T, B, O, b, v) {
        let E = [];
        if (v) {
          let M = v.start || 0, g = m(v.r, O), C = m(v.r, b || O), j = 1e-3 > Math.abs((v.end || 0) - M - 2 * Math.PI), D = (v.end || 0) - 1e-3, u = v.innerR, R = m(v.open, j), K = Math.cos(M), I = Math.sin(M), z = Math.cos(D), k = Math.sin(D), h = m(v.longArc, D - M - Math.PI < 1e-3 ? 0 : 1), F = ["A", g, C, 0, h, m(v.clockwise, 1), T + g * z, B + C * k];
          F.params = { start: M, end: D, cx: T, cy: B }, E.push(["M", T + g * K, B + C * I], F), s(u) && ((F = ["A", u, u, 0, h, s(v.clockwise) ? 1 - v.clockwise : 0, T + u * K, B + u * I]).params = { start: D, end: M, cx: T, cy: B }, E.push(R ? ["M", T + u * z, B + u * k] : ["L", T + u * z, B + u * k], F)), R || E.push(["Z"]);
        }
        return E;
      }
      function Y(T, B, O, b, v) {
        return v && v.r ? q(T, B, O, b, v) : [["M", T, B], ["L", T + O, B], ["L", T + O, B + b], ["L", T, B + b], ["Z"]];
      }
      function q(T, B, O, b, v) {
        let E = (v == null ? void 0 : v.r) || 0;
        return [["M", T + E, B], ["L", T + O - E, B], ["A", E, E, 0, 0, 1, T + O, B + E], ["L", T + O, B + b - E], ["A", E, E, 0, 0, 1, T + O - E, B + b], ["L", T + E, B + b], ["A", E, E, 0, 0, 1, T, B + b - E], ["L", T, B + E], ["A", E, E, 0, 0, 1, T + E, B], ["Z"]];
      }
      return { arc: A, callout: function(T, B, O, b, v) {
        let E = Math.min(v && v.r || 0, O, b), M = E + 6, g = v && v.anchorX, C = v && v.anchorY || 0, j = q(T, B, O, b, { r: E });
        if (!l(g) || g < O && g > 0 && C < b && C > 0)
          return j;
        if (T + g > O - M)
          if (C > B + M && C < B + b - M)
            j.splice(3, 1, ["L", T + O, C - 6], ["L", T + O + 6, C], ["L", T + O, C + 6], ["L", T + O, B + b - E]);
          else if (g < O) {
            let D = C < B + M, u = D ? B : B + b;
            j.splice(D ? 2 : 5, 0, ["L", g, C], ["L", T + O - E, u]);
          } else
            j.splice(3, 1, ["L", T + O, b / 2], ["L", g, C], ["L", T + O, b / 2], ["L", T + O, B + b - E]);
        else if (T + g < M)
          if (C > B + M && C < B + b - M)
            j.splice(7, 1, ["L", T, C + 6], ["L", T - 6, C], ["L", T, C - 6], ["L", T, B + E]);
          else if (g > 0) {
            let D = C < B + M, u = D ? B : B + b;
            j.splice(D ? 1 : 6, 0, ["L", g, C], ["L", T + E, u]);
          } else
            j.splice(7, 1, ["L", T, b / 2], ["L", g, C], ["L", T, b / 2], ["L", T, B + E]);
        else
          C > b && g < O - M ? j.splice(5, 1, ["L", g + 6, B + b], ["L", g, B + b + 6], ["L", g - 6, B + b], ["L", T + E, B + b]) : C < 0 && g > M && j.splice(1, 1, ["L", g - 6, B], ["L", g, B - 6], ["L", g + 6, B], ["L", O - E, B]);
        return j;
      }, circle: function(T, B, O, b) {
        return A(T + O / 2, B + b / 2, O / 2, b / 2, { start: 0.5 * Math.PI, end: 2.5 * Math.PI, open: !1 });
      }, diamond: function(T, B, O, b) {
        return [["M", T + O / 2, B], ["L", T + O, B + b / 2], ["L", T + O / 2, B + b], ["L", T, B + b / 2], ["Z"]];
      }, rect: Y, roundedRect: q, square: Y, triangle: function(T, B, O, b) {
        return [["M", T + O / 2, B], ["L", T + O, B + b], ["L", T, B + b], ["Z"]];
      }, "triangle-down": function(T, B, O, b) {
        return [["M", T, B], ["L", T + O, B], ["L", T + O / 2, B + b], ["Z"]];
      } };
    }), i(e, "Core/Renderer/SVG/TextBuilder.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function(n, s, l) {
      let { doc: m, SVG_NS: A, win: Y } = s, { attr: q, extend: T, fireEvent: B, isString: O, objectEach: b, pick: v } = l;
      return class {
        constructor(E) {
          let M = E.styles;
          this.renderer = E.renderer, this.svgElement = E, this.width = E.textWidth, this.textLineHeight = M && M.lineHeight, this.textOutline = M && M.textOutline, this.ellipsis = !!(M && M.textOverflow === "ellipsis"), this.noWrap = !!(M && M.whiteSpace === "nowrap");
        }
        buildSVG() {
          let E = this.svgElement, M = E.element, g = E.renderer, C = v(E.textStr, "").toString(), j = C.indexOf("<") !== -1, D = M.childNodes, u = !E.added && g.box, R = [C, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, E.getStyle("font-size"), this.width].join(",");
          if (R !== E.textCache) {
            E.textCache = R, delete E.actualWidth;
            for (let K = D.length; K--; )
              M.removeChild(D[K]);
            if (j || this.ellipsis || this.width || E.textPath || C.indexOf(" ") !== -1 && (!this.noWrap || /<br.*?>/g.test(C))) {
              if (C !== "") {
                u && u.appendChild(M);
                let K = new n(C);
                this.modifyTree(K.nodes), K.addToDOM(M), this.modifyDOM(), this.ellipsis && (M.textContent || "").indexOf("…") !== -1 && E.attr("title", this.unescapeEntities(E.textStr || "", ["&lt;", "&gt;"])), u && u.removeChild(M);
              }
            } else
              M.appendChild(m.createTextNode(this.unescapeEntities(C)));
            O(this.textOutline) && E.applyTextOutline && E.applyTextOutline(this.textOutline);
          }
        }
        modifyDOM() {
          let E, M = this.svgElement, g = q(M.element, "x");
          for (M.firstLineMetrics = void 0; (E = M.element.firstChild) && /^[\s\u200B]*$/.test(E.textContent || " "); )
            M.element.removeChild(E);
          [].forEach.call(M.element.querySelectorAll("tspan.highcharts-br"), (u, R) => {
            u.nextSibling && u.previousSibling && (R === 0 && u.previousSibling.nodeType === 1 && (M.firstLineMetrics = M.renderer.fontMetrics(u.previousSibling)), q(u, { dy: this.getLineHeight(u.nextSibling), x: g }));
          });
          let C = this.width || 0;
          if (!C)
            return;
          let j = (u, R) => {
            let K = u.textContent || "", I = K.replace(/([^\^])-/g, "$1- ").split(" "), z = !this.noWrap && (I.length > 1 || M.element.childNodes.length > 1), k = this.getLineHeight(R), h = 0, F = M.actualWidth;
            if (this.ellipsis)
              K && this.truncate(u, K, void 0, 0, Math.max(0, C - 0.8 * k), (o, a) => o.substring(0, a) + "…");
            else if (z) {
              let o = [], a = [];
              for (; R.firstChild && R.firstChild !== u; )
                a.push(R.firstChild), R.removeChild(R.firstChild);
              for (; I.length; )
                I.length && !this.noWrap && h > 0 && (o.push(u.textContent || ""), u.textContent = I.join(" ").replace(/- /g, "-")), this.truncate(u, void 0, I, h === 0 && F || 0, C, (c, d) => I.slice(0, d).join(" ").replace(/- /g, "-")), F = M.actualWidth, h++;
              a.forEach((c) => {
                R.insertBefore(c, u);
              }), o.forEach((c) => {
                R.insertBefore(m.createTextNode(c), u);
                let d = m.createElementNS(A, "tspan");
                d.textContent = "​", q(d, { dy: k, x: g }), R.insertBefore(d, u);
              });
            }
          }, D = (u) => {
            [].slice.call(u.childNodes).forEach((R) => {
              R.nodeType === Y.Node.TEXT_NODE ? j(R, u) : (R.className.baseVal.indexOf("highcharts-br") !== -1 && (M.actualWidth = 0), D(R));
            });
          };
          D(M.element);
        }
        getLineHeight(E) {
          let M = E.nodeType === Y.Node.TEXT_NODE ? E.parentElement : E;
          return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(M || this.svgElement.element).h;
        }
        modifyTree(E) {
          let M = (g, C) => {
            let { attributes: j = {}, children: D, style: u = {}, tagName: R } = g, K = this.renderer.styledMode;
            if (R === "b" || R === "strong" ? K ? j.class = "highcharts-strong" : u.fontWeight = "bold" : (R === "i" || R === "em") && (K ? j.class = "highcharts-emphasized" : u.fontStyle = "italic"), u && u.color && (u.fill = u.color), R === "br") {
              j.class = "highcharts-br", g.textContent = "​";
              let I = E[C + 1];
              I && I.textContent && (I.textContent = I.textContent.replace(/^ +/gm, ""));
            } else
              R === "a" && D && D.some((I) => I.tagName === "#text") && (g.children = [{ children: D, tagName: "tspan" }]);
            R !== "#text" && R !== "a" && (g.tagName = "tspan"), T(g, { attributes: j, style: u }), D && D.filter((I) => I.tagName !== "#text").forEach(M);
          };
          E.forEach(M), B(this.svgElement, "afterModifyTree", { nodes: E });
        }
        truncate(E, M, g, C, j, D) {
          let u, R, K = this.svgElement, { rotation: I } = K, z = [], k = g ? 1 : 0, h = (M || g || "").length, F = h, o = function(a, c) {
            let d = c || a, S = E.parentNode;
            if (S && z[d] === void 0 && S.getSubStringLength)
              try {
                z[d] = C + S.getSubStringLength(0, g ? d + 1 : d);
              } catch {
              }
            return z[d];
          };
          if (K.rotation = 0, C + (R = o(E.textContent.length)) > j) {
            for (; k <= h; )
              F = Math.ceil((k + h) / 2), g && (u = D(g, F)), R = o(F, u && u.length - 1), k === h ? k = h + 1 : R > j ? h = F - 1 : k = F;
            h === 0 ? E.textContent = "" : M && h === M.length - 1 || (E.textContent = u || D(M || g, F));
          }
          g && g.splice(0, F), K.actualWidth = R, K.rotation = I;
        }
        unescapeEntities(E, M) {
          return b(this.renderer.escapes, function(g, C) {
            M && M.indexOf(g) !== -1 || (E = E.toString().replace(RegExp(g, "g"), C));
          }), E;
        }
      };
    }), i(e, "Core/Renderer/SVG/SVGRenderer.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Renderer/SVG/SVGLabel.js"], e["Core/Renderer/SVG/Symbols.js"], e["Core/Renderer/SVG/TextBuilder.js"], e["Core/Utilities.js"]], function(n, s, l, m, A, Y, q, T, B) {
      let O, { charts: b, deg2rad: v, doc: E, isFirefox: M, isMS: g, isWebKit: C, noop: j, SVG_NS: D, symbolSizes: u, win: R } = l, { addEvent: K, attr: I, createElement: z, css: k, defined: h, destroyObjectProperties: F, extend: o, isArray: a, isNumber: c, isObject: d, isString: S, merge: P, pick: G, pInt: x, replaceNested: Q, uniqueKey: J } = B;
      class ie {
        constructor($, oe, p, W, X, f, L) {
          let w, H, U = this.createElement("svg").attr({ version: "1.1", class: "highcharts-root" }), ee = U.element;
          L || U.css(this.getStyle(W || {})), $.appendChild(ee), I($, "dir", "ltr"), $.innerHTML.indexOf("xmlns") === -1 && I(ee, "xmlns", this.SVG_NS), this.box = ee, this.boxWrapper = U, this.alignedObjects = [], this.url = this.getReferenceURL(), this.createElement("desc").add().element.appendChild(E.createTextNode("Created with Highcharts 11.4.1")), this.defs = this.createElement("defs").add(), this.allowHTML = f, this.forExport = X, this.styledMode = L, this.gradients = {}, this.cache = {}, this.cacheKeys = [], this.imgCount = 0, this.rootFontSize = U.getStyle("font-size"), this.setSize(oe, p, !1), M && $.getBoundingClientRect && ((w = function() {
            k($, { left: 0, top: 0 }), H = $.getBoundingClientRect(), k($, { left: Math.ceil(H.left) - H.left + "px", top: Math.ceil(H.top) - H.top + "px" });
          })(), this.unSubPixelFix = K(R, "resize", w));
        }
        definition($) {
          return new n([$]).addToDOM(this.defs.element);
        }
        getReferenceURL() {
          if ((M || C) && E.getElementsByTagName("base").length) {
            if (!h(O)) {
              let $ = J(), oe = new n([{ tagName: "svg", attributes: { width: 8, height: 8 }, children: [{ tagName: "defs", children: [{ tagName: "clipPath", attributes: { id: $ }, children: [{ tagName: "rect", attributes: { width: 4, height: 4 } }] }] }, { tagName: "rect", attributes: { id: "hitme", width: 8, height: 8, "clip-path": `url(#${$})`, fill: "rgba(0,0,0,0.001)" } }] }]).addToDOM(E.body);
              k(oe, { position: "fixed", top: 0, left: 0, zIndex: 9e5 });
              let p = E.elementFromPoint(6, 6);
              O = (p && p.id) === "hitme", E.body.removeChild(oe);
            }
            if (O)
              return Q(R.location.href.split("#")[0], [/<[^>]*>/g, ""], [/([\('\)])/g, "\\$1"], [/ /g, "%20"]);
          }
          return "";
        }
        getStyle($) {
          return this.style = o({ fontFamily: "Helvetica, Arial, sans-serif", fontSize: "1rem" }, $), this.style;
        }
        setStyle($) {
          this.boxWrapper.css(this.getStyle($));
        }
        isHidden() {
          return !this.boxWrapper.getBBox().width;
        }
        destroy() {
          let $ = this.defs;
          return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), F(this.gradients || {}), this.gradients = null, this.defs = $.destroy(), this.unSubPixelFix && this.unSubPixelFix(), this.alignedObjects = null, null;
        }
        createElement($) {
          return new this.Element(this, $);
        }
        getRadialAttr($, oe) {
          return { cx: $[0] - $[2] / 2 + (oe.cx || 0) * $[2], cy: $[1] - $[2] / 2 + (oe.cy || 0) * $[2], r: (oe.r || 0) * $[2] };
        }
        shadowDefinition($) {
          let oe = [`highcharts-drop-shadow-${this.chartIndex}`, ...Object.keys($).map((W) => `${W}-${$[W]}`)].join("-").toLowerCase().replace(/[^a-z0-9\-]/g, ""), p = P({ color: "#000000", offsetX: 1, offsetY: 1, opacity: 0.15, width: 5 }, $);
          return this.defs.element.querySelector(`#${oe}`) || this.definition({ tagName: "filter", attributes: { id: oe, filterUnits: p.filterUnits }, children: [{ tagName: "feDropShadow", attributes: { dx: p.offsetX, dy: p.offsetY, "flood-color": p.color, "flood-opacity": Math.min(5 * p.opacity, 1), stdDeviation: p.width / 2 } }] }), oe;
        }
        buildText($) {
          new T($).buildSVG();
        }
        getContrast($) {
          let oe = s.parse($).rgba.map((W) => {
            let X = W / 255;
            return X <= 0.03928 ? X / 12.92 : Math.pow((X + 0.055) / 1.055, 2.4);
          }), p = 0.2126 * oe[0] + 0.7152 * oe[1] + 0.0722 * oe[2];
          return 1.05 / (p + 0.05) > (p + 0.05) / 0.05 ? "#FFFFFF" : "#000000";
        }
        button($, oe, p, W, X = {}, f, L, w, H, U) {
          let ee, ae, ne, he = this.label($, oe, p, H, void 0, void 0, U, void 0, "button"), me = this.styledMode, ve = X.states || {}, Me = 0;
          X = P(X), delete X.states;
          let Z = P({ color: "#333333", cursor: "pointer", fontSize: "0.8em", fontWeight: "normal" }, X.style);
          delete X.style;
          let V = n.filterUserAttributes(X);
          return he.attr(P({ padding: 8, r: 2 }, V)), me || (V = P({ fill: "#f7f7f7", stroke: "#cccccc", "stroke-width": 1 }, V), ee = (f = P(V, { fill: "#e6e6e6" }, n.filterUserAttributes(f || ve.hover || {}))).style, delete f.style, ae = (L = P(V, { fill: "#e6e9ff", style: { color: "#000000", fontWeight: "bold" } }, n.filterUserAttributes(L || ve.select || {}))).style, delete L.style, ne = (w = P(V, { style: { color: "#cccccc" } }, n.filterUserAttributes(w || ve.disabled || {}))).style, delete w.style), K(he.element, g ? "mouseover" : "mouseenter", function() {
            Me !== 3 && he.setState(1);
          }), K(he.element, g ? "mouseout" : "mouseleave", function() {
            Me !== 3 && he.setState(Me);
          }), he.setState = function(re) {
            if (re !== 1 && (he.state = Me = re), he.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][re || 0]), !me) {
              he.attr([V, f, L, w][re || 0]);
              let le = [Z, ee, ae, ne][re || 0];
              d(le) && he.css(le);
            }
          }, !me && (he.attr(V).css(o({ cursor: "default" }, Z)), U && he.text.css({ pointerEvents: "none" })), he.on("touchstart", (re) => re.stopPropagation()).on("click", function(re) {
            Me !== 3 && W.call(he, re);
          });
        }
        crispLine($, oe, p = "round") {
          let W = $[0], X = $[1];
          return h(W[1]) && W[1] === X[1] && (W[1] = X[1] = Math[p](W[1]) - oe % 2 / 2), h(W[2]) && W[2] === X[2] && (W[2] = X[2] = Math[p](W[2]) + oe % 2 / 2), $;
        }
        path($) {
          let oe = this.styledMode ? {} : { fill: "none" };
          return a($) ? oe.d = $ : d($) && o(oe, $), this.createElement("path").attr(oe);
        }
        circle($, oe, p) {
          let W = d($) ? $ : $ === void 0 ? {} : { x: $, y: oe, r: p }, X = this.createElement("circle");
          return X.xSetter = X.ySetter = function(f, L, w) {
            w.setAttribute("c" + L, f);
          }, X.attr(W);
        }
        arc($, oe, p, W, X, f) {
          let L;
          d($) ? (oe = (L = $).y, p = L.r, W = L.innerR, X = L.start, f = L.end, $ = L.x) : L = { innerR: W, start: X, end: f };
          let w = this.symbol("arc", $, oe, p, p, L);
          return w.r = p, w;
        }
        rect($, oe, p, W, X, f) {
          let L = d($) ? $ : $ === void 0 ? {} : { x: $, y: oe, r: X, width: Math.max(p || 0, 0), height: Math.max(W || 0, 0) }, w = this.createElement("rect");
          return this.styledMode || (f !== void 0 && (L["stroke-width"] = f, o(L, w.crisp(L))), L.fill = "none"), w.rSetter = function(H, U, ee) {
            w.r = H, I(ee, { rx: H, ry: H });
          }, w.rGetter = function() {
            return w.r || 0;
          }, w.attr(L);
        }
        roundedRect($) {
          return this.symbol("roundedRect").attr($);
        }
        setSize($, oe, p) {
          this.width = $, this.height = oe, this.boxWrapper.animate({ width: $, height: oe }, { step: function() {
            this.attr({ viewBox: "0 0 " + this.attr("width") + " " + this.attr("height") });
          }, duration: G(p, !0) ? void 0 : 0 }), this.alignElements();
        }
        g($) {
          let oe = this.createElement("g");
          return $ ? oe.attr({ class: "highcharts-" + $ }) : oe;
        }
        image($, oe, p, W, X, f) {
          let L = { preserveAspectRatio: "none" };
          c(oe) && (L.x = oe), c(p) && (L.y = p), c(W) && (L.width = W), c(X) && (L.height = X);
          let w = this.createElement("image").attr(L), H = function(U) {
            w.attr({ href: $ }), f.call(w, U);
          };
          if (f) {
            w.attr({ href: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" });
            let U = new R.Image();
            K(U, "load", H), U.src = $, U.complete && H({});
          } else
            w.attr({ href: $ });
          return w;
        }
        symbol($, oe, p, W, X, f) {
          let L, w, H, U, ee = this, ae = /^url\((.*?)\)$/, ne = ae.test($), he = !ne && (this.symbols[$] ? $ : "circle"), me = he && this.symbols[he];
          if (me)
            typeof oe == "number" && (w = me.call(this.symbols, Math.round(oe || 0), Math.round(p || 0), W || 0, X || 0, f)), L = this.path(w), ee.styledMode || L.attr("fill", "none"), o(L, { symbolName: he || void 0, x: oe, y: p, width: W, height: X }), f && o(L, f);
          else if (ne) {
            H = $.match(ae)[1];
            let ve = L = this.image(H);
            ve.imgwidth = G(f && f.width, u[H] && u[H].width), ve.imgheight = G(f && f.height, u[H] && u[H].height), U = (Me) => Me.attr({ width: Me.width, height: Me.height }), ["width", "height"].forEach((Me) => {
              ve[`${Me}Setter`] = function(Z, V) {
                this[V] = Z;
                let { alignByTranslate: re, element: le, width: be, height: de, imgwidth: ge, imgheight: fe } = this, ke = V === "width" ? ge : fe, Pe = 1;
                f && f.backgroundSize === "within" && be && de && ge && fe ? (Pe = Math.min(be / ge, de / fe), I(le, { width: Math.round(ge * Pe), height: Math.round(fe * Pe) })) : le && ke && le.setAttribute(V, ke), !re && ge && fe && this.translate(((be || 0) - ge * Pe) / 2, ((de || 0) - fe * Pe) / 2);
              };
            }), h(oe) && ve.attr({ x: oe, y: p }), ve.isImg = !0, h(ve.imgwidth) && h(ve.imgheight) ? U(ve) : (ve.attr({ width: 0, height: 0 }), z("img", { onload: function() {
              let Me = b[ee.chartIndex];
              this.width === 0 && (k(this, { position: "absolute", top: "-999em" }), E.body.appendChild(this)), u[H] = { width: this.width, height: this.height }, ve.imgwidth = this.width, ve.imgheight = this.height, ve.element && U(ve), this.parentNode && this.parentNode.removeChild(this), ee.imgCount--, ee.imgCount || !Me || Me.hasLoaded || Me.onload();
            }, src: H }), this.imgCount++);
          }
          return L;
        }
        clipRect($, oe, p, W) {
          return this.rect($, oe, p, W, 0);
        }
        text($, oe, p, W) {
          let X = {};
          if (W && (this.allowHTML || !this.forExport))
            return this.html($, oe, p);
          X.x = Math.round(oe || 0), p && (X.y = Math.round(p)), h($) && (X.text = $);
          let f = this.createElement("text").attr(X);
          return W && (!this.forExport || this.allowHTML) || (f.xSetter = function(L, w, H) {
            let U = H.getElementsByTagName("tspan"), ee = H.getAttribute(w);
            for (let ae = 0, ne; ae < U.length; ae++)
              (ne = U[ae]).getAttribute(w) === ee && ne.setAttribute(w, L);
            H.setAttribute(w, L);
          }), f;
        }
        fontMetrics($) {
          let oe = x(A.prototype.getStyle.call($, "font-size") || 0), p = oe < 24 ? oe + 3 : Math.round(1.2 * oe), W = Math.round(0.8 * p);
          return { h: p, b: W, f: oe };
        }
        rotCorr($, oe, p) {
          let W = $;
          return oe && p && (W = Math.max(W * Math.cos(oe * v), 4)), { x: -$ / 3 * Math.sin(oe * v), y: W };
        }
        pathToSegments($) {
          let oe = [], p = [], W = { A: 8, C: 7, H: 2, L: 3, M: 3, Q: 5, S: 5, T: 3, V: 2 };
          for (let X = 0; X < $.length; X++)
            S(p[0]) && c($[X]) && p.length === W[p[0].toUpperCase()] && $.splice(X, 0, p[0].replace("M", "L").replace("m", "l")), typeof $[X] == "string" && (p.length && oe.push(p.slice(0)), p.length = 0), p.push($[X]);
          return oe.push(p.slice(0)), oe;
        }
        label($, oe, p, W, X, f, L, w, H) {
          return new Y(this, $, oe, p, W, X, f, L, w, H);
        }
        alignElements() {
          this.alignedObjects.forEach(($) => $.align());
        }
      }
      return o(ie.prototype, { Element: A, SVG_NS: D, escapes: { "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" }, symbols: q, draw: j }), m.registerRendererType("svg", ie, !0), ie;
    }), i(e, "Core/Renderer/HTML/HTMLElement.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Globals.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function(n, s, l, m) {
      let { composed: A } = s, { attr: Y, css: q, createElement: T, defined: B, extend: O, pInt: b, pushUnique: v } = m;
      function E(j, D, u) {
        var K;
        let R = ((K = this.div) == null ? void 0 : K.style) || u.style;
        l.prototype[`${D}Setter`].call(this, j, D, u), R && (R[D] = j);
      }
      let M = (j, D) => {
        var u;
        if (!j.div) {
          let R = Y(j.element, "class"), K = j.css, I = T("div", R ? { className: R } : void 0, { position: "absolute", left: `${j.translateX || 0}px`, top: `${j.translateY || 0}px`, ...j.styles, display: j.display, opacity: j.opacity, visibility: j.visibility }, ((u = j.parentGroup) == null ? void 0 : u.div) || D);
          j.classSetter = (z, k, h) => {
            h.setAttribute("class", z), I.className = z;
          }, j.translateXSetter = j.translateYSetter = (z, k) => {
            j[k] = z, I.style[k === "translateX" ? "left" : "top"] = `${z}px`, j.doTransform = !0;
          }, j.opacitySetter = j.visibilitySetter = E, j.css = (z) => (K.call(j, z), z.cursor && (I.style.cursor = z.cursor), z.pointerEvents && (I.style.pointerEvents = z.pointerEvents), j), j.on = function() {
            return l.prototype.on.apply({ element: I, onEvents: j.onEvents }, arguments), j;
          }, j.div = I;
        }
        return j.div;
      };
      class g extends l {
        static compose(D) {
          v(A, this.compose) && (D.prototype.html = function(u, R, K) {
            return new g(this, "span").attr({ text: u, x: Math.round(R), y: Math.round(K) });
          });
        }
        constructor(D, u) {
          super(D, u), this.css({ position: "absolute", ...D.styledMode ? {} : { fontFamily: D.style.fontFamily, fontSize: D.style.fontSize } }), this.element.style.whiteSpace = "nowrap";
        }
        getSpanCorrection(D, u, R) {
          this.xCorr = -D * R, this.yCorr = -u;
        }
        css(D) {
          let u, { element: R } = this, K = R.tagName === "SPAN" && D && "width" in D, I = K && D.width;
          return K && (delete D.width, this.textWidth = b(I) || void 0, u = !0), (D == null ? void 0 : D.textOverflow) === "ellipsis" && (D.whiteSpace = "nowrap", D.overflow = "hidden"), O(this.styles, D), q(R, D), u && this.updateTransform(), this;
        }
        htmlGetBBox() {
          let { element: D } = this;
          return { x: D.offsetLeft, y: D.offsetTop, width: D.offsetWidth, height: D.offsetHeight };
        }
        updateTransform() {
          var S;
          if (!this.added) {
            this.alignOnAdd = !0;
            return;
          }
          let { element: D, renderer: u, rotation: R, rotationOriginX: K, rotationOriginY: I, styles: z, textAlign: k = "left", textWidth: h, translateX: F = 0, translateY: o = 0, x: a = 0, y: c = 0 } = this, d = z.whiteSpace;
          if (q(D, { marginLeft: `${F}px`, marginTop: `${o}px` }), D.tagName === "SPAN") {
            let P = [R, k, D.innerHTML, h, this.textAlign].join(","), G = -(((S = this.parentGroup) == null ? void 0 : S.padding) * 1) || 0, x, Q = !1;
            if (h !== this.oldTextWidth) {
              let oe = this.textPxLength ? this.textPxLength : (q(D, { width: "", whiteSpace: d || "nowrap" }), D.offsetWidth), p = h || 0;
              (p > this.oldTextWidth || oe > p) && (/[ \-]/.test(D.textContent || D.innerText) || D.style.textOverflow === "ellipsis") && (q(D, { width: oe > p || R ? h + "px" : "auto", display: "block", whiteSpace: d || "normal" }), this.oldTextWidth = h, Q = !0);
            }
            this.hasBoxWidthChanged = Q, P !== this.cTT && (x = u.fontMetrics(D).b, B(R) && (R !== (this.oldRotation || 0) || k !== this.oldAlign) && this.setSpanRotation(R, G, G), this.getSpanCorrection(!B(R) && this.textPxLength || D.offsetWidth, x, { left: 0, center: 0.5, right: 1 }[k]));
            let { xCorr: J = 0, yCorr: ie = 0 } = this, te = (K ?? a) - J - a - G, $ = (I ?? c) - ie - c - G;
            q(D, { left: `${a + J}px`, top: `${c + ie}px`, transformOrigin: `${te}px ${$}px` }), this.cTT = P, this.oldRotation = R, this.oldAlign = k;
          }
        }
        setSpanRotation(D, u, R) {
          q(this.element, { transform: `rotate(${D}deg)`, transformOrigin: `${u}% ${R}px` });
        }
        add(D) {
          let u, R = this.renderer.box.parentNode, K = [];
          if (this.parentGroup = D, D && !(u = D.div)) {
            let I = D;
            for (; I; )
              K.push(I), I = I.parentGroup;
            for (let z of K.reverse())
              u = M(z, R);
          }
          return (u || R).appendChild(this.element), this.added = !0, this.alignOnAdd && this.updateTransform(), this;
        }
        textSetter(D) {
          D !== this.textStr && (delete this.bBox, delete this.oldTextWidth, n.setElementHTML(this.element, D ?? ""), this.textStr = D, this.doTransform = !0);
        }
        alignSetter(D) {
          this.alignValue = this.textAlign = D, this.doTransform = !0;
        }
        xSetter(D, u) {
          this[u] = D, this.doTransform = !0;
        }
      }
      let C = g.prototype;
      return C.visibilitySetter = C.opacitySetter = E, C.ySetter = C.rotationSetter = C.rotationOriginXSetter = C.rotationOriginYSetter = C.xSetter, g;
    }), i(e, "Core/Axis/AxisDefaults.js", [], function() {
      var n, s;
      return (s = n || (n = {})).xAxis = { alignTicks: !0, allowDecimals: void 0, panningEnabled: !0, zIndex: 2, zoomEnabled: !0, dateTimeLabelFormats: { millisecond: { main: "%H:%M:%S.%L", range: !1 }, second: { main: "%H:%M:%S", range: !1 }, minute: { main: "%H:%M", range: !1 }, hour: { main: "%H:%M", range: !1 }, day: { main: "%e %b" }, week: { main: "%e %b" }, month: { main: "%b '%y" }, year: { main: "%Y" } }, endOnTick: !1, gridLineDashStyle: "Solid", gridZIndex: 1, labels: { autoRotationLimit: 80, distance: 15, enabled: !0, indentation: 10, overflow: "justify", padding: 5, reserveSpace: void 0, rotation: void 0, staggerLines: 0, step: 0, useHTML: !1, zIndex: 7, style: { color: "#333333", cursor: "default", fontSize: "0.8em" } }, maxPadding: 0.01, minorGridLineDashStyle: "Solid", minorTickLength: 2, minorTickPosition: "outside", minorTicksPerMajor: 5, minPadding: 0.01, offset: void 0, reversed: void 0, reversedStacks: !1, showEmpty: !0, showFirstLabel: !0, showLastLabel: !0, startOfWeek: 1, startOnTick: !1, tickLength: 10, tickPixelInterval: 100, tickmarkPlacement: "between", tickPosition: "outside", title: { align: "middle", useHTML: !1, x: 0, y: 0, style: { color: "#666666", fontSize: "0.8em" } }, type: "linear", uniqueNames: !0, visible: !0, minorGridLineColor: "#f2f2f2", minorGridLineWidth: 1, minorTickColor: "#999999", lineColor: "#333333", lineWidth: 1, gridLineColor: "#e6e6e6", gridLineWidth: void 0, tickColor: "#333333" }, s.yAxis = { reversedStacks: !0, endOnTick: !0, maxPadding: 0.05, minPadding: 0.05, tickPixelInterval: 72, showLastLabel: !0, labels: { x: void 0 }, startOnTick: !0, title: { text: "Values" }, stackLabels: { animation: {}, allowOverlap: !1, enabled: !1, crop: !0, overflow: "justify", formatter: function() {
        let { numberFormatter: l } = this.axis.chart;
        return l(this.total || 0, -1);
      }, style: { color: "#000000", fontSize: "0.7em", fontWeight: "bold", textOutline: "1px contrast" } }, gridLineWidth: 1, lineWidth: 0 }, n;
    }), i(e, "Core/Foundation.js", [e["Core/Utilities.js"]], function(n) {
      var s;
      let { addEvent: l, isFunction: m, objectEach: A, removeEvent: Y } = n;
      return (s || (s = {})).registerEventOptions = function(q, T) {
        q.eventOptions = q.eventOptions || {}, A(T.events, function(B, O) {
          q.eventOptions[O] !== B && (q.eventOptions[O] && (Y(q, O, q.eventOptions[O]), delete q.eventOptions[O]), m(B) && (q.eventOptions[O] = B, l(q, O, B, { order: 0 })));
        });
      }, s;
    }), i(e, "Core/Axis/Tick.js", [e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function(n, s, l) {
      let { deg2rad: m } = s, { clamp: A, correctFloat: Y, defined: q, destroyObjectProperties: T, extend: B, fireEvent: O, isNumber: b, merge: v, objectEach: E, pick: M } = l;
      return class {
        constructor(g, C, j, D, u) {
          this.isNew = !0, this.isNewLabel = !0, this.axis = g, this.pos = C, this.type = j || "", this.parameters = u || {}, this.tickmarkOffset = this.parameters.tickmarkOffset, this.options = this.parameters.options, O(this, "init"), j || D || this.addLabel();
        }
        addLabel() {
          let g = this, C = g.axis, j = C.options, D = C.chart, u = C.categories, R = C.logarithmic, K = C.names, I = g.pos, z = M(g.options && g.options.labels, j.labels), k = C.tickPositions, h = I === k[0], F = I === k[k.length - 1], o = (!z.step || z.step === 1) && C.tickInterval === 1, a = k.info, c = g.label, d, S, P, G = this.parameters.category || (u ? M(u[I], K[I], I) : I);
          R && b(G) && (G = Y(R.lin2log(G))), C.dateTime && (a ? d = (S = D.time.resolveDTLFormat(j.dateTimeLabelFormats[!j.grid && a.higherRanks[I] || a.unitName])).main : b(G) && (d = C.dateTime.getXDateFormat(G, j.dateTimeLabelFormats || {}))), g.isFirst = h, g.isLast = F;
          let x = { axis: C, chart: D, dateTimeLabelFormat: d, isFirst: h, isLast: F, pos: I, tick: g, tickPositionInfo: a, value: G };
          O(this, "labelFormat", x);
          let Q = (te) => z.formatter ? z.formatter.call(te, te) : z.format ? (te.text = C.defaultLabelFormatter.call(te), n.format(z.format, te, D)) : C.defaultLabelFormatter.call(te), J = Q.call(x, x), ie = S && S.list;
          ie ? g.shortenLabel = function() {
            for (P = 0; P < ie.length; P++)
              if (B(x, { dateTimeLabelFormat: ie[P] }), c.attr({ text: Q.call(x, x) }), c.getBBox().width < C.getSlotWidth(g) - 2 * z.padding)
                return;
            c.attr({ text: "" });
          } : g.shortenLabel = void 0, o && C._addedPlotLB && g.moveLabel(J, z), q(c) || g.movedLabel ? c && c.textStr !== J && !o && (!c.textWidth || z.style.width || c.styles.width || c.css({ width: null }), c.attr({ text: J }), c.textPxLength = c.getBBox().width) : (g.label = c = g.createLabel(J, z), g.rotation = 0);
        }
        createLabel(g, C, j) {
          let D = this.axis, u = D.chart, R = q(g) && C.enabled ? u.renderer.text(g, j == null ? void 0 : j.x, j == null ? void 0 : j.y, C.useHTML).add(D.labelGroup) : void 0;
          return R && (u.styledMode || R.css(v(C.style)), R.textPxLength = R.getBBox().width), R;
        }
        destroy() {
          T(this, this.axis);
        }
        getPosition(g, C, j, D) {
          let u = this.axis, R = u.chart, K = D && R.oldChartHeight || R.chartHeight, I = { x: g ? Y(u.translate(C + j, void 0, void 0, D) + u.transB) : u.left + u.offset + (u.opposite ? (D && R.oldChartWidth || R.chartWidth) - u.right - u.left : 0), y: g ? K - u.bottom + u.offset - (u.opposite ? u.height : 0) : Y(K - u.translate(C + j, void 0, void 0, D) - u.transB) };
          return I.y = A(I.y, -1e5, 1e5), O(this, "afterGetPosition", { pos: I }), I;
        }
        getLabelPosition(g, C, j, D, u, R, K, I) {
          let z, k, h = this.axis, F = h.transA, o = h.isLinked && h.linkedParent ? h.linkedParent.reversed : h.reversed, a = h.staggerLines, c = h.tickRotCorr || { x: 0, y: 0 }, d = D || h.reserveSpaceDefault ? 0 : -h.labelOffset * (h.labelAlign === "center" ? 0.5 : 1), S = u.distance, P = {};
          return z = h.side === 0 ? j.rotation ? -S : -j.getBBox().height : h.side === 2 ? c.y + S : Math.cos(j.rotation * m) * (c.y - j.getBBox(!1, 0).height / 2), q(u.y) && (z = h.side === 0 && h.horiz ? u.y + z : u.y), g = g + M(u.x, [0, 1, 0, -1][h.side] * S) + d + c.x - (R && D ? R * F * (o ? -1 : 1) : 0), C = C + z - (R && !D ? R * F * (o ? 1 : -1) : 0), a && (k = K / (I || 1) % a, h.opposite && (k = a - k - 1), C += h.labelOffset / a * k), P.x = g, P.y = Math.round(C), O(this, "afterGetLabelPosition", { pos: P, tickmarkOffset: R, index: K }), P;
        }
        getLabelSize() {
          return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
        }
        getMarkPath(g, C, j, D, u, R) {
          return R.crispLine([["M", g, C], ["L", g + (u ? 0 : -j), C + (u ? j : 0)]], D);
        }
        handleOverflow(g) {
          let C = this.axis, j = C.options.labels, D = g.x, u = C.chart.chartWidth, R = C.chart.spacing, K = M(C.labelLeft, Math.min(C.pos, R[3])), I = M(C.labelRight, Math.max(C.isRadial ? 0 : C.pos + C.len, u - R[1])), z = this.label, k = this.rotation, h = { left: 0, center: 0.5, right: 1 }[C.labelAlign || z.attr("align")], F = z.getBBox().width, o = C.getSlotWidth(this), a = {}, c = o, d = 1, S, P, G;
          k || j.overflow !== "justify" ? k < 0 && D - h * F < K ? G = Math.round(D / Math.cos(k * m) - K) : k > 0 && D + h * F > I && (G = Math.round((u - D) / Math.cos(k * m))) : (S = D - h * F, P = D + (1 - h) * F, S < K ? c = g.x + c * (1 - h) - K : P > I && (c = I - g.x + c * h, d = -1), (c = Math.min(o, c)) < o && C.labelAlign === "center" && (g.x += d * (o - c - h * (o - Math.min(F, c)))), (F > c || C.autoRotation && (z.styles || {}).width) && (G = c)), G && (this.shortenLabel ? this.shortenLabel() : (a.width = Math.floor(G) + "px", (j.style || {}).textOverflow || (a.textOverflow = "ellipsis"), z.css(a)));
        }
        moveLabel(g, C) {
          let j = this, D = j.label, u = j.axis, R = !1, K;
          D && D.textStr === g ? (j.movedLabel = D, R = !0, delete j.label) : E(u.ticks, function(I) {
            R || I.isNew || I === j || !I.label || I.label.textStr !== g || (j.movedLabel = I.label, R = !0, I.labelPos = j.movedLabel.xy, delete I.label);
          }), !R && (j.labelPos || D) && (K = j.labelPos || D.xy, j.movedLabel = j.createLabel(g, C, K), j.movedLabel && j.movedLabel.attr({ opacity: 0 }));
        }
        render(g, C, j) {
          let D = this.axis, u = D.horiz, R = this.pos, K = M(this.tickmarkOffset, D.tickmarkOffset), I = this.getPosition(u, R, K, C), z = I.x, k = I.y, h = D.pos, F = h + D.len, o = u && z === F || !u && k === h ? -1 : 1, a = u ? z : k;
          !D.chart.polar && this.isNew && (Y(a) < h || a > F) && (j = 0);
          let c = M(j, this.label && this.label.newOpacity, 1);
          j = M(j, 1), this.isActive = !0, this.renderGridLine(C, j, o), this.renderMark(I, j, o), this.renderLabel(I, C, c, g), this.isNew = !1, O(this, "afterRender");
        }
        renderGridLine(g, C, j) {
          let D = this.axis, u = D.options, R = {}, K = this.pos, I = this.type, z = M(this.tickmarkOffset, D.tickmarkOffset), k = D.chart.renderer, h = this.gridLine, F, o = u.gridLineWidth, a = u.gridLineColor, c = u.gridLineDashStyle;
          this.type === "minor" && (o = u.minorGridLineWidth, a = u.minorGridLineColor, c = u.minorGridLineDashStyle), h || (D.chart.styledMode || (R.stroke = a, R["stroke-width"] = o || 0, R.dashstyle = c), I || (R.zIndex = 1), g && (C = 0), this.gridLine = h = k.path().attr(R).addClass("highcharts-" + (I ? I + "-" : "") + "grid-line").add(D.gridGroup)), h && (F = D.getPlotLinePath({ value: K + z, lineWidth: h.strokeWidth() * j, force: "pass", old: g, acrossPanes: !1 })) && h[g || this.isNew ? "attr" : "animate"]({ d: F, opacity: C });
        }
        renderMark(g, C, j) {
          let D = this.axis, u = D.options, R = D.chart.renderer, K = this.type, I = D.tickSize(K ? K + "Tick" : "tick"), z = g.x, k = g.y, h = M(u[K !== "minor" ? "tickWidth" : "minorTickWidth"], !K && D.isXAxis ? 1 : 0), F = u[K !== "minor" ? "tickColor" : "minorTickColor"], o = this.mark, a = !o;
          I && (D.opposite && (I[0] = -I[0]), o || (this.mark = o = R.path().addClass("highcharts-" + (K ? K + "-" : "") + "tick").add(D.axisGroup), D.chart.styledMode || o.attr({ stroke: F, "stroke-width": h })), o[a ? "attr" : "animate"]({ d: this.getMarkPath(z, k, I[0], o.strokeWidth() * j, D.horiz, R), opacity: C }));
        }
        renderLabel(g, C, j, D) {
          let u = this.axis, R = u.horiz, K = u.options, I = this.label, z = K.labels, k = z.step, h = M(this.tickmarkOffset, u.tickmarkOffset), F = g.x, o = g.y, a = !0;
          I && b(F) && (I.xy = g = this.getLabelPosition(F, o, I, R, z, h, D, k), (!this.isFirst || this.isLast || K.showFirstLabel) && (!this.isLast || this.isFirst || K.showLastLabel) ? !R || z.step || z.rotation || C || j === 0 || this.handleOverflow(g) : a = !1, k && D % k && (a = !1), a && b(g.y) ? (g.opacity = j, I[this.isNewLabel ? "attr" : "animate"](g).show(!0), this.isNewLabel = !1) : (I.hide(), this.isNewLabel = !0));
        }
        replaceMovedLabel() {
          let g = this.label, C = this.axis;
          g && !this.isNew && (g.animate({ opacity: 0 }, void 0, g.destroy), delete this.label), C.isDirty = !0, this.label = this.movedLabel, delete this.movedLabel;
        }
      };
    }), i(e, "Core/Axis/Axis.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Axis/AxisDefaults.js"], e["Core/Color/Color.js"], e["Core/Defaults.js"], e["Core/Foundation.js"], e["Core/Globals.js"], e["Core/Axis/Tick.js"], e["Core/Utilities.js"]], function(n, s, l, m, A, Y, q, T) {
      let { animObject: B } = n, { xAxis: O, yAxis: b } = s, { defaultOptions: v } = m, { registerEventOptions: E } = A, { deg2rad: M } = Y, { arrayMax: g, arrayMin: C, clamp: j, correctFloat: D, defined: u, destroyObjectProperties: R, erase: K, error: I, extend: z, fireEvent: k, getClosestDistance: h, insertItem: F, isArray: o, isNumber: a, isString: c, merge: d, normalizeTickInterval: S, objectEach: P, pick: G, relativeLength: x, removeEvent: Q, splat: J, syncTimeout: ie } = T, te = (oe, p) => S(p, void 0, void 0, G(oe.options.allowDecimals, p < 0.5 || oe.tickAmount !== void 0), !!oe.tickAmount);
      z(v, { xAxis: O, yAxis: d(O, b) });
      class $ {
        constructor(p, W, X) {
          this.init(p, W, X);
        }
        init(p, W, X = this.coll) {
          let f = X === "xAxis", L = this.isZAxis || (p.inverted ? !f : f);
          this.chart = p, this.horiz = L, this.isXAxis = f, this.coll = X, k(this, "init", { userOptions: W }), this.opposite = G(W.opposite, this.opposite), this.side = G(W.side, this.side, L ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3), this.setOptions(W);
          let w = this.options, H = w.labels, U = w.type;
          this.userOptions = W, this.minPixelPadding = 0, this.reversed = G(w.reversed, this.reversed), this.visible = w.visible, this.zoomEnabled = w.zoomEnabled, this.hasNames = U === "category" || w.categories === !0, this.categories = o(w.categories) && w.categories || (this.hasNames ? [] : void 0), this.names || (this.names = [], this.names.keys = {}), this.plotLinesAndBandsGroups = {}, this.positiveValuesOnly = !!this.logarithmic, this.isLinked = u(w.linkedTo), this.ticks = {}, this.labelEdge = [], this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, this.len = 0, this.minRange = this.userMinRange = w.minRange || w.maxZoom, this.range = w.range, this.offset = w.offset || 0, this.max = void 0, this.min = void 0;
          let ee = G(w.crosshair, J(p.options.tooltip.crosshairs)[f ? 0 : 1]);
          this.crosshair = ee === !0 ? {} : ee, p.axes.indexOf(this) === -1 && (f ? p.axes.splice(p.xAxis.length, 0, this) : p.axes.push(this), F(this, p[this.coll])), p.orderItems(this.coll), this.series = this.series || [], p.inverted && !this.isZAxis && f && !u(this.reversed) && (this.reversed = !0), this.labelRotation = a(H.rotation) ? H.rotation : void 0, E(this, w), k(this, "afterInit");
        }
        setOptions(p) {
          let W = this.horiz ? { labels: { autoRotation: [-45] }, margin: 15 } : { title: { rotation: 90 * this.side } };
          this.options = d(W, v[this.coll], p), k(this, "afterSetOptions", { userOptions: p });
        }
        defaultLabelFormatter() {
          let p = this.axis, { numberFormatter: W } = this.chart, X = a(this.value) ? this.value : NaN, f = p.chart.time, L = p.categories, w = this.dateTimeLabelFormat, H = v.lang, U = H.numericSymbols, ee = H.numericSymbolMagnitude || 1e3, ae = p.logarithmic ? Math.abs(X) : p.tickInterval, ne = U && U.length, he, me;
          if (L)
            me = `${this.value}`;
          else if (w)
            me = f.dateFormat(w, X);
          else if (ne && U && ae >= 1e3)
            for (; ne-- && me === void 0; )
              ae >= (he = Math.pow(ee, ne + 1)) && 10 * X % he == 0 && U[ne] !== null && X !== 0 && (me = W(X / he, -1) + U[ne]);
          return me === void 0 && (me = Math.abs(X) >= 1e4 ? W(X, -1) : W(X, -1, void 0, "")), me;
        }
        getSeriesExtremes() {
          let p, W = this;
          k(this, "getSeriesExtremes", null, function() {
            W.hasVisibleSeries = !1, W.dataMin = W.dataMax = W.threshold = void 0, W.softThreshold = !W.isXAxis, W.series.forEach((X) => {
              if (X.reserveSpace()) {
                let f = X.options, L, w = f.threshold, H, U;
                if (W.hasVisibleSeries = !0, W.positiveValuesOnly && 0 >= (w || 0) && (w = void 0), W.isXAxis)
                  (L = X.xData) && L.length && (L = W.logarithmic ? L.filter((ee) => ee > 0) : L, H = (p = X.getXExtremes(L)).min, U = p.max, a(H) || H instanceof Date || (L = L.filter(a), H = (p = X.getXExtremes(L)).min, U = p.max), L.length && (W.dataMin = Math.min(G(W.dataMin, H), H), W.dataMax = Math.max(G(W.dataMax, U), U)));
                else {
                  let ee = X.applyExtremes();
                  a(ee.dataMin) && (H = ee.dataMin, W.dataMin = Math.min(G(W.dataMin, H), H)), a(ee.dataMax) && (U = ee.dataMax, W.dataMax = Math.max(G(W.dataMax, U), U)), u(w) && (W.threshold = w), (!f.softThreshold || W.positiveValuesOnly) && (W.softThreshold = !1);
                }
              }
            });
          }), k(this, "afterGetSeriesExtremes");
        }
        translate(p, W, X, f, L, w) {
          var Me;
          let H = this.linkedParent || this, U = f && H.old ? H.old.min : H.min;
          if (!a(U))
            return NaN;
          let ee = H.minPixelPadding, ae = (H.isOrdinal || ((Me = H.brokenAxis) == null ? void 0 : Me.hasBreaks) || H.logarithmic && L) && H.lin2val, ne = 1, he = 0, me = f && H.old ? H.old.transA : H.transA, ve = 0;
          if (me || (me = H.transA), X && (ne *= -1, he = H.len), H.reversed && (ne *= -1, he -= ne * (H.sector || H.len)), W)
            ve = (p = p * ne + he - ee) / me + U, ae && (ve = H.lin2val(ve));
          else {
            ae && (p = H.val2lin(p));
            let Z = ne * (p - U) * me;
            ve = (H.isRadial ? Z : D(Z)) + he + ne * ee + (a(w) ? me * w : 0);
          }
          return ve;
        }
        toPixels(p, W) {
          return this.translate(p, !1, !this.horiz, void 0, !0) + (W ? 0 : this.pos);
        }
        toValue(p, W) {
          return this.translate(p - (W ? 0 : this.pos), !0, !this.horiz, void 0, !0);
        }
        getPlotLinePath(p) {
          let W = this, X = W.chart, f = W.left, L = W.top, w = p.old, H = p.value, U = p.lineWidth, ee = w && X.oldChartHeight || X.chartHeight, ae = w && X.oldChartWidth || X.chartWidth, ne = W.transB, he = p.translatedValue, me = p.force, ve, Me, Z, V, re;
          function le(de, ge, fe) {
            return me !== "pass" && (de < ge || de > fe) && (me ? de = j(de, ge, fe) : re = !0), de;
          }
          let be = { value: H, lineWidth: U, old: w, force: me, acrossPanes: p.acrossPanes, translatedValue: he };
          return k(this, "getPlotLinePath", be, function(de) {
            ve = Z = Math.round((he = j(he = G(he, W.translate(H, void 0, void 0, w)), -1e5, 1e5)) + ne), Me = V = Math.round(ee - he - ne), a(he) ? W.horiz ? (Me = L, V = ee - W.bottom + (X.scrollablePixelsY || 0), ve = Z = le(ve, f, f + W.width)) : (ve = f, Z = ae - W.right + (X.scrollablePixelsX || 0), Me = V = le(Me, L, L + W.height)) : (re = !0, me = !1), de.path = re && !me ? void 0 : X.renderer.crispLine([["M", ve, Me], ["L", Z, V]], U || 1);
          }), be.path;
        }
        getLinearTickPositions(p, W, X) {
          let f, L, w, H = D(Math.floor(W / p) * p), U = D(Math.ceil(X / p) * p), ee = [];
          if (D(H + p) === H && (w = 20), this.single)
            return [W];
          for (f = H; f <= U && (ee.push(f), (f = D(f + p, w)) !== L); )
            L = f;
          return ee;
        }
        getMinorTickInterval() {
          let { minorTicks: p, minorTickInterval: W } = this.options;
          return p === !0 ? G(W, "auto") : p !== !1 ? W : void 0;
        }
        getMinorTickPositions() {
          let p = this.options, W = this.tickPositions, X = this.minorTickInterval, f = this.pointRangePadding || 0, L = (this.min || 0) - f, w = (this.max || 0) + f, H = w - L, U = [], ee;
          if (H && H / X < this.len / 3) {
            let ae = this.logarithmic;
            if (ae)
              this.paddedTicks.forEach(function(ne, he, me) {
                he && U.push.apply(U, ae.getLogTickPositions(X, me[he - 1], me[he], !0));
              });
            else if (this.dateTime && this.getMinorTickInterval() === "auto")
              U = U.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(X), L, w, p.startOfWeek));
            else
              for (ee = L + (W[0] - L) % X; ee <= w && ee !== U[0]; ee += X)
                U.push(ee);
          }
          return U.length !== 0 && this.trimTicks(U), U;
        }
        adjustForMinRange() {
          let p = this.options, W = this.logarithmic, { max: X, min: f, minRange: L } = this, w, H, U, ee;
          this.isXAxis && L === void 0 && !W && (L = u(p.min) || u(p.max) || u(p.floor) || u(p.ceiling) ? null : Math.min(5 * (h(this.series.map((ae) => {
            var ne;
            return (ae.xIncrement ? (ne = ae.xData) == null ? void 0 : ne.slice(0, 2) : ae.xData) || [];
          })) || 0), this.dataMax - this.dataMin)), a(X) && a(f) && a(L) && X - f < L && (H = this.dataMax - this.dataMin >= L, w = (L - X + f) / 2, U = [f - w, G(p.min, f - w)], H && (U[2] = W ? W.log2lin(this.dataMin) : this.dataMin), ee = [(f = g(U)) + L, G(p.max, f + L)], H && (ee[2] = W ? W.log2lin(this.dataMax) : this.dataMax), (X = C(ee)) - f < L && (U[0] = X - L, U[1] = G(p.min, X - L), f = g(U))), this.minRange = L, this.min = f, this.max = X;
        }
        getClosest() {
          let p, W;
          if (this.categories)
            W = 1;
          else {
            let X = [];
            this.series.forEach(function(f) {
              var w;
              let L = f.closestPointRange;
              ((w = f.xData) == null ? void 0 : w.length) === 1 ? X.push(f.xData[0]) : !f.noSharedTooltip && u(L) && f.reserveSpace() && (W = u(W) ? Math.min(W, L) : L);
            }), X.length && (X.sort((f, L) => f - L), p = h([X]));
          }
          return p && W ? Math.min(p, W) : p || W;
        }
        nameToX(p) {
          let W = o(this.options.categories), X = W ? this.categories : this.names, f = p.options.x, L;
          return p.series.requireSorting = !1, u(f) || (f = this.options.uniqueNames && X ? W ? X.indexOf(p.name) : G(X.keys[p.name], -1) : p.series.autoIncrement()), f === -1 ? !W && X && (L = X.length) : L = f, L !== void 0 ? (this.names[L] = p.name, this.names.keys[p.name] = L) : p.x && (L = p.x), L;
        }
        updateNames() {
          let p = this, W = this.names;
          W.length > 0 && (Object.keys(W.keys).forEach(function(X) {
            delete W.keys[X];
          }), W.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach((X) => {
            X.xIncrement = null, (!X.points || X.isDirtyData) && (p.max = Math.max(p.max, X.xData.length - 1), X.processData(), X.generatePoints()), X.data.forEach(function(f, L) {
              let w;
              f != null && f.options && f.name !== void 0 && (w = p.nameToX(f)) !== void 0 && w !== f.x && (f.x = w, X.xData[L] = w);
            });
          }));
        }
        setAxisTranslation() {
          let p = this, W = p.max - p.min, X = p.linkedParent, f = !!p.categories, L = p.isXAxis, w = p.axisPointRange || 0, H, U = 0, ee = 0, ae, ne = p.transA;
          (L || f || w) && (H = p.getClosest(), X ? (U = X.minPointOffset, ee = X.pointRangePadding) : p.series.forEach(function(he) {
            let me = f ? 1 : L ? G(he.options.pointRange, H, 0) : p.axisPointRange || 0, ve = he.options.pointPlacement;
            if (w = Math.max(w, me), !p.single || f) {
              let Me = he.is("xrange") ? !L : L;
              U = Math.max(U, Me && c(ve) ? 0 : me / 2), ee = Math.max(ee, Me && ve === "on" ? 0 : me);
            }
          }), ae = p.ordinal && p.ordinal.slope && H ? p.ordinal.slope / H : 1, p.minPointOffset = U *= ae, p.pointRangePadding = ee *= ae, p.pointRange = Math.min(w, p.single && f ? 1 : W), L && H && (p.closestPointRange = H)), p.translationSlope = p.transA = ne = p.staticScale || p.len / (W + ee || 1), p.transB = p.horiz ? p.left : p.bottom, p.minPixelPadding = ne * U, k(this, "afterSetAxisTranslation");
        }
        minFromRange() {
          let { max: p, min: W } = this;
          return a(p) && a(W) && p - W || void 0;
        }
        setTickInterval(p) {
          var We, Ne, Xe, et;
          let { categories: W, chart: X, dataMax: f, dataMin: L, dateTime: w, isXAxis: H, logarithmic: U, options: ee, softThreshold: ae } = this, ne = a(this.threshold) ? this.threshold : void 0, he = this.minRange || 0, { ceiling: me, floor: ve, linkedTo: Me, softMax: Z, softMin: V } = ee, re = a(Me) && ((We = X[this.coll]) == null ? void 0 : We[Me]), le = ee.tickPixelInterval, be = ee.maxPadding, de = ee.minPadding, ge = 0, fe, ke = a(ee.tickInterval) && ee.tickInterval >= 0 ? ee.tickInterval : void 0, Pe, Ae, Le, Ee;
          if (w || W || re || this.getTickAmount(), Le = G(this.userMin, ee.min), Ee = G(this.userMax, ee.max), re ? (this.linkedParent = re, fe = re.getExtremes(), this.min = G(fe.min, fe.dataMin), this.max = G(fe.max, fe.dataMax), ee.type !== re.options.type && I(11, !0, X)) : (ae && u(ne) && a(f) && a(L) && (L >= ne ? (Pe = ne, de = 0) : f <= ne && (Ae = ne, be = 0)), this.min = G(Le, Pe, L), this.max = G(Ee, Ae, f)), a(this.max) && a(this.min) && (U && (this.positiveValuesOnly && !p && 0 >= Math.min(this.min, G(L, this.min)) && I(10, !0, X), this.min = D(U.log2lin(this.min), 16), this.max = D(U.log2lin(this.max), 16)), this.range && a(L) && (this.userMin = this.min = Le = Math.max(L, this.minFromRange() || 0), this.userMax = Ee = this.max, this.range = void 0)), k(this, "foundExtremes"), this.adjustForMinRange(), a(this.min) && a(this.max)) {
            if (!a(this.userMin) && a(V) && V < this.min && (this.min = Le = V), !a(this.userMax) && a(Z) && Z > this.max && (this.max = Ee = Z), W || this.axisPointRange || (Ne = this.stacking) != null && Ne.usePercentage || re || !(ge = this.max - this.min) || (!u(Le) && de && (this.min -= ge * de), u(Ee) || !be || (this.max += ge * be)), !a(this.userMin) && a(ve) && (this.min = Math.max(this.min, ve)), !a(this.userMax) && a(me) && (this.max = Math.min(this.max, me)), ae && a(L) && a(f)) {
              let Ze = ne || 0;
              !u(Le) && this.min < Ze && L >= Ze ? this.min = ee.minRange ? Math.min(Ze, this.max - he) : Ze : !u(Ee) && this.max > Ze && f <= Ze && (this.max = ee.minRange ? Math.max(Ze, this.min + he) : Ze);
            }
            !X.polar && this.min > this.max && (u(ee.min) ? this.max = this.min : u(ee.max) && (this.min = this.max)), ge = this.max - this.min;
          }
          if (this.min !== this.max && a(this.min) && a(this.max) ? re && !ke && le === re.options.tickPixelInterval ? this.tickInterval = ke = re.tickInterval : this.tickInterval = G(ke, this.tickAmount ? ge / Math.max(this.tickAmount - 1, 1) : void 0, W ? 1 : ge * le / Math.max(this.len, le)) : this.tickInterval = 1, H && !p) {
            let Ze = this.min !== ((Xe = this.old) == null ? void 0 : Xe.min) || this.max !== ((et = this.old) == null ? void 0 : et.max);
            this.series.forEach(function(ut) {
              var it;
              ut.forceCrop = (it = ut.forceCropping) == null ? void 0 : it.call(ut), ut.processData(Ze);
            }), k(this, "postProcessData", { hasExtremesChanged: Ze });
          }
          this.setAxisTranslation(), k(this, "initialAxisTranslation"), this.pointRange && !ke && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
          let Ye = G(ee.minTickInterval, w && !this.series.some((Ze) => Ze.noSharedTooltip) ? this.closestPointRange : 0);
          !ke && this.tickInterval < Ye && (this.tickInterval = Ye), w || U || ke || (this.tickInterval = te(this, this.tickInterval)), this.tickAmount || (this.tickInterval = this.unsquish()), this.setTickPositions();
        }
        setTickPositions() {
          var ae, ne;
          let p = this.options, W = p.tickPositions, X = p.tickPositioner, f = this.getMinorTickInterval(), L = !this.isPanning, w = L && p.startOnTick, H = L && p.endOnTick, U = [], ee;
          if (this.tickmarkOffset = this.categories && p.tickmarkPlacement === "between" && this.tickInterval === 1 ? 0.5 : 0, this.minorTickInterval = f === "auto" && this.tickInterval ? this.tickInterval / p.minorTicksPerMajor : f, this.single = this.min === this.max && u(this.min) && !this.tickAmount && (this.min % 1 == 0 || p.allowDecimals !== !1), W)
            U = W.slice();
          else if (a(this.min) && a(this.max)) {
            if (!((ae = this.ordinal) != null && ae.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))
              U = [this.min, this.max], I(19, !1, this.chart);
            else if (this.dateTime)
              U = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, p.units), this.min, this.max, p.startOfWeek, (ne = this.ordinal) == null ? void 0 : ne.positions, this.closestPointRange, !0);
            else if (this.logarithmic)
              U = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
            else {
              let he = this.tickInterval, me = he;
              for (; me <= 2 * he && (U = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && U.length > this.tickAmount); )
                this.tickInterval = te(this, me *= 1.1);
            }
            U.length > this.len && (U = [U[0], U[U.length - 1]])[0] === U[1] && (U.length = 1), X && (this.tickPositions = U, (ee = X.apply(this, [this.min, this.max])) && (U = ee));
          }
          this.tickPositions = U, this.paddedTicks = U.slice(0), this.trimTicks(U, w, H), !this.isLinked && a(this.min) && a(this.max) && (this.single && U.length < 2 && !this.categories && !this.series.some((he) => he.is("heatmap") && he.options.pointPlacement === "between") && (this.min -= 0.5, this.max += 0.5), W || ee || this.adjustTickAmount()), k(this, "afterSetTickPositions");
        }
        trimTicks(p, W, X) {
          let f = p[0], L = p[p.length - 1], w = !this.isOrdinal && this.minPointOffset || 0;
          if (k(this, "trimTicks"), !this.isLinked) {
            if (W && f !== -1 / 0)
              this.min = f;
            else
              for (; this.min - w > p[0]; )
                p.shift();
            if (X)
              this.max = L;
            else
              for (; this.max + w < p[p.length - 1]; )
                p.pop();
            p.length === 0 && u(f) && !this.options.tickPositions && p.push((L + f) / 2);
          }
        }
        alignToOthers() {
          let p, W = this, X = W.chart, f = [this], L = W.options, w = X.options.chart, H = this.coll === "yAxis" && w.alignThresholds, U = [];
          if (W.thresholdAlignment = void 0, (w.alignTicks !== !1 && L.alignTicks || H) && L.startOnTick !== !1 && L.endOnTick !== !1 && !W.logarithmic) {
            let ee = (ne) => {
              let { horiz: he, options: me } = ne;
              return [he ? me.left : me.top, me.width, me.height, me.pane].join(",");
            }, ae = ee(this);
            X[this.coll].forEach(function(ne) {
              let { series: he } = ne;
              he.length && he.some((me) => me.visible) && ne !== W && ee(ne) === ae && (p = !0, f.push(ne));
            });
          }
          if (p && H) {
            f.forEach((ae) => {
              let ne = ae.getThresholdAlignment(W);
              a(ne) && U.push(ne);
            });
            let ee = U.length > 1 ? U.reduce((ae, ne) => ae += ne, 0) / U.length : void 0;
            f.forEach((ae) => {
              ae.thresholdAlignment = ee;
            });
          }
          return p;
        }
        getThresholdAlignment(p) {
          if ((!a(this.dataMin) || this !== p && this.series.some((W) => W.isDirty || W.isDirtyData)) && this.getSeriesExtremes(), a(this.threshold)) {
            let W = j((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);
            return this.options.reversed && (W = 1 - W), W;
          }
        }
        getTickAmount() {
          let p = this.options, W = p.tickPixelInterval, X = p.tickAmount;
          u(p.tickInterval) || X || !(this.len < W) || this.isRadial || this.logarithmic || !p.startOnTick || !p.endOnTick || (X = 2), !X && this.alignToOthers() && (X = Math.ceil(this.len / W) + 1), X < 4 && (this.finalTickAmt = X, X = 5), this.tickAmount = X;
        }
        adjustTickAmount() {
          let p = this, { finalTickAmt: W, max: X, min: f, options: L, tickPositions: w, tickAmount: H, thresholdAlignment: U } = p, ee = w == null ? void 0 : w.length, ae = G(p.threshold, p.softThreshold ? 0 : null), ne, he, me = p.tickInterval, ve, Me = () => w.push(D(w[w.length - 1] + me)), Z = () => w.unshift(D(w[0] - me));
          if (a(U) && (ve = U < 0.5 ? Math.ceil(U * (H - 1)) : Math.floor(U * (H - 1)), L.reversed && (ve = H - 1 - ve)), p.hasData() && a(f) && a(X)) {
            let V = () => {
              p.transA *= (ee - 1) / (H - 1), p.min = L.startOnTick ? w[0] : Math.min(f, w[0]), p.max = L.endOnTick ? w[w.length - 1] : Math.max(X, w[w.length - 1]);
            };
            if (a(ve) && a(p.threshold)) {
              for (; w[ve] !== ae || w.length !== H || w[0] > f || w[w.length - 1] < X; ) {
                for (w.length = 0, w.push(p.threshold); w.length < H; )
                  w[ve] === void 0 || w[ve] > p.threshold ? Z() : Me();
                if (me > 8 * p.tickInterval)
                  break;
                me *= 2;
              }
              V();
            } else if (ee < H) {
              for (; w.length < H; )
                w.length % 2 || f === ae ? Me() : Z();
              V();
            }
            if (u(W)) {
              for (he = ne = w.length; he--; )
                (W === 3 && he % 2 == 1 || W <= 2 && he > 0 && he < ne - 1) && w.splice(he, 1);
              p.finalTickAmt = void 0;
            }
          }
        }
        setScale() {
          var w, H;
          let { coll: p, stacking: W } = this, X = !1, f = !1;
          this.series.forEach((U) => {
            X = X || U.isDirtyData || U.isDirty, f = f || U.xAxis && U.xAxis.isDirty || !1;
          }), this.setAxisSize();
          let L = this.len !== (this.old && this.old.len);
          L || X || f || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (W && p === "yAxis" && W.buildStacks(), this.forceRedraw = !1, this.userMinRange || (this.minRange = void 0), this.getSeriesExtremes(), this.setTickInterval(), W && p === "xAxis" && W.buildStacks(), this.isDirty || (this.isDirty = L || this.min !== ((w = this.old) == null ? void 0 : w.min) || this.max !== ((H = this.old) == null ? void 0 : H.max))) : W && W.cleanStacks(), X && delete this.allExtremes, k(this, "afterSetScale");
        }
        setExtremes(p, W, X = !0, f, L) {
          this.series.forEach((w) => {
            delete w.kdTree;
          }), k(this, "setExtremes", L = z(L, { min: p, max: W }), (w) => {
            this.userMin = w.min, this.userMax = w.max, this.eventArgs = w, X && this.chart.redraw(f);
          });
        }
        setAxisSize() {
          let p = this.chart, W = this.options, X = W.offsets || [0, 0, 0, 0], f = this.horiz, L = this.width = Math.round(x(G(W.width, p.plotWidth - X[3] + X[1]), p.plotWidth)), w = this.height = Math.round(x(G(W.height, p.plotHeight - X[0] + X[2]), p.plotHeight)), H = this.top = Math.round(x(G(W.top, p.plotTop + X[0]), p.plotHeight, p.plotTop)), U = this.left = Math.round(x(G(W.left, p.plotLeft + X[3]), p.plotWidth, p.plotLeft));
          this.bottom = p.chartHeight - w - H, this.right = p.chartWidth - L - U, this.len = Math.max(f ? L : w, 0), this.pos = f ? U : H;
        }
        getExtremes() {
          let p = this.logarithmic;
          return { min: p ? D(p.lin2log(this.min)) : this.min, max: p ? D(p.lin2log(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax };
        }
        getThreshold(p) {
          let W = this.logarithmic, X = W ? W.lin2log(this.min) : this.min, f = W ? W.lin2log(this.max) : this.max;
          return p === null || p === -1 / 0 ? p = X : p === 1 / 0 ? p = f : X > p ? p = X : f < p && (p = f), this.translate(p, 0, 1, 0, 1);
        }
        autoLabelAlign(p) {
          let W = (G(p, 0) - 90 * this.side + 720) % 360, X = { align: "center" };
          return k(this, "autoLabelAlign", X, function(f) {
            W > 15 && W < 165 ? f.align = "right" : W > 195 && W < 345 && (f.align = "left");
          }), X.align;
        }
        tickSize(p) {
          let W = this.options, X = G(W[p === "tick" ? "tickWidth" : "minorTickWidth"], p === "tick" && this.isXAxis && !this.categories ? 1 : 0), f = W[p === "tick" ? "tickLength" : "minorTickLength"], L;
          X && f && (W[p + "Position"] === "inside" && (f = -f), L = [f, X]);
          let w = { tickSize: L };
          return k(this, "afterTickSize", w), w.tickSize;
        }
        labelMetrics() {
          let p = this.chart.renderer, W = this.ticks, X = W[Object.keys(W)[0]] || {};
          return this.chart.renderer.fontMetrics(X.label || X.movedLabel || p.box);
        }
        unsquish() {
          let p = this.options.labels, W = this.horiz, X = this.tickInterval, f = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / X), L = p.rotation, w = this.labelMetrics().h, H = Math.max(this.max - this.min, 0), U = function(me) {
            let ve = me / (f || 1);
            return (ve = ve > 1 ? Math.ceil(ve) : 1) * X > H && me !== 1 / 0 && f !== 1 / 0 && H && (ve = Math.ceil(H / X)), D(ve * X);
          }, ee = X, ae, ne = Number.MAX_VALUE, he;
          if (W) {
            if (!p.staggerLines && (a(L) ? he = [L] : f < p.autoRotationLimit && (he = p.autoRotation)), he) {
              let me, ve;
              for (let Me of he)
                (Me === L || Me && Me >= -90 && Me <= 90) && (ve = (me = U(Math.abs(w / Math.sin(M * Me)))) + Math.abs(Me / 360)) < ne && (ne = ve, ae = Me, ee = me);
            }
          } else
            ee = U(0.75 * w);
          return this.autoRotation = he, this.labelRotation = G(ae, a(L) ? L : 0), p.step ? X : ee;
        }
        getSlotWidth(p) {
          let W = this.chart, X = this.horiz, f = this.options.labels, L = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), w = W.margin[3];
          if (p && a(p.slotWidth))
            return p.slotWidth;
          if (X && f.step < 2)
            return f.rotation ? 0 : (this.staggerLines || 1) * this.len / L;
          if (!X) {
            let H = f.style.width;
            if (H !== void 0)
              return parseInt(String(H), 10);
            if (w)
              return w - W.spacing[3];
          }
          return 0.33 * W.chartWidth;
        }
        renderUnsquish() {
          let p = this.chart, W = p.renderer, X = this.tickPositions, f = this.ticks, L = this.options.labels, w = L.style, H = this.horiz, U = this.getSlotWidth(), ee = Math.max(1, Math.round(U - 2 * L.padding)), ae = {}, ne = this.labelMetrics(), he = w.textOverflow, me, ve, Me = 0, Z, V;
          if (c(L.rotation) || (ae.rotation = L.rotation || 0), X.forEach(function(re) {
            let le = f[re];
            le.movedLabel && le.replaceMovedLabel(), le && le.label && le.label.textPxLength > Me && (Me = le.label.textPxLength);
          }), this.maxLabelLength = Me, this.autoRotation)
            Me > ee && Me > ne.h ? ae.rotation = this.labelRotation : this.labelRotation = 0;
          else if (U && (me = ee, !he))
            for (ve = "clip", V = X.length; !H && V--; )
              (Z = f[X[V]].label) && (Z.styles.textOverflow === "ellipsis" ? Z.css({ textOverflow: "clip" }) : Z.textPxLength > U && Z.css({ width: U + "px" }), Z.getBBox().height > this.len / X.length - (ne.h - ne.f) && (Z.specificTextOverflow = "ellipsis"));
          ae.rotation && (me = Me > 0.5 * p.chartHeight ? 0.33 * p.chartHeight : Me, he || (ve = "ellipsis")), this.labelAlign = L.align || this.autoLabelAlign(this.labelRotation), this.labelAlign && (ae.align = this.labelAlign), X.forEach(function(re) {
            let le = f[re], be = le && le.label, de = w.width, ge = {};
            be && (be.attr(ae), le.shortenLabel ? le.shortenLabel() : me && !de && w.whiteSpace !== "nowrap" && (me < be.textPxLength || be.element.tagName === "SPAN") ? (ge.width = me + "px", he || (ge.textOverflow = be.specificTextOverflow || ve), be.css(ge)) : !be.styles.width || ge.width || de || be.css({ width: null }), delete be.specificTextOverflow, le.rotation = ae.rotation);
          }, this), this.tickRotCorr = W.rotCorr(ne.b, this.labelRotation || 0, this.side !== 0);
        }
        hasData() {
          return this.series.some(function(p) {
            return p.hasData();
          }) || this.options.showEmpty && u(this.min) && u(this.max);
        }
        addTitle(p) {
          let W, X = this.chart.renderer, f = this.horiz, L = this.opposite, w = this.options.title, H = this.chart.styledMode;
          this.axisTitle || ((W = w.textAlign) || (W = (f ? { low: "left", middle: "center", high: "right" } : { low: L ? "right" : "left", middle: "center", high: L ? "left" : "right" })[w.align]), this.axisTitle = X.text(w.text || "", 0, 0, w.useHTML).attr({ zIndex: 7, rotation: w.rotation || 0, align: W }).addClass("highcharts-axis-title"), H || this.axisTitle.css(d(w.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0), H || w.style.width || this.isRadial || this.axisTitle.css({ width: this.len + "px" }), this.axisTitle[p ? "show" : "hide"](p);
        }
        generateTick(p) {
          let W = this.ticks;
          W[p] ? W[p].addLabel() : W[p] = new q(this, p);
        }
        createGroups() {
          let { axisParent: p, chart: W, coll: X, options: f } = this, L = W.renderer, w = (H, U, ee) => L.g(H).attr({ zIndex: ee }).addClass(`highcharts-${X.toLowerCase()}${U} ` + (this.isRadial ? `highcharts-radial-axis${U} ` : "") + (f.className || "")).add(p);
          this.axisGroup || (this.gridGroup = w("grid", "-grid", f.gridZIndex), this.axisGroup = w("axis", "", f.zIndex), this.labelGroup = w("axis-labels", "-labels", f.labels.zIndex));
        }
        getOffset() {
          let p = this, { chart: W, horiz: X, options: f, side: L, ticks: w, tickPositions: H, coll: U } = p, ee = W.inverted && !p.isZAxis ? [1, 0, 3, 2][L] : L, ae = p.hasData(), ne = f.title, he = f.labels, me = a(f.crossing), ve = W.axisOffset, Me = W.clipOffset, Z = [-1, 1, 1, -1][L], V, re = 0, le, be = 0, de = 0, ge, fe;
          if (p.showAxis = V = ae || f.showEmpty, p.staggerLines = p.horiz && he.staggerLines || void 0, p.createGroups(), ae || p.isLinked ? (H.forEach(function(ke) {
            p.generateTick(ke);
          }), p.renderUnsquish(), p.reserveSpaceDefault = L === 0 || L === 2 || { 1: "left", 3: "right" }[L] === p.labelAlign, G(he.reserveSpace, !me && null, p.labelAlign === "center" || null, p.reserveSpaceDefault) && H.forEach(function(ke) {
            de = Math.max(w[ke].getLabelSize(), de);
          }), p.staggerLines && (de *= p.staggerLines), p.labelOffset = de * (p.opposite ? -1 : 1)) : P(w, function(ke, Pe) {
            ke.destroy(), delete w[Pe];
          }), ne != null && ne.text && ne.enabled !== !1 && (p.addTitle(V), V && !me && ne.reserveSpace !== !1 && (p.titleOffset = re = p.axisTitle.getBBox()[X ? "height" : "width"], be = u(le = ne.offset) ? 0 : G(ne.margin, X ? 5 : 10))), p.renderLine(), p.offset = Z * G(f.offset, ve[L] ? ve[L] + (f.margin || 0) : 0), p.tickRotCorr = p.tickRotCorr || { x: 0, y: 0 }, fe = L === 0 ? -p.labelMetrics().h : L === 2 ? p.tickRotCorr.y : 0, ge = Math.abs(de) + be, de && (ge -= fe, ge += Z * (X ? G(he.y, p.tickRotCorr.y + Z * he.distance) : G(he.x, Z * he.distance))), p.axisTitleMargin = G(le, ge), p.getMaxLabelDimensions && (p.maxLabelDimensions = p.getMaxLabelDimensions(w, H)), U !== "colorAxis") {
            let ke = this.tickSize("tick");
            ve[L] = Math.max(ve[L], (p.axisTitleMargin || 0) + re + Z * p.offset, ge, H && H.length && ke ? ke[0] + Z * p.offset : 0);
            let Pe = !p.axisLine || f.offset ? 0 : 2 * Math.floor(p.axisLine.strokeWidth() / 2);
            Me[ee] = Math.max(Me[ee], Pe);
          }
          k(this, "afterGetOffset");
        }
        getLinePath(p) {
          let W = this.chart, X = this.opposite, f = this.offset, L = this.horiz, w = this.left + (X ? this.width : 0) + f, H = W.chartHeight - this.bottom - (X ? this.height : 0) + f;
          return X && (p *= -1), W.renderer.crispLine([["M", L ? this.left : w, L ? H : this.top], ["L", L ? W.chartWidth - this.right : w, L ? H : W.chartHeight - this.bottom]], p);
        }
        renderLine() {
          this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({ stroke: this.options.lineColor, "stroke-width": this.options.lineWidth, zIndex: 7 }));
        }
        getTitlePosition(p) {
          let W = this.horiz, X = this.left, f = this.top, L = this.len, w = this.options.title, H = W ? X : f, U = this.opposite, ee = this.offset, ae = w.x, ne = w.y, he = this.chart.renderer.fontMetrics(p), me = p ? Math.max(p.getBBox(!1, 0).height - he.h - 1, 0) : 0, ve = { low: H + (W ? 0 : L), middle: H + L / 2, high: H + (W ? L : 0) }[w.align], Me = (W ? f + this.height : X) + (W ? 1 : -1) * (U ? -1 : 1) * (this.axisTitleMargin || 0) + [-me, me, he.f, -me][this.side], Z = { x: W ? ve + ae : Me + (U ? this.width : 0) + ee + ae, y: W ? Me + ne - (U ? this.height : 0) + ee : ve + ne };
          return k(this, "afterGetTitlePosition", { titlePosition: Z }), Z;
        }
        renderMinorTick(p, W) {
          let X = this.minorTicks;
          X[p] || (X[p] = new q(this, p, "minor")), W && X[p].isNew && X[p].render(null, !0), X[p].render(null, !1, 1);
        }
        renderTick(p, W, X) {
          let f = this.isLinked, L = this.ticks;
          (!f || p >= this.min && p <= this.max || this.grid && this.grid.isColumn) && (L[p] || (L[p] = new q(this, p)), X && L[p].isNew && L[p].render(W, !0, -1), L[p].render(W));
        }
        render() {
          let p, W, X = this, f = X.chart, L = X.logarithmic, w = f.renderer, H = X.options, U = X.isLinked, ee = X.tickPositions, ae = X.axisTitle, ne = X.ticks, he = X.minorTicks, me = X.alternateBands, ve = H.stackLabels, Me = H.alternateGridColor, Z = H.crossing, V = X.tickmarkOffset, re = X.axisLine, le = X.showAxis, be = B(w.globalAnimation);
          if (X.labelEdge.length = 0, X.overlap = !1, [ne, he, me].forEach(function(de) {
            P(de, function(ge) {
              ge.isActive = !1;
            });
          }), a(Z)) {
            let de = this.isXAxis ? f.yAxis[0] : f.xAxis[0], ge = [1, -1, -1, 1][this.side];
            if (de) {
              let fe = de.toPixels(Z, !0);
              X.horiz && (fe = de.len - fe), X.offset = ge * fe;
            }
          }
          if (X.hasData() || U) {
            let de = X.chart.hasRendered && X.old && a(X.old.min);
            X.minorTickInterval && !X.categories && X.getMinorTickPositions().forEach(function(ge) {
              X.renderMinorTick(ge, de);
            }), ee.length && (ee.forEach(function(ge, fe) {
              X.renderTick(ge, fe, de);
            }), V && (X.min === 0 || X.single) && (ne[-1] || (ne[-1] = new q(X, -1, null, !0)), ne[-1].render(-1))), Me && ee.forEach(function(ge, fe) {
              W = ee[fe + 1] !== void 0 ? ee[fe + 1] + V : X.max - V, fe % 2 == 0 && ge < X.max && W <= X.max + (f.polar ? -V : V) && (me[ge] || (me[ge] = new Y.PlotLineOrBand(X, {})), p = ge + V, me[ge].options = { from: L ? L.lin2log(p) : p, to: L ? L.lin2log(W) : W, color: Me, className: "highcharts-alternate-grid" }, me[ge].render(), me[ge].isActive = !0);
            }), X._addedPlotLB || (X._addedPlotLB = !0, (H.plotLines || []).concat(H.plotBands || []).forEach(function(ge) {
              X.addPlotBandOrLine(ge);
            }));
          }
          [ne, he, me].forEach(function(de) {
            let ge = [], fe = be.duration;
            P(de, function(ke, Pe) {
              ke.isActive || (ke.render(Pe, !1, 0), ke.isActive = !1, ge.push(Pe));
            }), ie(function() {
              let ke = ge.length;
              for (; ke--; )
                de[ge[ke]] && !de[ge[ke]].isActive && (de[ge[ke]].destroy(), delete de[ge[ke]]);
            }, de !== me && f.hasRendered && fe ? fe : 0);
          }), re && (re[re.isPlaced ? "animate" : "attr"]({ d: this.getLinePath(re.strokeWidth()) }), re.isPlaced = !0, re[le ? "show" : "hide"](le)), ae && le && (ae[ae.isNew ? "attr" : "animate"](X.getTitlePosition(ae)), ae.isNew = !1), ve && ve.enabled && X.stacking && X.stacking.renderStackTotals(), X.old = { len: X.len, max: X.max, min: X.min, transA: X.transA, userMax: X.userMax, userMin: X.userMin }, X.isDirty = !1, k(this, "afterRender");
        }
        redraw() {
          this.visible && (this.render(), this.plotLinesAndBands.forEach(function(p) {
            p.render();
          })), this.series.forEach(function(p) {
            p.isDirty = !0;
          });
        }
        getKeepProps() {
          return this.keepProps || $.keepProps;
        }
        destroy(p) {
          let W = this, X = W.plotLinesAndBands, f = this.eventOptions;
          if (k(this, "destroy", { keepEvents: p }), p || Q(W), [W.ticks, W.minorTicks, W.alternateBands].forEach(function(L) {
            R(L);
          }), X) {
            let L = X.length;
            for (; L--; )
              X[L].destroy();
          }
          for (let L in ["axisLine", "axisTitle", "axisGroup", "gridGroup", "labelGroup", "cross", "scrollbar"].forEach(function(w) {
            W[w] && (W[w] = W[w].destroy());
          }), W.plotLinesAndBandsGroups)
            W.plotLinesAndBandsGroups[L] = W.plotLinesAndBandsGroups[L].destroy();
          P(W, function(L, w) {
            W.getKeepProps().indexOf(w) === -1 && delete W[w];
          }), this.eventOptions = f;
        }
        drawCrosshair(p, W) {
          let X = this.crosshair, f = G(X && X.snap, !0), L = this.chart, w, H, U, ee = this.cross, ae;
          if (k(this, "drawCrosshair", { e: p, point: W }), p || (p = this.cross && this.cross.e), X && (u(W) || !f) !== !1) {
            if (f ? u(W) && (H = G(this.coll !== "colorAxis" ? W.crosshairPos : null, this.isXAxis ? W.plotX : this.len - W.plotY)) : H = p && (this.horiz ? p.chartX - this.pos : this.len - p.chartY + this.pos), u(H) && (ae = { value: W && (this.isXAxis ? W.x : G(W.stackY, W.y)), translatedValue: H }, L.polar && z(ae, { isCrosshair: !0, chartX: p && p.chartX, chartY: p && p.chartY, point: W }), w = this.getPlotLinePath(ae) || null), !u(w)) {
              this.hideCrosshair();
              return;
            }
            U = this.categories && !this.isRadial, ee || (this.cross = ee = L.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (U ? "category " : "thin ") + (X.className || "")).attr({ zIndex: G(X.zIndex, 2) }).add(), !L.styledMode && (ee.attr({ stroke: X.color || (U ? l.parse("#ccd3ff").setOpacity(0.25).get() : "#cccccc"), "stroke-width": G(X.width, 1) }).css({ "pointer-events": "none" }), X.dashStyle && ee.attr({ dashstyle: X.dashStyle }))), ee.show().attr({ d: w }), U && !X.width && ee.attr({ "stroke-width": this.transA }), this.cross.e = p;
          } else
            this.hideCrosshair();
          k(this, "afterDrawCrosshair", { e: p, point: W });
        }
        hideCrosshair() {
          this.cross && this.cross.hide(), k(this, "afterHideCrosshair");
        }
        update(p, W) {
          let X = this.chart;
          p = d(this.userOptions, p), this.destroy(!0), this.init(X, p), X.isDirtyBox = !0, G(W, !0) && X.redraw();
        }
        remove(p) {
          let W = this.chart, X = this.coll, f = this.series, L = f.length;
          for (; L--; )
            f[L] && f[L].remove(!1);
          K(W.axes, this), K(W[X] || [], this), W.orderItems(X), this.destroy(), W.isDirtyBox = !0, G(p, !0) && W.redraw();
        }
        setTitle(p, W) {
          this.update({ title: p }, W);
        }
        setCategories(p, W) {
          this.update({ categories: p }, W);
        }
      }
      return $.keepProps = ["coll", "extKey", "hcEvents", "names", "series", "userMax", "userMin"], $;
    }), i(e, "Core/Axis/DateTimeAxis.js", [e["Core/Utilities.js"]], function(n) {
      var s;
      let { addEvent: l, getMagnitude: m, normalizeTickInterval: A, timeUnits: Y } = n;
      return function(q) {
        function T() {
          return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
        }
        function B() {
          if (this.options.type !== "datetime") {
            this.dateTime = void 0;
            return;
          }
          this.dateTime || (this.dateTime = new O(this));
        }
        q.compose = function(b) {
          return b.keepProps.includes("dateTime") || (b.keepProps.push("dateTime"), b.prototype.getTimeTicks = T, l(b, "afterSetOptions", B)), b;
        };
        class O {
          constructor(v) {
            this.axis = v;
          }
          normalizeTimeTickInterval(v, E) {
            let M = E || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]], g = M[M.length - 1], C = Y[g[0]], j = g[1], D;
            for (D = 0; D < M.length && (C = Y[(g = M[D])[0]], j = g[1], !M[D + 1] || !(v <= (C * j[j.length - 1] + Y[M[D + 1][0]]) / 2)); D++)
              ;
            C === Y.year && v < 5 * C && (j = [1, 2, 5]);
            let u = A(v / C, j, g[0] === "year" ? Math.max(m(v / C), 1) : 1);
            return { unitRange: C, count: u, unitName: g[0] };
          }
          getXDateFormat(v, E) {
            let { axis: M } = this, g = M.chart.time;
            return M.closestPointRange ? g.getDateFormat(M.closestPointRange, v, M.options.startOfWeek, E) || g.resolveDTLFormat(E.year).main : g.resolveDTLFormat(E.day).main;
          }
        }
        q.Additions = O;
      }(s || (s = {})), s;
    }), i(e, "Core/Axis/LogarithmicAxis.js", [e["Core/Utilities.js"]], function(n) {
      var s;
      let { addEvent: l, normalizeTickInterval: m, pick: A } = n;
      return function(Y) {
        function q(O) {
          let b = O.userOptions, v = this.logarithmic;
          b.type !== "logarithmic" ? this.logarithmic = void 0 : v || (v = this.logarithmic = new B(this));
        }
        function T() {
          let O = this.logarithmic;
          O && (this.lin2val = function(b) {
            return O.lin2log(b);
          }, this.val2lin = function(b) {
            return O.log2lin(b);
          });
        }
        Y.compose = function(O) {
          return O.keepProps.includes("logarithmic") || (O.keepProps.push("logarithmic"), l(O, "init", q), l(O, "afterInit", T)), O;
        };
        class B {
          constructor(b) {
            this.axis = b;
          }
          getLogTickPositions(b, v, E, M) {
            let g = this.axis, C = g.len, j = g.options, D = [];
            if (M || (this.minorAutoInterval = void 0), b >= 0.5)
              b = Math.round(b), D = g.getLinearTickPositions(b, v, E);
            else if (b >= 0.08) {
              let u, R, K, I, z, k, h, F = Math.floor(v);
              for (u = b > 0.3 ? [1, 2, 4] : b > 0.15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], R = F; R < E + 1 && !h; R++)
                for (K = 0, I = u.length; K < I && !h; K++)
                  (z = this.log2lin(this.lin2log(R) * u[K])) > v && (!M || k <= E) && k !== void 0 && D.push(k), k > E && (h = !0), k = z;
            } else {
              let u = this.lin2log(v), R = this.lin2log(E), K = M ? g.getMinorTickInterval() : j.tickInterval, I = j.tickPixelInterval / (M ? 5 : 1), z = M ? C / g.tickPositions.length : C;
              b = m(b = A(K === "auto" ? null : K, this.minorAutoInterval, (R - u) * I / (z || 1))), D = g.getLinearTickPositions(b, u, R).map(this.log2lin), M || (this.minorAutoInterval = b / 5);
            }
            return M || (g.tickInterval = b), D;
          }
          lin2log(b) {
            return Math.pow(10, b);
          }
          log2lin(b) {
            return Math.log(b) / Math.LN10;
          }
        }
        Y.Additions = B;
      }(s || (s = {})), s;
    }), i(e, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [e["Core/Utilities.js"]], function(n) {
      var s;
      let { erase: l, extend: m, isNumber: A } = n;
      return function(Y) {
        let q;
        function T(g) {
          return this.addPlotBandOrLine(g, "plotBands");
        }
        function B(g, C) {
          let j = this.userOptions, D = new q(this, g);
          if (this.visible && (D = D.render()), D) {
            if (this._addedPlotLB || (this._addedPlotLB = !0, (j.plotLines || []).concat(j.plotBands || []).forEach((u) => {
              this.addPlotBandOrLine(u);
            })), C) {
              let u = j[C] || [];
              u.push(g), j[C] = u;
            }
            this.plotLinesAndBands.push(D);
          }
          return D;
        }
        function O(g) {
          return this.addPlotBandOrLine(g, "plotLines");
        }
        function b(g, C, j) {
          j = j || this.options;
          let D = this.getPlotLinePath({ value: C, force: !0, acrossPanes: j.acrossPanes }), u = [], R = this.horiz, K = !A(this.min) || !A(this.max) || g < this.min && C < this.min || g > this.max && C > this.max, I = this.getPlotLinePath({ value: g, force: !0, acrossPanes: j.acrossPanes }), z, k = 1, h;
          if (I && D)
            for (K && (h = I.toString() === D.toString(), k = 0), z = 0; z < I.length; z += 2) {
              let F = I[z], o = I[z + 1], a = D[z], c = D[z + 1];
              (F[0] === "M" || F[0] === "L") && (o[0] === "M" || o[0] === "L") && (a[0] === "M" || a[0] === "L") && (c[0] === "M" || c[0] === "L") && (R && a[1] === F[1] ? (a[1] += k, c[1] += k) : R || a[2] !== F[2] || (a[2] += k, c[2] += k), u.push(["M", F[1], F[2]], ["L", o[1], o[2]], ["L", c[1], c[2]], ["L", a[1], a[2]], ["Z"])), u.isFlat = h;
            }
          return u;
        }
        function v(g) {
          this.removePlotBandOrLine(g);
        }
        function E(g) {
          let C = this.plotLinesAndBands, j = this.options, D = this.userOptions;
          if (C) {
            let u = C.length;
            for (; u--; )
              C[u].id === g && C[u].destroy();
            [j.plotLines || [], D.plotLines || [], j.plotBands || [], D.plotBands || []].forEach(function(R) {
              for (u = R.length; u--; )
                (R[u] || {}).id === g && l(R, R[u]);
            });
          }
        }
        function M(g) {
          this.removePlotBandOrLine(g);
        }
        Y.compose = function(g, C) {
          let j = C.prototype;
          return j.addPlotBand || (q = g, m(j, { addPlotBand: T, addPlotLine: O, addPlotBandOrLine: B, getPlotBandPath: b, removePlotBand: v, removePlotLine: M, removePlotBandOrLine: E })), C;
        };
      }(s || (s = {})), s;
    }), i(e, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [e["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], e["Core/Utilities.js"]], function(n, s) {
      let { arrayMax: l, arrayMin: m, defined: A, destroyObjectProperties: Y, erase: q, fireEvent: T, merge: B, objectEach: O, pick: b } = s;
      class v {
        static compose(M) {
          return n.compose(v, M);
        }
        constructor(M, g) {
          this.axis = M, this.options = g, this.id = g.id;
        }
        render() {
          T(this, "render");
          let { axis: M, options: g } = this, { horiz: C, logarithmic: j } = M, { color: D, events: u, zIndex: R = 0 } = g, K = {}, I = M.chart.renderer, z = g.to, k = g.from, h = g.value, F = g.borderWidth, o = g.label, { label: a, svgElem: c } = this, d = [], S, P = A(k) && A(z), G = A(h), x = !c, Q = { class: "highcharts-plot-" + (P ? "band " : "line ") + (g.className || "") }, J = P ? "bands" : "lines";
          if (!M.chart.styledMode && (G ? (Q.stroke = D || "#999999", Q["stroke-width"] = b(g.width, 1), g.dashStyle && (Q.dashstyle = g.dashStyle)) : P && (Q.fill = D || "#e6e9ff", F && (Q.stroke = g.borderColor, Q["stroke-width"] = F))), K.zIndex = R, J += "-" + R, (S = M.plotLinesAndBandsGroups[J]) || (M.plotLinesAndBandsGroups[J] = S = I.g("plot-" + J).attr(K).add()), c || (this.svgElem = c = I.path().attr(Q).add(S)), A(h))
            d = M.getPlotLinePath({ value: (j == null ? void 0 : j.log2lin(h)) ?? h, lineWidth: c.strokeWidth(), acrossPanes: g.acrossPanes });
          else {
            if (!(A(k) && A(z)))
              return;
            d = M.getPlotBandPath((j == null ? void 0 : j.log2lin(k)) ?? k, (j == null ? void 0 : j.log2lin(z)) ?? z, g);
          }
          return !this.eventsAdded && u && (O(u, (ie, te) => {
            c == null || c.on(te, ($) => {
              u[te].apply(this, [$]);
            });
          }), this.eventsAdded = !0), (x || !c.d) && (d != null && d.length) ? c.attr({ d }) : c && (d ? (c.show(), c.animate({ d })) : c.d && (c.hide(), a && (this.label = a = a.destroy()))), o && (A(o.text) || A(o.formatter)) && (d != null && d.length) && M.width > 0 && M.height > 0 && !d.isFlat ? (o = B({ align: C && P ? "center" : void 0, x: C ? !P && 4 : 10, verticalAlign: !C && P ? "middle" : void 0, y: C ? P ? 16 : 10 : P ? 6 : -4, rotation: C && !P ? 90 : 0 }, o), this.renderLabel(o, d, P, R)) : a && a.hide(), this;
        }
        renderLabel(M, g, C, j) {
          let D = this.axis, u = D.chart.renderer, R = this.label;
          R || (this.label = R = u.text(this.getLabelText(M), 0, 0, M.useHTML).attr({ align: M.textAlign || M.align, rotation: M.rotation, class: "highcharts-plot-" + (C ? "band" : "line") + "-label " + (M.className || ""), zIndex: j }), D.chart.styledMode || R.css(B({ fontSize: "0.8em", textOverflow: "ellipsis" }, M.style)), R.add());
          let K = g.xBounds || [g[0][1], g[1][1], C ? g[2][1] : g[0][1]], I = g.yBounds || [g[0][2], g[1][2], C ? g[2][2] : g[0][2]], z = m(K), k = m(I);
          if (R.align(M, !1, { x: z, y: k, width: l(K) - z, height: l(I) - k }), !R.alignValue || R.alignValue === "left") {
            let h = M.clip ? D.width : D.chart.chartWidth;
            R.css({ width: (R.rotation === 90 ? D.height - (R.alignAttr.y - D.top) : h - (R.alignAttr.x - D.left)) + "px" });
          }
          R.show(!0);
        }
        getLabelText(M) {
          return A(M.formatter) ? M.formatter.call(this) : M.text;
        }
        destroy() {
          q(this.axis.plotLinesAndBands, this), delete this.axis, Y(this);
        }
      }
      return v;
    }), i(e, "Core/Tooltip.js", [e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Utilities.js"]], function(n, s, l, m, A) {
      var Y;
      let { format: q } = n, { composed: T, doc: B, isSafari: O } = s, { distribute: b } = l, { addEvent: v, clamp: E, css: M, discardElement: g, extend: C, fireEvent: j, isArray: D, isNumber: u, isString: R, merge: K, pick: I, pushUnique: z, splat: k, syncTimeout: h } = A;
      class F {
        constructor(a, c, d) {
          this.allowShared = !0, this.crosshairs = [], this.distance = 0, this.isHidden = !0, this.isSticky = !1, this.now = {}, this.options = {}, this.outside = !1, this.chart = a, this.init(a, c), this.pointer = d;
        }
        bodyFormatter(a) {
          return a.map(function(c) {
            let d = c.series.tooltipOptions;
            return (d[(c.point.formatPrefix || "point") + "Formatter"] || c.point.tooltipFormatter).call(c.point, d[(c.point.formatPrefix || "point") + "Format"] || "");
          });
        }
        cleanSplit(a) {
          this.chart.series.forEach(function(c) {
            let d = c && c.tt;
            d && (!d.isActive || a ? c.tt = d.destroy() : d.isActive = !1);
          });
        }
        defaultFormatter(a) {
          let c, d = this.points || k(this);
          return (c = (c = [a.tooltipFooterHeaderFormatter(d[0])]).concat(a.bodyFormatter(d))).push(a.tooltipFooterHeaderFormatter(d[0], !0)), c;
        }
        destroy() {
          this.label && (this.label = this.label.destroy()), this.split && (this.cleanSplit(!0), this.tt && (this.tt = this.tt.destroy())), this.renderer && (this.renderer = this.renderer.destroy(), g(this.container)), A.clearTimeout(this.hideTimer), A.clearTimeout(this.tooltipTimeout);
        }
        getAnchor(a, c) {
          let d, { chart: S, pointer: P } = this, G = S.inverted, x = S.plotTop, Q = S.plotLeft;
          if ((a = k(a))[0].series && a[0].series.yAxis && !a[0].series.yAxis.options.reversedStacks && (a = a.slice().reverse()), this.followPointer && c)
            c.chartX === void 0 && (c = P.normalize(c)), d = [c.chartX - Q, c.chartY - x];
          else if (a[0].tooltipPos)
            d = a[0].tooltipPos;
          else {
            let J = 0, ie = 0;
            a.forEach(function(te) {
              let $ = te.pos(!0);
              $ && (J += $[0], ie += $[1]);
            }), J /= a.length, ie /= a.length, this.shared && a.length > 1 && c && (G ? J = c.chartX : ie = c.chartY), d = [J - Q, ie - x];
          }
          return d.map(Math.round);
        }
        getClassName(a, c, d) {
          let S = this.options, P = a.series, G = P.options;
          return [S.className, "highcharts-label", d && "highcharts-tooltip-header", c ? "highcharts-tooltip-box" : "highcharts-tooltip", !d && "highcharts-color-" + I(a.colorIndex, P.colorIndex), G && G.className].filter(R).join(" ");
        }
        getLabel() {
          let a = this, c = this.chart.styledMode, d = this.options, S = this.split && this.allowShared, P = this.container, G = this.chart.renderer;
          if (this.label) {
            let x = !this.label.hasClass("highcharts-label");
            (!S && x || S && !x) && this.destroy();
          }
          if (!this.label) {
            if (this.outside) {
              let x = this.chart.options.chart.style, Q = m.getRendererType();
              this.container = P = s.doc.createElement("div"), P.className = "highcharts-tooltip-container", M(P, { position: "absolute", top: "1px", pointerEvents: "none", zIndex: Math.max(this.options.style.zIndex || 0, (x && x.zIndex || 0) + 3) }), this.renderer = G = new Q(P, 0, 0, x, void 0, void 0, G.styledMode);
            }
            if (S ? this.label = G.g("tooltip") : (this.label = G.label("", 0, 0, d.shape, void 0, void 0, d.useHTML, void 0, "tooltip").attr({ padding: d.padding, r: d.borderRadius }), c || this.label.attr({ fill: d.backgroundColor, "stroke-width": d.borderWidth || 0 }).css(d.style).css({ pointerEvents: d.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none") })), a.outside) {
              let x = this.label, { xSetter: Q, ySetter: J } = x;
              x.xSetter = function(ie) {
                Q.call(x, a.distance), P && (P.style.left = ie + "px");
              }, x.ySetter = function(ie) {
                J.call(x, a.distance), P && (P.style.top = ie + "px");
              };
            }
            this.label.attr({ zIndex: 8 }).shadow(d.shadow).add();
          }
          return P && !P.parentElement && s.doc.body.appendChild(P), this.label;
        }
        getPlayingField() {
          let { body: a, documentElement: c } = B, { chart: d, distance: S, outside: P } = this;
          return { width: P ? Math.max(a.scrollWidth, c.scrollWidth, a.offsetWidth, c.offsetWidth, c.clientWidth) - 2 * S : d.chartWidth, height: P ? Math.max(a.scrollHeight, c.scrollHeight, a.offsetHeight, c.offsetHeight, c.clientHeight) : d.chartHeight };
        }
        getPosition(a, c, d) {
          var re, le;
          let { distance: S, chart: P, outside: G, pointer: x } = this, { inverted: Q, plotLeft: J, plotTop: ie, polar: te } = P, { plotX: $ = 0, plotY: oe = 0 } = d, p = {}, W = Q && d.h || 0, { height: X, width: f } = this.getPlayingField(), L = x.getChartPosition(), w = (be) => be * L.scaleX, H = (be) => be * L.scaleY, U = (be) => {
            let de = be === "x";
            return [be, de ? f : X, de ? a : c].concat(G ? [de ? w(a) : H(c), de ? L.left - S + w($ + J) : L.top - S + H(oe + ie), 0, de ? f : X] : [de ? a : c, de ? $ + J : oe + ie, de ? J : ie, de ? J + P.plotWidth : ie + P.plotHeight]);
          }, ee = U("y"), ae = U("x"), ne, he = !!d.negative;
          !te && ((le = (re = P.hoverSeries) == null ? void 0 : re.yAxis) != null && le.reversed) && (he = !he);
          let me = !this.followPointer && I(d.ttBelow, !te && !Q === he), ve = function(be, de, ge, fe, ke, Pe, Ae) {
            let Le = G ? be === "y" ? H(S) : w(S) : S, Ee = (ge - fe) / 2, Ye = fe < ke - S, We = ke + S + fe < de, Ne = ke - Le - ge + Ee, Xe = ke + Le - Ee;
            if (me && We)
              p[be] = Xe;
            else if (!me && Ye)
              p[be] = Ne;
            else if (Ye)
              p[be] = Math.min(Ae - fe, Ne - W < 0 ? Ne : Ne - W);
            else {
              if (!We)
                return !1;
              p[be] = Math.max(Pe, Xe + W + ge > de ? Xe : Xe + W);
            }
          }, Me = function(be, de, ge, fe, ke) {
            if (ke < S || ke > de - S)
              return !1;
            ke < ge / 2 ? p[be] = 1 : ke > de - fe / 2 ? p[be] = de - fe - 2 : p[be] = ke - ge / 2;
          }, Z = function(be) {
            [ee, ae] = [ae, ee], ne = be;
          }, V = () => {
            ve.apply(0, ee) !== !1 ? Me.apply(0, ae) !== !1 || ne || (Z(!0), V()) : ne ? p.x = p.y = 0 : (Z(!0), V());
          };
          return (Q && !te || this.len > 1) && Z(), V(), p;
        }
        hide(a) {
          let c = this;
          A.clearTimeout(this.hideTimer), a = I(a, this.options.hideDelay), this.isHidden || (this.hideTimer = h(function() {
            let d = c.getLabel();
            c.getLabel().animate({ opacity: 0 }, { duration: a && 150, complete: () => {
              d.hide(), c.container && c.container.remove();
            } }), c.isHidden = !0;
          }, a));
        }
        init(a, c) {
          this.chart = a, this.options = c, this.crosshairs = [], this.now = { x: 0, y: 0 }, this.isHidden = !0, this.split = c.split && !a.inverted && !a.polar, this.shared = c.shared || this.split, this.outside = I(c.outside, !!(a.scrollablePixelsX || a.scrollablePixelsY));
        }
        shouldStickOnContact(a) {
          return !!(!this.followPointer && this.options.stickOnContact && (!a || this.pointer.inClass(a.target, "highcharts-tooltip")));
        }
        move(a, c, d, S) {
          let P = this, G = P.now, x = P.options.animation !== !1 && !P.isHidden && (Math.abs(a - G.x) > 1 || Math.abs(c - G.y) > 1), Q = P.followPointer || P.len > 1;
          C(G, { x: x ? (2 * G.x + a) / 3 : a, y: x ? (G.y + c) / 2 : c, anchorX: Q ? void 0 : x ? (2 * G.anchorX + d) / 3 : d, anchorY: Q ? void 0 : x ? (G.anchorY + S) / 2 : S }), P.getLabel().attr(G), P.drawTracker(), x && (A.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
            P && P.move(a, c, d, S);
          }, 32));
        }
        refresh(a, c) {
          let { chart: d, options: S, pointer: P, shared: G } = this, x = k(a), Q = x[0], J = [], ie = S.format, te = S.formatter || this.defaultFormatter, $ = d.styledMode, oe = {};
          if (!S.enabled || !Q.series)
            return;
          A.clearTimeout(this.hideTimer), this.allowShared = !(!D(a) && a.series && a.series.noSharedTooltip), this.followPointer = !this.split && Q.series.tooltipOptions.followPointer;
          let p = this.getAnchor(a, c), W = p[0], X = p[1];
          G && this.allowShared ? (P.applyInactiveState(x), x.forEach(function(w) {
            w.setState("hover"), J.push(w.getLabelConfig());
          }), (oe = Q.getLabelConfig()).points = J) : oe = Q.getLabelConfig(), this.len = J.length;
          let f = R(ie) ? q(ie, oe, d) : te.call(oe, this), L = Q.series;
          if (this.distance = I(L.tooltipOptions.distance, 16), f === !1)
            this.hide();
          else {
            if (this.split && this.allowShared)
              this.renderSplit(f, x);
            else {
              let w = W, H = X;
              if (c && P.isDirectTouch && (w = c.chartX - d.plotLeft, H = c.chartY - d.plotTop), d.polar || L.options.clip === !1 || x.some((U) => P.isDirectTouch || U.series.shouldShowTooltip(w, H))) {
                let U = this.getLabel();
                (!S.style.width || $) && U.css({ width: (this.outside ? this.getPlayingField() : d.spacingBox).width + "px" }), U.attr({ text: f && f.join ? f.join("") : f }), U.addClass(this.getClassName(Q), !0), $ || U.attr({ stroke: S.borderColor || Q.color || L.color || "#666666" }), this.updatePosition({ plotX: W, plotY: X, negative: Q.negative, ttBelow: Q.ttBelow, h: p[2] || 0 });
              } else {
                this.hide();
                return;
              }
            }
            this.isHidden && this.label && this.label.attr({ opacity: 1 }).show(), this.isHidden = !1;
          }
          j(this, "refresh");
        }
        renderSplit(a, c) {
          var de;
          let d = this, { chart: S, chart: { chartWidth: P, chartHeight: G, plotHeight: x, plotLeft: Q, plotTop: J, scrollablePixelsY: ie = 0, scrollablePixelsX: te, styledMode: $ }, distance: oe, options: p, options: { positioner: W }, pointer: X } = d, { scrollLeft: f = 0, scrollTop: L = 0 } = ((de = S.scrollablePlotArea) == null ? void 0 : de.scrollingContainer) || {}, w = d.outside && typeof te != "number" ? B.documentElement.getBoundingClientRect() : { left: f, right: f + P, top: L, bottom: L + G }, H = d.getLabel(), U = this.renderer || S.renderer, ee = !!(S.xAxis[0] && S.xAxis[0].opposite), { left: ae, top: ne } = X.getChartPosition(), he = J + L, me = 0, ve = x - ie;
          function Me(ge, fe, ke, Pe, Ae = !0) {
            let Le, Ee;
            return ke ? (Le = ee ? 0 : ve, Ee = E(ge - Pe / 2, w.left, w.right - Pe - (d.outside ? ae : 0))) : (Le = fe - he, Ee = E(Ee = Ae ? ge - Pe - oe : ge + oe, Ae ? Ee : w.left, w.right)), { x: Ee, y: Le };
          }
          R(a) && (a = [!1, a]);
          let Z = a.slice(0, c.length + 1).reduce(function(ge, fe, ke) {
            if (fe !== !1 && fe !== "") {
              let Pe = c[ke - 1] || { isHeader: !0, plotX: c[0].plotX, plotY: x, series: {} }, Ae = Pe.isHeader, Le = Ae ? d : Pe.series, Ee = Le.tt = function(et, Ze, ut) {
                let it = et, { isHeader: kt, series: ze } = Ze;
                if (!it) {
                  let nt = { padding: p.padding, r: p.borderRadius };
                  $ || (nt.fill = p.backgroundColor, nt["stroke-width"] = p.borderWidth ?? 1), it = U.label("", 0, 0, p[kt ? "headerShape" : "shape"], void 0, void 0, p.useHTML).addClass(d.getClassName(Ze, !0, kt)).attr(nt).add(H);
                }
                return it.isActive = !0, it.attr({ text: ut }), $ || it.css(p.style).attr({ stroke: p.borderColor || Ze.color || ze.color || "#333333" }), it;
              }(Le.tt, Pe, fe.toString()), Ye = Ee.getBBox(), We = Ye.width + Ee.strokeWidth();
              Ae && (me = Ye.height, ve += me, ee && (he -= me));
              let { anchorX: Ne, anchorY: Xe } = function(et) {
                let Ze, ut, { isHeader: it, plotX: kt = 0, plotY: ze = 0, series: nt } = et;
                if (it)
                  Ze = Math.max(Q + kt, Q), ut = J + x / 2;
                else {
                  let { xAxis: jt, yAxis: Vt } = nt;
                  Ze = jt.pos + E(kt, -oe, jt.len + oe), nt.shouldShowTooltip(0, Vt.pos - J + ze, { ignoreX: !0 }) && (ut = Vt.pos + ze);
                }
                return { anchorX: Ze = E(Ze, w.left - oe, w.right + oe), anchorY: ut };
              }(Pe);
              if (typeof Xe == "number") {
                let et = Ye.height + 1, Ze = W ? W.call(d, We, et, Pe) : Me(Ne, Xe, Ae, We);
                ge.push({ align: W ? 0 : void 0, anchorX: Ne, anchorY: Xe, boxWidth: We, point: Pe, rank: I(Ze.rank, Ae ? 1 : 0), size: et, target: Ze.y, tt: Ee, x: Ze.x });
              } else
                Ee.isActive = !1;
            }
            return ge;
          }, []);
          !W && Z.some((ge) => {
            let { outside: fe } = d, ke = (fe ? ae : 0) + ge.anchorX;
            return ke < w.left && ke + ge.boxWidth < w.right || ke < ae - w.left + ge.boxWidth && w.right - ke > ke;
          }) && (Z = Z.map((ge) => {
            let { x: fe, y: ke } = Me(ge.anchorX, ge.anchorY, ge.point.isHeader, ge.boxWidth, !1);
            return C(ge, { target: ke, x: fe });
          })), d.cleanSplit(), b(Z, ve);
          let V = { left: ae, right: ae };
          Z.forEach(function(ge) {
            let { x: fe, boxWidth: ke, isHeader: Pe } = ge;
            !Pe && (d.outside && ae + fe < V.left && (V.left = ae + fe), !Pe && d.outside && V.left + ke > V.right && (V.right = ae + fe));
          }), Z.forEach(function(ge) {
            let { x: fe, anchorX: ke, anchorY: Pe, pos: Ae, point: { isHeader: Le } } = ge, Ee = { visibility: Ae === void 0 ? "hidden" : "inherit", x: fe, y: (Ae || 0) + he, anchorX: ke, anchorY: Pe };
            if (d.outside && fe < ke) {
              let Ye = ae - V.left;
              Ye > 0 && (Le || (Ee.x = fe + Ye, Ee.anchorX = ke + Ye), Le && (Ee.x = (V.right - V.left) / 2, Ee.anchorX = ke + Ye));
            }
            ge.tt.attr(Ee);
          });
          let { container: re, outside: le, renderer: be } = d;
          if (le && re && be) {
            let { width: ge, height: fe, x: ke, y: Pe } = H.getBBox();
            be.setSize(ge + ke, fe + Pe, !1), re.style.left = V.left + "px", re.style.top = ne + "px";
          }
          O && H.attr({ opacity: H.opacity === 1 ? 0.999 : 1 });
        }
        drawTracker() {
          if (!this.shouldStickOnContact()) {
            this.tracker && (this.tracker = this.tracker.destroy());
            return;
          }
          let a = this.chart, c = this.label, d = this.shared ? a.hoverPoints : a.hoverPoint;
          if (!c || !d)
            return;
          let S = { x: 0, y: 0, width: 0, height: 0 }, P = this.getAnchor(d), G = c.getBBox();
          P[0] += a.plotLeft - (c.translateX || 0), P[1] += a.plotTop - (c.translateY || 0), S.x = Math.min(0, P[0]), S.y = Math.min(0, P[1]), S.width = P[0] < 0 ? Math.max(Math.abs(P[0]), G.width - P[0]) : Math.max(Math.abs(P[0]), G.width), S.height = P[1] < 0 ? Math.max(Math.abs(P[1]), G.height - Math.abs(P[1])) : Math.max(Math.abs(P[1]), G.height), this.tracker ? this.tracker.attr(S) : (this.tracker = c.renderer.rect(S).addClass("highcharts-tracker").add(c), a.styledMode || this.tracker.attr({ fill: "rgba(0,0,0,0)" }));
        }
        styledModeFormat(a) {
          return a.replace('style="font-size: 0.8em"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
        }
        tooltipFooterHeaderFormatter(a, c) {
          let d = a.series, S = d.tooltipOptions, P = d.xAxis, G = P && P.dateTime, x = { isFooter: c, labelConfig: a }, Q = S.xDateFormat, J = S[c ? "footerFormat" : "headerFormat"];
          return j(this, "headerFormatter", x, function(ie) {
            G && !Q && u(a.key) && (Q = G.getXDateFormat(a.key, S.dateTimeLabelFormats)), G && Q && (a.point && a.point.tooltipDateKeys || ["key"]).forEach(function(te) {
              J = J.replace("{point." + te + "}", "{point." + te + ":" + Q + "}");
            }), d.chart.styledMode && (J = this.styledModeFormat(J)), ie.text = q(J, { point: a, series: d }, this.chart);
          }), x.text;
        }
        update(a) {
          this.destroy(), this.init(this.chart, K(!0, this.options, a));
        }
        updatePosition(a) {
          let { chart: c, container: d, distance: S, options: P, pointer: G, renderer: x } = this, { height: Q = 0, width: J = 0 } = this.getLabel(), { left: ie, top: te, scaleX: $, scaleY: oe } = G.getChartPosition(), p = (P.positioner || this.getPosition).call(this, J, Q, a), W = (a.plotX || 0) + c.plotLeft, X = (a.plotY || 0) + c.plotTop, f;
          x && d && (P.positioner && (p.x += ie - S, p.y += te - S), f = (P.borderWidth || 0) + 2 * S + 2, x.setSize(J + f, Q + f, !1), ($ !== 1 || oe !== 1) && (M(d, { transform: `scale(${$}, ${oe})` }), W *= $, X *= oe), W += ie - p.x, X += te - p.y), this.move(Math.round(p.x), Math.round(p.y || 0), W, X);
        }
      }
      return (Y = F || (F = {})).compose = function(o) {
        z(T, "Core.Tooltip") && v(o, "afterInit", function() {
          let a = this.chart;
          a.options.tooltip && (a.tooltip = new Y(a, a.options.tooltip, this));
        });
      }, F;
    }), i(e, "Core/Series/Point.js", [e["Core/Renderer/HTML/AST.js"], e["Core/Animation/AnimationUtilities.js"], e["Core/Defaults.js"], e["Core/Templating.js"], e["Core/Utilities.js"]], function(n, s, l, m, A) {
      let { animObject: Y } = s, { defaultOptions: q } = l, { format: T } = m, { addEvent: B, erase: O, extend: b, fireEvent: v, getNestedProperty: E, isArray: M, isFunction: g, isNumber: C, isObject: j, merge: D, pick: u, syncTimeout: R, removeEvent: K, uniqueKey: I } = A;
      class z {
        animateBeforeDestroy() {
          let h = this, F = { x: h.startXPos, opacity: 0 }, o = h.getGraphicalProps();
          o.singular.forEach(function(a) {
            h[a] = h[a].animate(a === "dataLabel" ? { x: h[a].startXPos, y: h[a].startYPos, opacity: 0 } : F);
          }), o.plural.forEach(function(a) {
            h[a].forEach(function(c) {
              c.element && c.animate(b({ x: h.startXPos }, c.startYPos ? { x: c.startXPos, y: c.startYPos } : {}));
            });
          });
        }
        applyOptions(h, F) {
          let o = this.series, a = o.options.pointValKey || o.pointValKey;
          return b(this, h = z.prototype.optionsToObject.call(this, h)), this.options = this.options ? b(this.options, h) : h, h.group && delete this.group, h.dataLabels && delete this.dataLabels, a && (this.y = z.prototype.getNestedProperty.call(this, a)), this.selected && (this.state = "select"), "name" in this && F === void 0 && o.xAxis && o.xAxis.hasNames && (this.x = o.xAxis.nameToX(this)), this.x === void 0 && o ? F === void 0 ? this.x = o.autoIncrement() : this.x = F : C(h.x) && o.options.relativeXValue && (this.x = o.autoIncrement(h.x)), this.isNull = this.isValid && !this.isValid(), this.formatPrefix = this.isNull ? "null" : "point", this;
        }
        destroy() {
          if (!this.destroyed) {
            let h = this, F = h.series, o = F.chart, a = F.options.dataSorting, c = o.hoverPoints, d = Y(h.series.chart.renderer.globalAnimation), S = () => {
              for (let P in (h.graphic || h.graphics || h.dataLabel || h.dataLabels) && (K(h), h.destroyElements()), h)
                delete h[P];
            };
            h.legendItem && o.legend.destroyItem(h), c && (h.setState(), O(c, h), c.length || (o.hoverPoints = null)), h === o.hoverPoint && h.onMouseOut(), a && a.enabled ? (this.animateBeforeDestroy(), R(S, d.duration)) : S(), o.pointCount--;
          }
          this.destroyed = !0;
        }
        destroyElements(h) {
          let F = this, o = F.getGraphicalProps(h);
          o.singular.forEach(function(a) {
            F[a] = F[a].destroy();
          }), o.plural.forEach(function(a) {
            F[a].forEach(function(c) {
              c && c.element && c.destroy();
            }), delete F[a];
          });
        }
        firePointEvent(h, F, o) {
          let a = this, c = this.series.options;
          a.manageEvent(h), h === "click" && c.allowPointSelect && (o = function(d) {
            !a.destroyed && a.select && a.select(null, d.ctrlKey || d.metaKey || d.shiftKey);
          }), v(a, h, F, o);
        }
        getClassName() {
          return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (this.colorIndex !== void 0 ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
        }
        getGraphicalProps(h) {
          let F, o, a = this, c = [], d = { singular: [], plural: [] };
          for ((h = h || { graphic: 1, dataLabel: 1 }).graphic && c.push("graphic", "connector"), h.dataLabel && c.push("dataLabel", "dataLabelPath", "dataLabelUpper"), o = c.length; o--; )
            a[F = c[o]] && d.singular.push(F);
          return ["graphic", "dataLabel"].forEach(function(S) {
            let P = S + "s";
            h[S] && a[P] && d.plural.push(P);
          }), d;
        }
        getLabelConfig() {
          return { x: this.category, y: this.y, color: this.color, colorIndex: this.colorIndex, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal };
        }
        getNestedProperty(h) {
          return h ? h.indexOf("custom.") === 0 ? E(h, this.options) : this[h] : void 0;
        }
        getZone() {
          let h = this.series, F = h.zones, o = h.zoneAxis || "y", a, c = 0;
          for (a = F[0]; this[o] >= a.value; )
            a = F[++c];
          return this.nonZonedColor || (this.nonZonedColor = this.color), a && a.color && !this.options.color ? this.color = a.color : this.color = this.nonZonedColor, a;
        }
        hasNewShapeType() {
          return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
        }
        constructor(h, F, o) {
          this.formatPrefix = "point", this.visible = !0, this.series = h, this.applyOptions(F, o), this.id ?? (this.id = I()), this.resolveColor(), h.chart.pointCount++, v(this, "afterInit");
        }
        isValid() {
          return (C(this.x) || this.x instanceof Date) && C(this.y);
        }
        optionsToObject(h) {
          let F = this.series, o = F.options.keys, a = o || F.pointArrayMap || ["y"], c = a.length, d = {}, S, P = 0, G = 0;
          if (C(h) || h === null)
            d[a[0]] = h;
          else if (M(h))
            for (!o && h.length > c && ((S = typeof h[0]) == "string" ? d.name = h[0] : S === "number" && (d.x = h[0]), P++); G < c; )
              o && h[P] === void 0 || (a[G].indexOf(".") > 0 ? z.prototype.setNestedProperty(d, h[P], a[G]) : d[a[G]] = h[P]), P++, G++;
          else
            typeof h == "object" && (d = h, h.dataLabels && (F.hasDataLabels = () => !0), h.marker && (F._hasPointMarkers = !0));
          return d;
        }
        pos(h, F = this.plotY) {
          if (!this.destroyed) {
            let { plotX: o, series: a } = this, { chart: c, xAxis: d, yAxis: S } = a, P = 0, G = 0;
            if (C(o) && C(F))
              return h && (P = d ? d.pos : c.plotLeft, G = S ? S.pos : c.plotTop), c.inverted && d && S ? [S.len - F + G, d.len - o + P] : [o + P, F + G];
          }
        }
        resolveColor() {
          let h = this.series, F = h.chart.options.chart, o = h.chart.styledMode, a, c, d = F.colorCount, S;
          delete this.nonZonedColor, h.options.colorByPoint ? (o || (a = (c = h.options.colors || h.chart.options.colors)[h.colorCounter], d = c.length), S = h.colorCounter, h.colorCounter++, h.colorCounter === d && (h.colorCounter = 0)) : (o || (a = h.color), S = h.colorIndex), this.colorIndex = u(this.options.colorIndex, S), this.color = u(this.options.color, a);
        }
        setNestedProperty(h, F, o) {
          return o.split(".").reduce(function(a, c, d, S) {
            let P = S.length - 1 === d;
            return a[c] = P ? F : j(a[c], !0) ? a[c] : {}, a[c];
          }, h), h;
        }
        shouldDraw() {
          return !this.isNull;
        }
        tooltipFormatter(h) {
          let F = this.series, o = F.tooltipOptions, a = u(o.valueDecimals, ""), c = o.valuePrefix || "", d = o.valueSuffix || "";
          return F.chart.styledMode && (h = F.chart.tooltip.styledModeFormat(h)), (F.pointArrayMap || ["y"]).forEach(function(S) {
            S = "{point." + S, (c || d) && (h = h.replace(RegExp(S + "}", "g"), c + S + "}" + d)), h = h.replace(RegExp(S + "}", "g"), S + ":,." + a + "f}");
          }), T(h, { point: this, series: this.series }, F.chart);
        }
        update(h, F, o, a) {
          let c, d = this, S = d.series, P = d.graphic, G = S.chart, x = S.options;
          function Q() {
            d.applyOptions(h);
            let J = P && d.hasMockGraphic, ie = d.y === null ? !J : J;
            P && ie && (d.graphic = P.destroy(), delete d.hasMockGraphic), j(h, !0) && (P && P.element && h && h.marker && h.marker.symbol !== void 0 && (d.graphic = P.destroy()), h != null && h.dataLabels && d.dataLabel && (d.dataLabel = d.dataLabel.destroy())), c = d.index, S.updateParallelArrays(d, c), x.data[c] = j(x.data[c], !0) || j(h, !0) ? d.options : u(h, x.data[c]), S.isDirty = S.isDirtyData = !0, !S.fixedBox && S.hasCartesianSeries && (G.isDirtyBox = !0), x.legendType === "point" && (G.isDirtyLegend = !0), F && G.redraw(o);
          }
          F = u(F, !0), a === !1 ? Q() : d.firePointEvent("update", { options: h }, Q);
        }
        remove(h, F) {
          this.series.removePoint(this.series.data.indexOf(this), h, F);
        }
        select(h, F) {
          let o = this, a = o.series, c = a.chart;
          h = u(h, !o.selected), this.selectedStaging = h, o.firePointEvent(h ? "select" : "unselect", { accumulate: F }, function() {
            o.selected = o.options.selected = h, a.options.data[a.data.indexOf(o)] = o.options, o.setState(h && "select"), F || c.getSelectedPoints().forEach(function(d) {
              let S = d.series;
              d.selected && d !== o && (d.selected = d.options.selected = !1, S.options.data[S.data.indexOf(d)] = d.options, d.setState(c.hoverPoints && S.options.inactiveOtherPoints ? "inactive" : ""), d.firePointEvent("unselect"));
            });
          }), delete this.selectedStaging;
        }
        onMouseOver(h) {
          let { inverted: F, pointer: o } = this.series.chart;
          o && (h = h ? o.normalize(h) : o.getChartCoordinatesFromPoint(this, F), o.runPointActions(h, this));
        }
        onMouseOut() {
          let h = this.series.chart;
          this.firePointEvent("mouseOut"), this.series.options.inactiveOtherPoints || (h.hoverPoints || []).forEach(function(F) {
            F.setState();
          }), h.hoverPoints = h.hoverPoint = null;
        }
        manageEvent(h) {
          var a, c, d, S, P;
          let F = D(this.series.options.point, this.options), o = (a = F.events) == null ? void 0 : a[h];
          g(o) && (!((c = this.hcEvents) != null && c[h]) || ((S = (d = this.hcEvents) == null ? void 0 : d[h]) == null ? void 0 : S.map((G) => G.fn).indexOf(o)) === -1) ? (B(this, h, o), this.hasImportedEvents = !0) : this.hasImportedEvents && !o && ((P = this.hcEvents) != null && P[h]) && (K(this, h), delete this.hcEvents[h], Object.keys(this.hcEvents) || (this.hasImportedEvents = !1));
        }
        setState(h, F) {
          let o = this.series, a = this.state, c = o.options.states[h || "normal"] || {}, d = q.plotOptions[o.type].marker && o.options.marker, S = d && d.enabled === !1, P = d && d.states && d.states[h || "normal"] || {}, G = P.enabled === !1, x = this.marker || {}, Q = o.chart, J = d && o.markerAttribs, ie = o.halo, te, $, oe, p = o.stateMarkerGraphic, W;
          if ((h = h || "") === this.state && !F || this.selected && h !== "select" || c.enabled === !1 || h && (G || S && P.enabled === !1) || h && x.states && x.states[h] && x.states[h].enabled === !1)
            return;
          if (this.state = h, J && (te = o.markerAttribs(this, h)), this.graphic && !this.hasMockGraphic) {
            if (a && this.graphic.removeClass("highcharts-point-" + a), h && this.graphic.addClass("highcharts-point-" + h), !Q.styledMode) {
              $ = o.pointAttribs(this, h), oe = u(Q.options.chart.animation, c.animation);
              let w = $.opacity;
              o.options.inactiveOtherPoints && C(w) && (this.dataLabels || []).forEach(function(H) {
                H && !H.hasClass("highcharts-data-label-hidden") && (H.animate({ opacity: w }, oe), H.connector && H.connector.animate({ opacity: w }, oe));
              }), this.graphic.animate($, oe);
            }
            te && this.graphic.animate(te, u(Q.options.chart.animation, P.animation, d.animation)), p && p.hide();
          } else
            h && P && (W = x.symbol || o.symbol, p && p.currentSymbol !== W && (p = p.destroy()), te && (p ? p[F ? "animate" : "attr"]({ x: te.x, y: te.y }) : W && (o.stateMarkerGraphic = p = Q.renderer.symbol(W, te.x, te.y, te.width, te.height).add(o.markerGroup), p.currentSymbol = W)), !Q.styledMode && p && this.state !== "inactive" && p.attr(o.pointAttribs(this, h))), p && (p[h && this.isInside ? "show" : "hide"](), p.element.point = this, p.addClass(this.getClassName(), !0));
          let X = c.halo, f = this.graphic || p, L = f && f.visibility || "inherit";
          X && X.size && f && L !== "hidden" && !this.isCluster ? (ie || (o.halo = ie = Q.renderer.path().add(f.parentGroup)), ie.show()[F ? "animate" : "attr"]({ d: this.haloPath(X.size) }), ie.attr({ class: "highcharts-halo highcharts-color-" + u(this.colorIndex, o.colorIndex) + (this.className ? " " + this.className : ""), visibility: L, zIndex: -1 }), ie.point = this, Q.styledMode || ie.attr(b({ fill: this.color || o.color, "fill-opacity": X.opacity }, n.filterUserAttributes(X.attributes || {})))) : ie && ie.point && ie.point.haloPath && ie.animate({ d: ie.point.haloPath(0) }, null, ie.hide), v(this, "afterSetState", { state: h });
        }
        haloPath(h) {
          let F = this.pos();
          return F ? this.series.chart.renderer.symbols.circle(Math.floor(F[0]) - h, F[1] - h, 2 * h, 2 * h) : [];
        }
      }
      return z;
    }), i(e, "Core/Pointer.js", [e["Core/Color/Color.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function(n, s, l) {
      var m;
      let { parse: A } = n, { charts: Y, composed: q, isTouchDevice: T } = s, { addEvent: B, attr: O, css: b, extend: v, find: E, fireEvent: M, isNumber: g, isObject: C, objectEach: j, offset: D, pick: u, pushUnique: R, splat: K } = l;
      class I {
        applyInactiveState(k) {
          let h = [], F;
          (k || []).forEach(function(o) {
            F = o.series, h.push(F), F.linkedParent && h.push(F.linkedParent), F.linkedSeries && (h = h.concat(F.linkedSeries)), F.navigatorSeries && h.push(F.navigatorSeries);
          }), this.chart.series.forEach(function(o) {
            h.indexOf(o) === -1 ? o.setState("inactive", !0) : o.options.inactiveOtherPoints && o.setAllPointsToState("inactive");
          });
        }
        destroy() {
          let k = this;
          this.eventsToUnbind.forEach((h) => h()), this.eventsToUnbind = [], !s.chartCount && (I.unbindDocumentMouseUp && (I.unbindDocumentMouseUp = I.unbindDocumentMouseUp()), I.unbindDocumentTouchEnd && (I.unbindDocumentTouchEnd = I.unbindDocumentTouchEnd())), clearInterval(k.tooltipTimeout), j(k, function(h, F) {
            k[F] = void 0;
          });
        }
        getSelectionMarkerAttrs(k, h) {
          let F = { args: { chartX: k, chartY: h }, attrs: {}, shapeType: "rect" };
          return M(this, "getSelectionMarkerAttrs", F, (o) => {
            let a, { chart: c, zoomHor: d, zoomVert: S } = this, { mouseDownX: P = 0, mouseDownY: G = 0 } = c, x = o.attrs;
            x.x = c.plotLeft, x.y = c.plotTop, x.width = d ? 1 : c.plotWidth, x.height = S ? 1 : c.plotHeight, d && (a = k - P, x.width = Math.max(1, Math.abs(a)), x.x = (a > 0 ? 0 : a) + P), S && (a = h - G, x.height = Math.max(1, Math.abs(a)), x.y = (a > 0 ? 0 : a) + G);
          }), F;
        }
        drag(k) {
          let { chart: h } = this, { mouseDownX: F = 0, mouseDownY: o = 0 } = h, { panning: a, panKey: c, selectionMarkerFill: d } = h.options.chart, S = h.plotLeft, P = h.plotTop, G = h.plotWidth, x = h.plotHeight, Q = C(a) ? a.enabled : a, J = c && k[`${c}Key`], ie = k.chartX, te = k.chartY, $, oe = this.selectionMarker;
          if ((!oe || !oe.touch) && (ie < S ? ie = S : ie > S + G && (ie = S + G), te < P ? te = P : te > P + x && (te = P + x), this.hasDragged = Math.sqrt(Math.pow(F - ie, 2) + Math.pow(o - te, 2)), this.hasDragged > 10)) {
            $ = h.isInsidePlot(F - S, o - P, { visiblePlotOnly: !0 });
            let { shapeType: p, attrs: W } = this.getSelectionMarkerAttrs(ie, te);
            (h.hasCartesianSeries || h.mapView) && this.hasZoom && $ && !J && !oe && (this.selectionMarker = oe = h.renderer[p](), oe.attr({ class: "highcharts-selection-marker", zIndex: 7 }).add(), h.styledMode || oe.attr({ fill: d || A("#334eff").setOpacity(0.25).get() })), oe && oe.attr(W), $ && !oe && Q && h.pan(k, a);
          }
        }
        dragStart(k) {
          let h = this.chart;
          h.mouseIsDown = k.type, h.cancelClick = !1, h.mouseDownX = k.chartX, h.mouseDownY = k.chartY;
        }
        getSelectionBox(k) {
          let h = { args: { marker: k }, result: k.getBBox() };
          return M(this, "getSelectionBox", h), h.result;
        }
        drop(k) {
          let h, { chart: F, selectionMarker: o } = this;
          for (let a of F.axes)
            a.isPanning && (a.isPanning = !1, (a.options.startOnTick || a.options.endOnTick || a.series.some((c) => c.boosted)) && (a.forceRedraw = !0, a.setExtremes(a.userMin, a.userMax, !1), h = !0));
          if (h && F.redraw(), o && k) {
            if (this.hasDragged) {
              let a = this.getSelectionBox(o);
              F.transform({ axes: F.axes.filter((c) => c.zoomEnabled && (c.coll === "xAxis" && this.zoomX || c.coll === "yAxis" && this.zoomY)), selection: { originalEvent: k, xAxis: [], yAxis: [], ...a }, from: a });
            }
            g(F.index) && (this.selectionMarker = o.destroy());
          }
          F && g(F.index) && (b(F.container, { cursor: F._cursor }), F.cancelClick = this.hasDragged > 10, F.mouseIsDown = !1, this.hasDragged = 0, this.pinchDown = []);
        }
        findNearestKDPoint(k, h, F) {
          let o;
          return k.forEach(function(a) {
            let c = !(a.noSharedTooltip && h) && 0 > a.options.findNearestPointBy.indexOf("y"), d = a.searchPoint(F, c);
            C(d, !0) && d.series && (!C(o, !0) || function(S, P) {
              var J, ie;
              let G = S.distX - P.distX, x = S.dist - P.dist, Q = ((J = P.series.group) == null ? void 0 : J.zIndex) - ((ie = S.series.group) == null ? void 0 : ie.zIndex);
              return G !== 0 && h ? G : x !== 0 ? x : Q !== 0 ? Q : S.series.index > P.series.index ? -1 : 1;
            }(o, d) > 0) && (o = d);
          }), o;
        }
        getChartCoordinatesFromPoint(k, h) {
          let { xAxis: F, yAxis: o } = k.series, a = k.shapeArgs;
          if (F && o) {
            let c = k.clientX ?? k.plotX ?? 0, d = k.plotY || 0;
            return k.isNode && a && g(a.x) && g(a.y) && (c = a.x, d = a.y), h ? { chartX: o.len + o.pos - d, chartY: F.len + F.pos - c } : { chartX: c + F.pos, chartY: d + o.pos };
          }
          if (a && a.x && a.y)
            return { chartX: a.x, chartY: a.y };
        }
        getChartPosition() {
          if (this.chartPosition)
            return this.chartPosition;
          let { container: k } = this.chart, h = D(k);
          this.chartPosition = { left: h.left, top: h.top, scaleX: 1, scaleY: 1 };
          let { offsetHeight: F, offsetWidth: o } = k;
          return o > 2 && F > 2 && (this.chartPosition.scaleX = h.width / o, this.chartPosition.scaleY = h.height / F), this.chartPosition;
        }
        getCoordinates(k) {
          let h = { xAxis: [], yAxis: [] };
          for (let F of this.chart.axes)
            h[F.isXAxis ? "xAxis" : "yAxis"].push({ axis: F, value: F.toValue(k[F.horiz ? "chartX" : "chartY"]) });
          return h;
        }
        getHoverData(k, h, F, o, a, c) {
          let d = [], S = function(J) {
            return J.visible && !(!a && J.directTouch) && u(J.options.enableMouseTracking, !0);
          }, P = h, G, x = { chartX: c ? c.chartX : void 0, chartY: c ? c.chartY : void 0, shared: a };
          M(this, "beforeGetHoverData", x), G = P && !P.stickyTracking ? [P] : F.filter((J) => J.stickyTracking && (x.filter || S)(J));
          let Q = o && k || !c ? k : this.findNearestKDPoint(G, a, c);
          return P = Q && Q.series, Q && (a && !P.noSharedTooltip ? (G = F.filter(function(J) {
            return x.filter ? x.filter(J) : S(J) && !J.noSharedTooltip;
          })).forEach(function(J) {
            let ie = E(J.points, function(te) {
              return te.x === Q.x && !te.isNull;
            });
            C(ie) && (J.boosted && J.boost && (ie = J.boost.getPoint(ie)), d.push(ie));
          }) : d.push(Q)), M(this, "afterGetHoverData", x = { hoverPoint: Q }), { hoverPoint: x.hoverPoint, hoverSeries: P, hoverPoints: d };
        }
        getPointFromEvent(k) {
          let h = k.target, F;
          for (; h && !F; )
            F = h.point, h = h.parentNode;
          return F;
        }
        onTrackerMouseOut(k) {
          let h = this.chart, F = k.relatedTarget, o = h.hoverSeries;
          this.isDirectTouch = !1, !o || !F || o.stickyTracking || this.inClass(F, "highcharts-tooltip") || this.inClass(F, "highcharts-series-" + o.index) && this.inClass(F, "highcharts-tracker") || o.onMouseOut();
        }
        inClass(k, h) {
          let F = k, o;
          for (; F; ) {
            if (o = O(F, "class")) {
              if (o.indexOf(h) !== -1)
                return !0;
              if (o.indexOf("highcharts-container") !== -1)
                return !1;
            }
            F = F.parentElement;
          }
        }
        constructor(k, h) {
          var F;
          this.hasDragged = 0, this.pointerCaptureEventsToUnbind = [], this.eventsToUnbind = [], this.options = h, this.chart = k, this.runChartClick = !!((F = h.chart.events) != null && F.click), this.pinchDown = [], this.setDOMEvents(), M(this, "afterInit");
        }
        normalize(k, h) {
          let F = k.touches, o = F ? F.length ? F.item(0) : u(F.changedTouches, k.changedTouches)[0] : k;
          h || (h = this.getChartPosition());
          let a = o.pageX - h.left, c = o.pageY - h.top;
          return v(k, { chartX: Math.round(a /= h.scaleX), chartY: Math.round(c /= h.scaleY) });
        }
        onContainerClick(k) {
          let h = this.chart, F = h.hoverPoint, o = this.normalize(k), a = h.plotLeft, c = h.plotTop;
          !h.cancelClick && (F && this.inClass(o.target, "highcharts-tracker") ? (M(F.series, "click", v(o, { point: F })), h.hoverPoint && F.firePointEvent("click", o)) : (v(o, this.getCoordinates(o)), h.isInsidePlot(o.chartX - a, o.chartY - c, { visiblePlotOnly: !0 }) && M(h, "click", o)));
        }
        onContainerMouseDown(k) {
          var F;
          let h = (1 & (k.buttons || k.button)) == 1;
          k = this.normalize(k), s.isFirefox && k.button !== 0 && this.onContainerMouseMove(k), (k.button === void 0 || h) && (this.zoomOption(k), h && ((F = k.preventDefault) == null || F.call(k)), this.dragStart(k));
        }
        onContainerMouseLeave(k) {
          let { pointer: h } = Y[u(I.hoverChartIndex, -1)] || {};
          k = this.normalize(k), this.onContainerMouseMove(k), h && k.relatedTarget && !this.inClass(k.relatedTarget, "highcharts-tooltip") && (h.reset(), h.chartPosition = void 0);
        }
        onContainerMouseEnter() {
          delete this.chartPosition;
        }
        onContainerMouseMove(k) {
          let h = this.chart, F = h.tooltip, o = this.normalize(k);
          this.setHoverChartIndex(k), (h.mouseIsDown === "mousedown" || this.touchSelect(o)) && this.drag(o), !h.openMenu && (this.inClass(o.target, "highcharts-tracker") || h.isInsidePlot(o.chartX - h.plotLeft, o.chartY - h.plotTop, { visiblePlotOnly: !0 })) && !(F && F.shouldStickOnContact(o)) && (this.inClass(o.target, "highcharts-no-tooltip") ? this.reset(!1, 0) : this.runPointActions(o));
        }
        onDocumentTouchEnd(k) {
          this.onDocumentMouseUp(k);
        }
        onContainerTouchMove(k) {
          this.touchSelect(k) ? this.onContainerMouseMove(k) : this.touch(k);
        }
        onContainerTouchStart(k) {
          this.touchSelect(k) ? this.onContainerMouseDown(k) : (this.zoomOption(k), this.touch(k, !0));
        }
        onDocumentMouseMove(k) {
          let h = this.chart, F = h.tooltip, o = this.chartPosition, a = this.normalize(k, o);
          !o || h.isInsidePlot(a.chartX - h.plotLeft, a.chartY - h.plotTop, { visiblePlotOnly: !0 }) || F && F.shouldStickOnContact(a) || this.inClass(a.target, "highcharts-tracker") || this.reset();
        }
        onDocumentMouseUp(k) {
          var h, F;
          (F = (h = Y[u(I.hoverChartIndex, -1)]) == null ? void 0 : h.pointer) == null || F.drop(k);
        }
        pinch(k) {
          let h = this, { chart: F, hasZoom: o, lastTouches: a } = h, c = [].map.call(k.touches || [], (x) => h.normalize(x)), d = c.length, S = d === 1 && (h.inClass(k.target, "highcharts-tracker") && F.runTrackerClick || h.runChartClick), P = F.tooltip, G = d === 1 && u(P == null ? void 0 : P.options.followTouchMove, !0);
          d > 1 ? h.initiated = !0 : G && (h.initiated = !1), o && h.initiated && !S && k.cancelable !== !1 && k.preventDefault(), k.type === "touchstart" ? (h.pinchDown = c, h.res = !0) : G ? this.runPointActions(h.normalize(k)) : a && (M(F, "touchpan", { originalEvent: k, touches: c }, () => {
            let x = (Q) => {
              let J = Q[0], ie = Q[1] || J;
              return { x: J.chartX, y: J.chartY, width: ie.chartX - J.chartX, height: ie.chartY - J.chartY };
            };
            F.transform({ axes: F.axes.filter((Q) => Q.zoomEnabled && (this.zoomHor && Q.horiz || this.zoomVert && !Q.horiz)), to: x(c), from: x(a), trigger: k.type });
          }), h.res && (h.res = !1, this.reset(!1, 0))), h.lastTouches = c;
        }
        reset(k, h) {
          let F = this.chart, o = F.hoverSeries, a = F.hoverPoint, c = F.hoverPoints, d = F.tooltip, S = d && d.shared ? c : a;
          k && S && K(S).forEach(function(P) {
            P.series.isCartesian && P.plotX === void 0 && (k = !1);
          }), k ? d && S && K(S).length && (d.refresh(S), d.shared && c ? c.forEach(function(P) {
            P.setState(P.state, !0), P.series.isCartesian && (P.series.xAxis.crosshair && P.series.xAxis.drawCrosshair(null, P), P.series.yAxis.crosshair && P.series.yAxis.drawCrosshair(null, P));
          }) : a && (a.setState(a.state, !0), F.axes.forEach(function(P) {
            P.crosshair && a.series[P.coll] === P && P.drawCrosshair(null, a);
          }))) : (a && a.onMouseOut(), c && c.forEach(function(P) {
            P.setState();
          }), o && o.onMouseOut(), d && d.hide(h), this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove()), F.axes.forEach(function(P) {
            P.hideCrosshair();
          }), F.hoverPoints = F.hoverPoint = void 0);
        }
        runPointActions(k, h, F) {
          let o = this.chart, a = o.series, c = o.tooltip && o.tooltip.options.enabled ? o.tooltip : void 0, d = !!c && c.shared, S = h || o.hoverPoint, P = S && S.series || o.hoverSeries, G = (!k || k.type !== "touchmove") && (!!h || P && P.directTouch && this.isDirectTouch), x = this.getHoverData(S, P, a, G, d, k);
          S = x.hoverPoint, P = x.hoverSeries;
          let Q = x.hoverPoints, J = P && P.tooltipOptions.followPointer && !P.tooltipOptions.split, ie = d && P && !P.noSharedTooltip;
          if (S && (F || S !== o.hoverPoint || c && c.isHidden)) {
            if ((o.hoverPoints || []).forEach(function(te) {
              Q.indexOf(te) === -1 && te.setState();
            }), o.hoverSeries !== P && P.onMouseOver(), this.applyInactiveState(Q), (Q || []).forEach(function(te) {
              te.setState("hover");
            }), o.hoverPoint && o.hoverPoint.firePointEvent("mouseOut"), !S.series)
              return;
            o.hoverPoints = Q, o.hoverPoint = S, S.firePointEvent("mouseOver", void 0, () => {
              c && S && c.refresh(ie ? Q : S, k);
            });
          } else if (J && c && !c.isHidden) {
            let te = c.getAnchor([{}], k);
            o.isInsidePlot(te[0], te[1], { visiblePlotOnly: !0 }) && c.updatePosition({ plotX: te[0], plotY: te[1] });
          }
          this.unDocMouseMove || (this.unDocMouseMove = B(o.container.ownerDocument, "mousemove", (te) => {
            var $, oe;
            return (oe = ($ = Y[I.hoverChartIndex ?? -1]) == null ? void 0 : $.pointer) == null ? void 0 : oe.onDocumentMouseMove(te);
          }), this.eventsToUnbind.push(this.unDocMouseMove)), o.axes.forEach(function(te) {
            let $, oe = u((te.crosshair || {}).snap, !0);
            !oe || ($ = o.hoverPoint) && $.series[te.coll] === te || ($ = E(Q, (p) => p.series && p.series[te.coll] === te)), $ || !oe ? te.drawCrosshair(k, $) : te.hideCrosshair();
          });
        }
        setDOMEvents() {
          let k = this.chart.container, h = k.ownerDocument;
          k.onmousedown = this.onContainerMouseDown.bind(this), k.onmousemove = this.onContainerMouseMove.bind(this), k.onclick = this.onContainerClick.bind(this), this.eventsToUnbind.push(B(k, "mouseenter", this.onContainerMouseEnter.bind(this)), B(k, "mouseleave", this.onContainerMouseLeave.bind(this))), I.unbindDocumentMouseUp || (I.unbindDocumentMouseUp = B(h, "mouseup", this.onDocumentMouseUp.bind(this)));
          let F = this.chart.renderTo.parentElement;
          for (; F && F.tagName !== "BODY"; )
            this.eventsToUnbind.push(B(F, "scroll", () => {
              delete this.chartPosition;
            })), F = F.parentElement;
          this.eventsToUnbind.push(B(k, "touchstart", this.onContainerTouchStart.bind(this), { passive: !1 }), B(k, "touchmove", this.onContainerTouchMove.bind(this), { passive: !1 })), I.unbindDocumentTouchEnd || (I.unbindDocumentTouchEnd = B(h, "touchend", this.onDocumentTouchEnd.bind(this), { passive: !1 })), this.setPointerCapture(), B(this.chart, "redraw", this.setPointerCapture.bind(this));
        }
        setPointerCapture() {
          var a, c;
          if (!T)
            return;
          let k = this.pointerCaptureEventsToUnbind, h = this.chart, F = h.container, o = u((a = h.options.tooltip) == null ? void 0 : a.followTouchMove, !0) && h.series.some((d) => d.options.findNearestPointBy.indexOf("y") > -1);
          !this.hasPointerCapture && o ? (k.push(B(F, "pointerdown", (d) => {
            var S, P;
            (S = d.target) != null && S.hasPointerCapture(d.pointerId) && ((P = d.target) == null || P.releasePointerCapture(d.pointerId));
          }), B(F, "pointermove", (d) => {
            var S, P;
            (P = (S = h.pointer) == null ? void 0 : S.getPointFromEvent(d)) == null || P.onMouseOver(d);
          })), h.styledMode || b(F, { "touch-action": "none" }), F.className += " highcharts-no-touch-action", this.hasPointerCapture = !0) : this.hasPointerCapture && !o && (k.forEach((d) => d()), k.length = 0, h.styledMode || b(F, { "touch-action": u((c = h.options.chart.style) == null ? void 0 : c["touch-action"], "manipulation") }), F.className = F.className.replace(" highcharts-no-touch-action", ""), this.hasPointerCapture = !1);
        }
        setHoverChartIndex(k) {
          var o;
          let h = this.chart, F = s.charts[u(I.hoverChartIndex, -1)];
          F && F !== h && ((o = F.pointer) == null || o.onContainerMouseLeave(k || { relatedTarget: h.container })), F && F.mouseIsDown || (I.hoverChartIndex = h.index);
        }
        touch(k, h) {
          let F, { chart: o, pinchDown: a = [] } = this;
          this.setHoverChartIndex(), k.touches.length === 1 ? (k = this.normalize(k), o.isInsidePlot(k.chartX - o.plotLeft, k.chartY - o.plotTop, { visiblePlotOnly: !0 }) && !o.openMenu ? (h && this.runPointActions(k), k.type === "touchmove" && (F = !!a[0] && Math.pow(a[0].chartX - k.chartX, 2) + Math.pow(a[0].chartY - k.chartY, 2) >= 16), u(F, !0) && this.pinch(k)) : h && this.reset()) : k.touches.length === 2 && this.pinch(k);
        }
        touchSelect(k) {
          return !!(this.chart.zooming.singleTouch && k.touches && k.touches.length === 1);
        }
        zoomOption(k) {
          let h = this.chart, F = h.inverted, o = h.zooming.type || "", a, c;
          /touch/.test(k.type) && (o = u(h.zooming.pinchType, o)), this.zoomX = a = /x/.test(o), this.zoomY = c = /y/.test(o), this.zoomHor = a && !F || c && F, this.zoomVert = c && !F || a && F, this.hasZoom = a || c;
        }
      }
      return (m = I || (I = {})).compose = function(z) {
        R(q, "Core.Pointer") && B(z, "beforeRender", function() {
          this.pointer = new m(this, this.options);
        });
      }, I;
    }), i(e, "Core/Legend/Legend.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Templating.js"], e["Core/Globals.js"], e["Core/Series/Point.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Utilities.js"]], function(n, s, l, m, A, Y) {
      var q;
      let { animObject: T, setAnimation: B } = n, { format: O } = s, { composed: b, marginNames: v } = l, { distribute: E } = A, { addEvent: M, createElement: g, css: C, defined: j, discardElement: D, find: u, fireEvent: R, isNumber: K, merge: I, pick: z, pushUnique: k, relativeLength: h, stableSort: F, syncTimeout: o } = Y;
      class a {
        constructor(d, S) {
          this.allItems = [], this.initialItemY = 0, this.itemHeight = 0, this.itemMarginBottom = 0, this.itemMarginTop = 0, this.itemX = 0, this.itemY = 0, this.lastItemY = 0, this.lastLineHeight = 0, this.legendHeight = 0, this.legendWidth = 0, this.maxItemWidth = 0, this.maxLegendWidth = 0, this.offsetWidth = 0, this.padding = 0, this.pages = [], this.symbolHeight = 0, this.symbolWidth = 0, this.titleHeight = 0, this.totalItemWidth = 0, this.widthOption = 0, this.chart = d, this.setOptions(S), S.enabled && (this.render(), M(this.chart, "endResize", function() {
            this.legend.positionCheckboxes();
          })), M(this.chart, "render", () => {
            this.options.enabled && this.proximate && (this.proximatePositions(), this.positionItems());
          });
        }
        setOptions(d) {
          let S = z(d.padding, 8);
          this.options = d, this.chart.styledMode || (this.itemStyle = d.itemStyle, this.itemHiddenStyle = I(this.itemStyle, d.itemHiddenStyle)), this.itemMarginTop = d.itemMarginTop, this.itemMarginBottom = d.itemMarginBottom, this.padding = S, this.initialItemY = S - 5, this.symbolWidth = z(d.symbolWidth, 16), this.pages = [], this.proximate = d.layout === "proximate" && !this.chart.inverted, this.baseline = void 0;
        }
        update(d, S) {
          let P = this.chart;
          this.setOptions(I(!0, this.options, d)), this.destroy(), P.isDirtyLegend = P.isDirtyBox = !0, z(S, !0) && P.redraw(), R(this, "afterUpdate", { redraw: S });
        }
        colorizeItem(d, S) {
          let { area: P, group: G, label: x, line: Q, symbol: J } = d.legendItem || {};
          if (G == null || G[S ? "removeClass" : "addClass"]("highcharts-legend-item-hidden"), !this.chart.styledMode) {
            let { itemHiddenStyle: ie = {} } = this, te = ie.color, { fillColor: $, fillOpacity: oe, lineColor: p, marker: W } = d.options, X = (f) => (!S && (f.fill && (f.fill = te), f.stroke && (f.stroke = te)), f);
            x == null || x.css(I(S ? this.itemStyle : ie)), Q == null || Q.attr(X({ stroke: p || d.color })), J && J.attr(X(W && J.isMarker ? d.pointAttribs() : { fill: d.color })), P == null || P.attr(X({ fill: $ || d.color, "fill-opacity": $ ? 1 : oe ?? 0.75 }));
          }
          R(this, "afterColorizeItem", { item: d, visible: S });
        }
        positionItems() {
          this.allItems.forEach(this.positionItem, this), this.chart.isResizing || this.positionCheckboxes();
        }
        positionItem(d) {
          let { group: S, x: P = 0, y: G = 0 } = d.legendItem || {}, x = this.options, Q = x.symbolPadding, J = !x.rtl, ie = d.checkbox;
          if (S && S.element) {
            let te = { translateX: J ? P : this.legendWidth - P - 2 * Q - 4, translateY: G };
            S[j(S.translateY) ? "animate" : "attr"](te, void 0, () => {
              R(this, "afterPositionItem", { item: d });
            });
          }
          ie && (ie.x = P, ie.y = G);
        }
        destroyItem(d) {
          let S = d.checkbox, P = d.legendItem || {};
          for (let G of ["group", "label", "line", "symbol"])
            P[G] && (P[G] = P[G].destroy());
          S && D(S), d.legendItem = void 0;
        }
        destroy() {
          for (let d of this.getAllItems())
            this.destroyItem(d);
          for (let d of ["clipRect", "up", "down", "pager", "nav", "box", "title", "group"])
            this[d] && (this[d] = this[d].destroy());
          this.display = null;
        }
        positionCheckboxes() {
          let d, S = this.group && this.group.alignAttr, P = this.clipHeight || this.legendHeight, G = this.titleHeight;
          S && (d = S.translateY, this.allItems.forEach(function(x) {
            let Q, J = x.checkbox;
            J && (Q = d + G + J.y + (this.scrollOffset || 0) + 3, C(J, { left: S.translateX + x.checkboxOffset + J.x - 20 + "px", top: Q + "px", display: this.proximate || Q > d - 6 && Q < d + P - 6 ? "" : "none" }));
          }, this));
        }
        renderTitle() {
          let d = this.options, S = this.padding, P = d.title, G, x = 0;
          P.text && (this.title || (this.title = this.chart.renderer.label(P.text, S - 3, S - 4, void 0, void 0, void 0, d.useHTML, void 0, "legend-title").attr({ zIndex: 1 }), this.chart.styledMode || this.title.css(P.style), this.title.add(this.group)), P.width || this.title.css({ width: this.maxLegendWidth + "px" }), x = (G = this.title.getBBox()).height, this.offsetWidth = G.width, this.contentGroup.attr({ translateY: x })), this.titleHeight = x;
        }
        setText(d) {
          let S = this.options;
          d.legendItem.label.attr({ text: S.labelFormat ? O(S.labelFormat, d, this.chart) : S.labelFormatter.call(d) });
        }
        renderItem(d) {
          let S = d.legendItem = d.legendItem || {}, P = this.chart, G = P.renderer, x = this.options, Q = x.layout === "horizontal", J = this.symbolWidth, ie = x.symbolPadding || 0, te = this.itemStyle, $ = this.itemHiddenStyle, oe = Q ? z(x.itemDistance, 20) : 0, p = !x.rtl, W = !d.series, X = !W && d.series.drawLegendSymbol ? d.series : d, f = X.options, L = !!this.createCheckboxForItem && f && f.showCheckbox, w = x.useHTML, H = d.options.className, U = S.label, ee = J + ie + oe + (L ? 20 : 0);
          !U && (S.group = G.g("legend-item").addClass("highcharts-" + X.type + "-series highcharts-color-" + d.colorIndex + (H ? " " + H : "") + (W ? " highcharts-series-" + d.index : "")).attr({ zIndex: 1 }).add(this.scrollGroup), S.label = U = G.text("", p ? J + ie : -ie, this.baseline || 0, w), P.styledMode || U.css(I(d.visible ? te : $)), U.attr({ align: p ? "left" : "right", zIndex: 2 }).add(S.group), !this.baseline && (this.fontMetrics = G.fontMetrics(U), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, U.attr("y", this.baseline), this.symbolHeight = z(x.symbolHeight, this.fontMetrics.f), x.squareSymbol && (this.symbolWidth = z(x.symbolWidth, Math.max(this.symbolHeight, 16)), ee = this.symbolWidth + ie + oe + (L ? 20 : 0), p && U.attr("x", this.symbolWidth + ie))), X.drawLegendSymbol(this, d), this.setItemEvents && this.setItemEvents(d, U, w)), L && !d.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(d), this.colorizeItem(d, d.visible), (P.styledMode || !te.width) && U.css({ width: (x.itemWidth || this.widthOption || P.spacingBox.width) - ee + "px" }), this.setText(d);
          let ae = U.getBBox(), ne = this.fontMetrics && this.fontMetrics.h || 0;
          d.itemWidth = d.checkboxOffset = x.itemWidth || S.labelWidth || ae.width + ee, this.maxItemWidth = Math.max(this.maxItemWidth, d.itemWidth), this.totalItemWidth += d.itemWidth, this.itemHeight = d.itemHeight = Math.round(S.labelHeight || (ae.height > 1.5 * ne ? ae.height : ne));
        }
        layoutItem(d) {
          let S = this.options, P = this.padding, G = S.layout === "horizontal", x = d.itemHeight, Q = this.itemMarginBottom, J = this.itemMarginTop, ie = G ? z(S.itemDistance, 20) : 0, te = this.maxLegendWidth, $ = S.alignColumns && this.totalItemWidth > te ? this.maxItemWidth : d.itemWidth, oe = d.legendItem || {};
          G && this.itemX - P + $ > te && (this.itemX = P, this.lastLineHeight && (this.itemY += J + this.lastLineHeight + Q), this.lastLineHeight = 0), this.lastItemY = J + this.itemY + Q, this.lastLineHeight = Math.max(x, this.lastLineHeight), oe.x = this.itemX, oe.y = this.itemY, G ? this.itemX += $ : (this.itemY += J + x + Q, this.lastLineHeight = x), this.offsetWidth = this.widthOption || Math.max((G ? this.itemX - P - (d.checkbox ? 0 : ie) : $) + P, this.offsetWidth);
        }
        getAllItems() {
          let d = [];
          return this.chart.series.forEach(function(S) {
            let P = S && S.options;
            S && z(P.showInLegend, !j(P.linkedTo) && void 0, !0) && (d = d.concat((S.legendItem || {}).labels || (P.legendType === "point" ? S.data : S)));
          }), R(this, "afterGetAllItems", { allItems: d }), d;
        }
        getAlignment() {
          let d = this.options;
          return this.proximate ? d.align.charAt(0) + "tv" : d.floating ? "" : d.align.charAt(0) + d.verticalAlign.charAt(0) + d.layout.charAt(0);
        }
        adjustMargins(d, S) {
          let P = this.chart, G = this.options, x = this.getAlignment();
          x && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function(Q, J) {
            Q.test(x) && !j(d[J]) && (P[v[J]] = Math.max(P[v[J]], P.legend[(J + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][J] * G[J % 2 ? "x" : "y"] + z(G.margin, 12) + S[J] + (P.titleOffset[J] || 0)));
          });
        }
        proximatePositions() {
          let d, S = this.chart, P = [], G = this.options.align === "left";
          for (let x of (this.allItems.forEach(function(Q) {
            let J, ie, te = G, $, oe;
            Q.yAxis && (Q.xAxis.options.reversed && (te = !te), Q.points && (J = u(te ? Q.points : Q.points.slice(0).reverse(), function(p) {
              return K(p.plotY);
            })), ie = this.itemMarginTop + Q.legendItem.label.getBBox().height + this.itemMarginBottom, oe = Q.yAxis.top - S.plotTop, $ = Q.visible ? (J ? J.plotY : Q.yAxis.height) + (oe - 0.3 * ie) : oe + Q.yAxis.height, P.push({ target: $, size: ie, item: Q }));
          }, this), E(P, S.plotHeight)))
            d = x.item.legendItem || {}, K(x.pos) && (d.y = S.plotTop - S.spacing[0] + x.pos);
        }
        render() {
          let d = this.chart, S = d.renderer, P = this.options, G = this.padding, x = this.getAllItems(), Q, J, ie, te = this.group, $, oe = this.box;
          this.itemX = G, this.itemY = this.initialItemY, this.offsetWidth = 0, this.lastItemY = 0, this.widthOption = h(P.width, d.spacingBox.width - G), $ = d.spacingBox.width - 2 * G - P.x, ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) > -1 && ($ /= 2), this.maxLegendWidth = this.widthOption || $, te || (this.group = te = S.g("legend").addClass(P.className || "").attr({ zIndex: 7 }).add(), this.contentGroup = S.g().attr({ zIndex: 1 }).add(te), this.scrollGroup = S.g().add(this.contentGroup)), this.renderTitle(), F(x, (p, W) => (p.options && p.options.legendIndex || 0) - (W.options && W.options.legendIndex || 0)), P.reversed && x.reverse(), this.allItems = x, this.display = Q = !!x.length, this.lastLineHeight = 0, this.maxItemWidth = 0, this.totalItemWidth = 0, this.itemHeight = 0, x.forEach(this.renderItem, this), x.forEach(this.layoutItem, this), J = (this.widthOption || this.offsetWidth) + G, ie = this.lastItemY + this.lastLineHeight + this.titleHeight, ie = this.handleOverflow(ie) + G, oe || (this.box = oe = S.rect().addClass("highcharts-legend-box").attr({ r: P.borderRadius }).add(te)), d.styledMode || oe.attr({ stroke: P.borderColor, "stroke-width": P.borderWidth || 0, fill: P.backgroundColor || "none" }).shadow(P.shadow), J > 0 && ie > 0 && oe[oe.placed ? "animate" : "attr"](oe.crisp.call({}, { x: 0, y: 0, width: J, height: ie }, oe.strokeWidth())), te[Q ? "show" : "hide"](), d.styledMode && te.getStyle("display") === "none" && (J = ie = 0), this.legendWidth = J, this.legendHeight = ie, Q && this.align(), this.proximate || this.positionItems(), R(this, "afterRender");
        }
        align(d = this.chart.spacingBox) {
          let S = this.chart, P = this.options, G = d.y;
          /(lth|ct|rth)/.test(this.getAlignment()) && S.titleOffset[0] > 0 ? G += S.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && S.titleOffset[2] > 0 && (G -= S.titleOffset[2]), G !== d.y && (d = I(d, { y: G })), S.hasRendered || (this.group.placed = !1), this.group.align(I(P, { width: this.legendWidth, height: this.legendHeight, verticalAlign: this.proximate ? "top" : P.verticalAlign }), !0, d);
        }
        handleOverflow(d) {
          let S = this, P = this.chart, G = P.renderer, x = this.options, Q = x.y, J = x.verticalAlign === "top", ie = this.padding, te = x.maxHeight, $ = x.navigation, oe = z($.animation, !0), p = $.arrowSize || 12, W = this.pages, X = this.allItems, f = function(he) {
            typeof he == "number" ? ne.attr({ height: he }) : ne && (S.clipRect = ne.destroy(), S.contentGroup.clip()), S.contentGroup.div && (S.contentGroup.div.style.clip = he ? "rect(" + ie + "px,9999px," + (ie + he) + "px,0)" : "auto");
          }, L = function(he) {
            return S[he] = G.circle(0, 0, 1.3 * p).translate(p / 2, p / 2).add(ae), P.styledMode || S[he].attr("fill", "rgba(0,0,0,0.0001)"), S[he];
          }, w, H, U, ee = P.spacingBox.height + (J ? -Q : Q) - ie, ae = this.nav, ne = this.clipRect;
          return x.layout !== "horizontal" || x.verticalAlign === "middle" || x.floating || (ee /= 2), te && (ee = Math.min(ee, te)), W.length = 0, d && ee > 0 && d > ee && $.enabled !== !1 ? (this.clipHeight = w = Math.max(ee - 20 - this.titleHeight - ie, 0), this.currentPage = z(this.currentPage, 1), this.fullHeight = d, X.forEach((he, me) => {
            let ve = (U = he.legendItem || {}).y || 0, Me = Math.round(U.label.getBBox().height), Z = W.length;
            (!Z || ve - W[Z - 1] > w && (H || ve) !== W[Z - 1]) && (W.push(H || ve), Z++), U.pageIx = Z - 1, H && ((X[me - 1].legendItem || {}).pageIx = Z - 1), me === X.length - 1 && ve + Me - W[Z - 1] > w && ve > W[Z - 1] && (W.push(ve), U.pageIx = Z), ve !== H && (H = ve);
          }), ne || (ne = S.clipRect = G.clipRect(0, ie - 2, 9999, 0), S.contentGroup.clip(ne)), f(w), ae || (this.nav = ae = G.g().attr({ zIndex: 1 }).add(this.group), this.up = G.symbol("triangle", 0, 0, p, p).add(ae), L("upTracker").on("click", function() {
            S.scroll(-1, oe);
          }), this.pager = G.text("", 15, 10).addClass("highcharts-legend-navigation"), !P.styledMode && $.style && this.pager.css($.style), this.pager.add(ae), this.down = G.symbol("triangle-down", 0, 0, p, p).add(ae), L("downTracker").on("click", function() {
            S.scroll(1, oe);
          })), S.scroll(0), d = ee) : ae && (f(), this.nav = ae.destroy(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0), d;
        }
        scroll(d, S) {
          let P = this.chart, G = this.pages, x = G.length, Q = this.clipHeight, J = this.options.navigation, ie = this.pager, te = this.padding, $ = this.currentPage + d;
          $ > x && ($ = x), $ > 0 && (S !== void 0 && B(S, P), this.nav.attr({ translateX: te, translateY: Q + this.padding + 7 + this.titleHeight, visibility: "inherit" }), [this.up, this.upTracker].forEach(function(oe) {
            oe.attr({ class: $ === 1 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" });
          }), ie.attr({ text: $ + "/" + x }), [this.down, this.downTracker].forEach(function(oe) {
            oe.attr({ x: 18 + this.pager.getBBox().width, class: $ === x ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" });
          }, this), P.styledMode || (this.up.attr({ fill: $ === 1 ? J.inactiveColor : J.activeColor }), this.upTracker.css({ cursor: $ === 1 ? "default" : "pointer" }), this.down.attr({ fill: $ === x ? J.inactiveColor : J.activeColor }), this.downTracker.css({ cursor: $ === x ? "default" : "pointer" })), this.scrollOffset = -G[$ - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: this.scrollOffset }), this.currentPage = $, this.positionCheckboxes(), o(() => {
            R(this, "afterScroll", { currentPage: $ });
          }, T(z(S, P.renderer.globalAnimation, !0)).duration));
        }
        setItemEvents(d, S, P) {
          let G = this, x = d.legendItem || {}, Q = G.chart.renderer.boxWrapper, J = d instanceof m, ie = "highcharts-legend-" + (J ? "point" : "series") + "-active", te = G.chart.styledMode, $ = P ? [S, x.symbol] : [x.group], oe = (p) => {
            G.allItems.forEach((W) => {
              d !== W && [W].concat(W.linkedSeries || []).forEach((X) => {
                X.setState(p, !J);
              });
            });
          };
          for (let p of $)
            p && p.on("mouseover", function() {
              d.visible && oe("inactive"), d.setState("hover"), d.visible && Q.addClass(ie), te || S.css(G.options.itemHoverStyle);
            }).on("mouseout", function() {
              G.chart.styledMode || S.css(I(d.visible ? G.itemStyle : G.itemHiddenStyle)), oe(""), Q.removeClass(ie), d.setState();
            }).on("click", function(W) {
              let X = "legendItemClick", f = function() {
                d.setVisible && d.setVisible(), oe(d.visible ? "inactive" : "");
              };
              Q.removeClass(ie), W = { browserEvent: W }, d.firePointEvent ? d.firePointEvent(X, W, f) : R(d, X, W, f);
            });
        }
        createCheckboxForItem(d) {
          d.checkbox = g("input", { type: "checkbox", className: "highcharts-legend-checkbox", checked: d.selected, defaultChecked: d.selected }, this.options.itemCheckboxStyle, this.chart.container), M(d.checkbox, "click", function(S) {
            let P = S.target;
            R(d.series || d, "checkboxClick", { checked: P.checked, item: d }, function() {
              d.select();
            });
          });
        }
      }
      return (q = a || (a = {})).compose = function(c) {
        k(b, "Core.Legend") && M(c, "beforeMargins", function() {
          this.legend = new q(this, this.options.legend);
        });
      }, a;
    }), i(e, "Core/Legend/LegendSymbol.js", [e["Core/Utilities.js"]], function(n) {
      var s;
      let { extend: l, merge: m, pick: A } = n;
      return function(Y) {
        function q(T, B, O) {
          var F;
          let b = this.legendItem = this.legendItem || {}, { chart: v, options: E } = this, { baseline: M = 0, symbolWidth: g, symbolHeight: C } = T, j = this.symbol || "circle", D = C / 2, u = v.renderer, R = b.group, K = M - Math.round(C * (O ? 0.4 : 0.3)), I = {}, z, k = E.marker, h = 0;
          if (v.styledMode || (I["stroke-width"] = Math.min(E.lineWidth || 0, 24), E.dashStyle ? I.dashstyle = E.dashStyle : E.linecap === "square" || (I["stroke-linecap"] = "round")), b.line = u.path().addClass("highcharts-graph").attr(I).add(R), O && (b.area = u.path().addClass("highcharts-area").add(R)), I["stroke-linecap"] && (h = Math.min(b.line.strokeWidth(), g) / 2), g) {
            let o = [["M", h, K], ["L", g - h, K]];
            b.line.attr({ d: o }), (F = b.area) == null || F.attr({ d: [...o, ["L", g - h, M], ["L", h, M]] });
          }
          if (k && k.enabled !== !1 && g) {
            let o = Math.min(A(k.radius, D), D);
            j.indexOf("url") === 0 && (k = m(k, { width: C, height: C }), o = 0), b.symbol = z = u.symbol(j, g / 2 - o, K - o, 2 * o, 2 * o, l({ context: "legend" }, k)).addClass("highcharts-point").add(R), z.isMarker = !0;
          }
        }
        Y.areaMarker = function(T, B) {
          q.call(this, T, B, !0);
        }, Y.lineMarker = q, Y.rectangle = function(T, B) {
          let O = B.legendItem || {}, b = T.options, v = T.symbolHeight, E = b.squareSymbol, M = E ? v : T.symbolWidth;
          O.symbol = this.chart.renderer.rect(E ? (T.symbolWidth - v) / 2 : 0, T.baseline - v + 1, M, v, A(T.options.symbolRadius, v / 2)).addClass("highcharts-point").attr({ zIndex: 3 }).add(O.group);
        };
      }(s || (s = {})), s;
    }), i(e, "Core/Series/SeriesDefaults.js", [], function() {
      return { lineWidth: 2, allowPointSelect: !1, crisp: !0, showCheckbox: !1, animation: { duration: 1e3 }, enableMouseTracking: !0, events: {}, marker: { enabledThreshold: 2, lineColor: "#ffffff", lineWidth: 0, radius: 4, states: { normal: { animation: !0 }, hover: { animation: { duration: 150 }, enabled: !0, radiusPlus: 2, lineWidthPlus: 1 }, select: { fillColor: "#cccccc", lineColor: "#000000", lineWidth: 2 } } }, point: { events: {} }, dataLabels: { animation: {}, align: "center", borderWidth: 0, defer: !0, formatter: function() {
        let { numberFormatter: n } = this.series.chart;
        return typeof this.y != "number" ? "" : n(this.y, -1);
      }, padding: 5, style: { fontSize: "0.7em", fontWeight: "bold", color: "contrast", textOutline: "1px contrast" }, verticalAlign: "bottom", x: 0, y: 0 }, cropThreshold: 300, opacity: 1, pointRange: 0, softThreshold: !0, states: { normal: { animation: !0 }, hover: { animation: { duration: 150 }, lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: 0.25 } }, select: { animation: { duration: 0 } }, inactive: { animation: { duration: 150 }, opacity: 0.2 } }, stickyTracking: !0, turboThreshold: 1e3, findNearestPointBy: "x" };
    }), i(e, "Core/Series/SeriesRegistry.js", [e["Core/Globals.js"], e["Core/Defaults.js"], e["Core/Series/Point.js"], e["Core/Utilities.js"]], function(n, s, l, m) {
      var A;
      let { defaultOptions: Y } = s, { extend: q, extendClass: T, merge: B } = m;
      return function(O) {
        function b(v, E) {
          let M = Y.plotOptions || {}, g = E.defaultOptions, C = E.prototype;
          return C.type = v, C.pointClass || (C.pointClass = l), !O.seriesTypes[v] && (g && (M[v] = g), O.seriesTypes[v] = E, !0);
        }
        O.seriesTypes = n.seriesTypes, O.registerSeriesType = b, O.seriesType = function(v, E, M, g, C) {
          let j = Y.plotOptions || {};
          if (E = E || "", j[v] = B(j[E], M), delete O.seriesTypes[v], b(v, T(O.seriesTypes[E] || function() {
          }, g)), O.seriesTypes[v].prototype.type = v, C) {
            class D extends l {
            }
            q(D.prototype, C), O.seriesTypes[v].prototype.pointClass = D;
          }
          return O.seriesTypes[v];
        };
      }(A || (A = {})), A;
    }), i(e, "Core/Series/Series.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Defaults.js"], e["Core/Foundation.js"], e["Core/Globals.js"], e["Core/Legend/LegendSymbol.js"], e["Core/Series/Point.js"], e["Core/Series/SeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Utilities.js"]], function(n, s, l, m, A, Y, q, T, B, O) {
      let { animObject: b, setAnimation: v } = n, { defaultOptions: E } = s, { registerEventOptions: M } = l, { svg: g, win: C } = m, { seriesTypes: j } = T, { arrayMax: D, arrayMin: u, clamp: R, correctFloat: K, defined: I, destroyObjectProperties: z, diffObjects: k, erase: h, error: F, extend: o, find: a, fireEvent: c, getClosestDistance: d, getNestedProperty: S, insertItem: P, isArray: G, isNumber: x, isString: Q, merge: J, objectEach: ie, pick: te, removeEvent: $, splat: oe, syncTimeout: p } = O;
      class W {
        constructor() {
          this.zoneAxis = "y";
        }
        init(f, L) {
          let w;
          c(this, "init", { options: L });
          let H = this, U = f.series;
          this.eventsToUnbind = [], H.chart = f, H.options = H.setOptions(L);
          let ee = H.options, ae = ee.visible !== !1;
          H.linkedSeries = [], H.bindAxes(), o(H, { name: ee.name, state: "", visible: ae, selected: ee.selected === !0 }), M(this, ee);
          let ne = ee.events;
          (ne && ne.click || ee.point && ee.point.events && ee.point.events.click || ee.allowPointSelect) && (f.runTrackerClick = !0), H.getColor(), H.getSymbol(), H.parallelArrays.forEach(function(he) {
            H[he + "Data"] || (H[he + "Data"] = []);
          }), H.isCartesian && (f.hasCartesianSeries = !0), U.length && (w = U[U.length - 1]), H._i = te(w && w._i, -1) + 1, H.opacity = H.options.opacity, f.orderItems("series", P(this, U)), ee.dataSorting && ee.dataSorting.enabled ? H.setDataSortingOptions() : H.points || H.data || H.setData(ee.data, !1), c(this, "afterInit");
        }
        is(f) {
          return j[f] && this instanceof j[f];
        }
        bindAxes() {
          let f, L = this, w = L.options, H = L.chart;
          c(this, "bindAxes", null, function() {
            (L.axisTypes || []).forEach(function(U) {
              (H[U] || []).forEach(function(ee) {
                f = ee.options, (te(w[U], 0) === ee.index || w[U] !== void 0 && w[U] === f.id) && (P(L, ee.series), L[U] = ee, ee.isDirty = !0);
              }), L[U] || L.optionalAxis === U || F(18, !0, H);
            });
          }), c(this, "afterBindAxes");
        }
        updateParallelArrays(f, L, w) {
          let H = f.series, U = x(L) ? function(ee) {
            let ae = ee === "y" && H.toYData ? H.toYData(f) : f[ee];
            H[ee + "Data"][L] = ae;
          } : function(ee) {
            Array.prototype[L].apply(H[ee + "Data"], w);
          };
          H.parallelArrays.forEach(U);
        }
        hasData() {
          return this.visible && this.dataMax !== void 0 && this.dataMin !== void 0 || this.visible && this.yData && this.yData.length > 0;
        }
        hasMarkerChanged(f, L) {
          let w = f.marker, H = L.marker || {};
          return w && (H.enabled && !w.enabled || H.symbol !== w.symbol || H.height !== w.height || H.width !== w.width);
        }
        autoIncrement(f) {
          let L = this.options, w = L.pointIntervalUnit, H = L.relativeXValue, U = this.chart.time, ee = this.xIncrement, ae, ne;
          return ee = te(ee, L.pointStart, 0), this.pointInterval = ne = te(this.pointInterval, L.pointInterval, 1), H && x(f) && (ne *= f), w && (ae = new U.Date(ee), w === "day" ? U.set("Date", ae, U.get("Date", ae) + ne) : w === "month" ? U.set("Month", ae, U.get("Month", ae) + ne) : w === "year" && U.set("FullYear", ae, U.get("FullYear", ae) + ne), ne = ae.getTime() - ee), H && x(f) ? ee + ne : (this.xIncrement = ee + ne, ee);
        }
        setDataSortingOptions() {
          let f = this.options;
          o(this, { requireSorting: !1, sorted: !1, enabledDataSorting: !0, allowDG: !1 }), I(f.pointRange) || (f.pointRange = 1);
        }
        setOptions(f) {
          var le, be;
          let L, w = this.chart, H = w.options.plotOptions, U = w.userOptions || {}, ee = J(f), ae = w.styledMode, ne = { plotOptions: H, userOptions: ee };
          c(this, "setOptions", ne);
          let he = ne.plotOptions[this.type], me = U.plotOptions || {}, ve = me.series || {}, Me = E.plotOptions[this.type] || {}, Z = me[this.type] || {};
          this.userOptions = ne.userOptions;
          let V = J(he, H.series, Z, ee);
          this.tooltipOptions = J(E.tooltip, (le = E.plotOptions.series) == null ? void 0 : le.tooltip, Me == null ? void 0 : Me.tooltip, w.userOptions.tooltip, (be = me.series) == null ? void 0 : be.tooltip, Z.tooltip, ee.tooltip), this.stickyTracking = te(ee.stickyTracking, Z.stickyTracking, ve.stickyTracking, !!this.tooltipOptions.shared && !this.noSharedTooltip || V.stickyTracking), he.marker === null && delete V.marker, this.zoneAxis = V.zoneAxis || "y";
          let re = this.zones = (V.zones || []).map((de) => ({ ...de }));
          return (V.negativeColor || V.negativeFillColor) && !V.zones && (L = { value: V[this.zoneAxis + "Threshold"] || V.threshold || 0, className: "highcharts-negative" }, ae || (L.color = V.negativeColor, L.fillColor = V.negativeFillColor), re.push(L)), re.length && I(re[re.length - 1].value) && re.push(ae ? {} : { color: this.color, fillColor: this.fillColor }), c(this, "afterSetOptions", { options: V }), V;
        }
        getName() {
          return te(this.options.name, "Series " + (this.index + 1));
        }
        getCyclic(f, L, w) {
          let H, U, ee = this.chart, ae = `${f}Index`, ne = `${f}Counter`, he = (w == null ? void 0 : w.length) || ee.options.chart.colorCount;
          !L && (I(U = te(f === "color" ? this.options.colorIndex : void 0, this[ae])) ? H = U : (ee.series.length || (ee[ne] = 0), H = ee[ne] % he, ee[ne] += 1), w && (L = w[H])), H !== void 0 && (this[ae] = H), this[f] = L;
        }
        getColor() {
          this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || E.plotOptions[this.type].color, this.chart.options.colors);
        }
        getPointsCollection() {
          return (this.hasGroupedData ? this.points : this.data) || [];
        }
        getSymbol() {
          let f = this.options.marker;
          this.getCyclic("symbol", f.symbol, this.chart.options.symbols);
        }
        findPointIndex(f, L) {
          let w, H, U, ee = f.id, ae = f.x, ne = this.points, he = this.options.dataSorting;
          if (ee) {
            let me = this.chart.get(ee);
            me instanceof Y && (w = me);
          } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
            let me = (ve) => !ve.touched && ve.index === f.index;
            if (he && he.matchByName ? me = (ve) => !ve.touched && ve.name === f.name : this.options.relativeXValue && (me = (ve) => !ve.touched && ve.options.x === f.x), !(w = a(ne, me)))
              return;
          }
          return w && (U = w && w.index) !== void 0 && (H = !0), U === void 0 && x(ae) && (U = this.xData.indexOf(ae, L)), U !== -1 && U !== void 0 && this.cropped && (U = U >= this.cropStart ? U - this.cropStart : U), !H && x(U) && ne[U] && ne[U].touched && (U = void 0), U;
        }
        updateData(f, L) {
          let w = this.options, H = w.dataSorting, U = this.points, ee = [], ae = this.requireSorting, ne = f.length === U.length, he, me, ve, Me, Z = !0;
          if (this.xIncrement = null, f.forEach(function(V, re) {
            let le, be = I(V) && this.pointClass.prototype.optionsToObject.call({ series: this }, V) || {}, de = be.x;
            be.id || x(de) ? ((le = this.findPointIndex(be, Me)) === -1 || le === void 0 ? ee.push(V) : U[le] && V !== w.data[le] ? (U[le].update(V, !1, null, !1), U[le].touched = !0, ae && (Me = le + 1)) : U[le] && (U[le].touched = !0), (!ne || re !== le || H && H.enabled || this.hasDerivedData) && (he = !0)) : ee.push(V);
          }, this), he)
            for (me = U.length; me--; )
              (ve = U[me]) && !ve.touched && ve.remove && ve.remove(!1, L);
          else
            !ne || H && H.enabled ? Z = !1 : (f.forEach(function(V, re) {
              V === U[re].y || U[re].destroyed || U[re].update(V, !1, null, !1);
            }), ee.length = 0);
          return U.forEach(function(V) {
            V && (V.touched = !1);
          }), !!Z && (ee.forEach(function(V) {
            this.addPoint(V, !1, null, null, !1);
          }, this), this.xIncrement === null && this.xData && this.xData.length && (this.xIncrement = D(this.xData), this.autoIncrement()), !0);
        }
        setData(f, L = !0, w, H) {
          var Ye;
          let U = this, ee = U.points, ae = ee && ee.length || 0, ne = U.options, he = U.chart, me = ne.dataSorting, ve = U.xAxis, Me = ne.turboThreshold, Z = this.xData, V = this.yData, re = U.pointArrayMap, le = re && re.length, be = ne.keys, de, ge, fe, ke = 0, Pe = 1, Ae = null, Le;
          he.options.chart.allowMutatingData || (ne.data && delete U.options.data, U.userOptions.data && delete U.userOptions.data, Le = J(!0, f));
          let Ee = (f = Le || f || []).length;
          if (me && me.enabled && (f = this.sortData(f)), he.options.chart.allowMutatingData && H !== !1 && Ee && ae && !U.cropped && !U.hasGroupedData && U.visible && !U.boosted && (fe = this.updateData(f, w)), !fe) {
            if (U.xIncrement = null, U.colorCounter = 0, this.parallelArrays.forEach(function(We) {
              U[We + "Data"].length = 0;
            }), Me && Ee > Me)
              if (x(Ae = U.getFirstValidPoint(f)))
                for (de = 0; de < Ee; de++)
                  Z[de] = this.autoIncrement(), V[de] = f[de];
              else if (G(Ae))
                if (le)
                  if (Ae.length === le)
                    for (de = 0; de < Ee; de++)
                      Z[de] = this.autoIncrement(), V[de] = f[de];
                  else
                    for (de = 0; de < Ee; de++)
                      ge = f[de], Z[de] = ge[0], V[de] = ge.slice(1, le + 1);
                else if (be && (ke = be.indexOf("x"), Pe = be.indexOf("y"), ke = ke >= 0 ? ke : 0, Pe = Pe >= 0 ? Pe : 1), Ae.length === 1 && (Pe = 0), ke === Pe)
                  for (de = 0; de < Ee; de++)
                    Z[de] = this.autoIncrement(), V[de] = f[de][Pe];
                else
                  for (de = 0; de < Ee; de++)
                    ge = f[de], Z[de] = ge[ke], V[de] = ge[Pe];
              else
                F(12, !1, he);
            else
              for (de = 0; de < Ee; de++)
                ge = { series: U }, U.pointClass.prototype.applyOptions.apply(ge, [f[de]]), U.updateParallelArrays(ge, de);
            for (V && Q(V[0]) && F(14, !0, he), U.data = [], U.options.data = U.userOptions.data = f, de = ae; de--; )
              (Ye = ee[de]) == null || Ye.destroy();
            ve && (ve.minRange = ve.userMinRange), U.isDirty = he.isDirtyBox = !0, U.isDirtyData = !!ee, w = !1;
          }
          ne.legendType === "point" && (this.processData(), this.generatePoints()), L && he.redraw(w);
        }
        sortData(f) {
          let L = this, w = L.options.dataSorting.sortKey || "y", H = function(U, ee) {
            return I(ee) && U.pointClass.prototype.optionsToObject.call({ series: U }, ee) || {};
          };
          return f.forEach(function(U, ee) {
            f[ee] = H(L, U), f[ee].index = ee;
          }, this), f.concat().sort((U, ee) => {
            let ae = S(w, U), ne = S(w, ee);
            return ne < ae ? -1 : ne > ae ? 1 : 0;
          }).forEach(function(U, ee) {
            U.x = ee;
          }, this), L.linkedSeries && L.linkedSeries.forEach(function(U) {
            let ee = U.options, ae = ee.data;
            ee.dataSorting && ee.dataSorting.enabled || !ae || (ae.forEach(function(ne, he) {
              ae[he] = H(U, ne), f[he] && (ae[he].x = f[he].x, ae[he].index = he);
            }), U.setData(ae, !1));
          }), f;
        }
        getProcessedData(f) {
          let L = this, w = L.xAxis, H = L.options, U = H.cropThreshold, ee = f || L.getExtremesFromAll || H.getExtremesFromAll, ae = w == null ? void 0 : w.logarithmic, ne = L.isCartesian, he, me, ve = 0, Me, Z, V, re = L.xData, le = L.yData, be = !1, de = re.length;
          w && (Z = (Me = w.getExtremes()).min, V = Me.max, be = !!(w.categories && !w.names.length)), ne && L.sorted && !ee && (!U || de > U || L.forceCrop) && (re[de - 1] < Z || re[0] > V ? (re = [], le = []) : L.yData && (re[0] < Z || re[de - 1] > V) && (re = (he = this.cropData(L.xData, L.yData, Z, V)).xData, le = he.yData, ve = he.start, me = !0));
          let ge = d([ae ? re.map(ae.log2lin) : re], () => L.requireSorting && !be && F(15, !1, L.chart));
          return { xData: re, yData: le, cropped: me, cropStart: ve, closestPointRange: ge };
        }
        processData(f) {
          let L = this.xAxis;
          if (this.isCartesian && !this.isDirty && !L.isDirty && !this.yAxis.isDirty && !f)
            return !1;
          let w = this.getProcessedData();
          this.cropped = w.cropped, this.cropStart = w.cropStart, this.processedXData = w.xData, this.processedYData = w.yData, this.closestPointRange = this.basePointRange = w.closestPointRange, c(this, "afterProcessData");
        }
        cropData(f, L, w, H) {
          let U = f.length, ee, ae, ne = 0, he = U;
          for (ee = 0; ee < U; ee++)
            if (f[ee] >= w) {
              ne = Math.max(0, ee - 1);
              break;
            }
          for (ae = ee; ae < U; ae++)
            if (f[ae] > H) {
              he = ae + 1;
              break;
            }
          return { xData: f.slice(ne, he), yData: L.slice(ne, he), start: ne, end: he };
        }
        generatePoints() {
          let f = this.options, L = this.processedData || f.data, w = this.processedXData, H = this.processedYData, U = this.pointClass, ee = w.length, ae = this.cropStart || 0, ne = this.hasGroupedData, he = f.keys, me = [], ve = f.dataGrouping && f.dataGrouping.groupAll ? ae : 0, Me, Z, V, re, le = this.data;
          if (!le && !ne) {
            let be = [];
            be.length = L.length, le = this.data = be;
          }
          for (he && ne && (this.options.keys = !1), re = 0; re < ee; re++)
            Z = ae + re, ne ? ((V = new U(this, [w[re]].concat(oe(H[re])))).dataGroup = this.groupMap[ve + re], V.dataGroup.options && (V.options = V.dataGroup.options, o(V, V.dataGroup.options), delete V.dataLabels)) : (V = le[Z]) || L[Z] === void 0 || (le[Z] = V = new U(this, L[Z], w[re])), V && (V.index = ne ? ve + re : Z, me[re] = V);
          if (this.options.keys = he, le && (ee !== (Me = le.length) || ne))
            for (re = 0; re < Me; re++)
              re !== ae || ne || (re += ee), le[re] && (le[re].destroyElements(), le[re].plotX = void 0);
          this.data = le, this.points = me, c(this, "afterGeneratePoints");
        }
        getXExtremes(f) {
          return { min: u(f), max: D(f) };
        }
        getExtremes(f, L) {
          let w = this.xAxis, H = this.yAxis, U = this.processedXData || this.xData, ee = [], ae = this.requireSorting && !this.is("column") ? 1 : 0, ne = !!H && H.positiveValuesOnly, he, me, ve, Me, Z, V, re, le = 0, be = 0, de = 0, ge = (f = f || this.stackedYData || this.processedYData || []).length;
          for (w && (le = (he = w.getExtremes()).min, be = he.max), V = 0; V < ge; V++)
            if (Me = U[V], me = (x(Z = f[V]) || G(Z)) && ((x(Z) ? Z > 0 : Z.length) || !ne), ve = L || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !w || (U[V + ae] || Me) >= le && (U[V - ae] || Me) <= be, me && ve)
              if (re = Z.length)
                for (; re--; )
                  x(Z[re]) && (ee[de++] = Z[re]);
              else
                ee[de++] = Z;
          let fe = { activeYData: ee, dataMin: u(ee), dataMax: D(ee) };
          return c(this, "afterGetExtremes", { dataExtremes: fe }), fe;
        }
        applyExtremes() {
          let f = this.getExtremes();
          return this.dataMin = f.dataMin, this.dataMax = f.dataMax, f;
        }
        getFirstValidPoint(f) {
          let L = f.length, w = 0, H = null;
          for (; H === null && w < L; )
            H = f[w], w++;
          return H;
        }
        translate() {
          var ge;
          this.processedXData || this.processData(), this.generatePoints();
          let f = this.options, L = f.stacking, w = this.xAxis, H = w.categories, U = this.enabledDataSorting, ee = this.yAxis, ae = this.points, ne = ae.length, he = this.pointPlacementToXValue(), me = !!he, ve = f.threshold, Me = f.startFromThreshold ? ve : 0, Z, V, re, le, be = Number.MAX_VALUE;
          function de(fe) {
            return R(fe, -1e5, 1e5);
          }
          for (Z = 0; Z < ne; Z++) {
            let fe, ke = ae[Z], Pe = ke.x, Ae, Le, Ee = ke.y, Ye = ke.low, We = L && ((ge = ee.stacking) == null ? void 0 : ge.stacks[(this.negStacks && Ee < (Me ? 0 : ve) ? "-" : "") + this.stackKey]);
            V = w.translate(Pe, !1, !1, !1, !0, he), ke.plotX = x(V) ? K(de(V)) : void 0, L && this.visible && We && We[Pe] && (le = this.getStackIndicator(le, Pe, this.index), !ke.isNull && le.key && (Le = (Ae = We[Pe]).points[le.key]), Ae && G(Le) && (Ye = Le[0], Ee = Le[1], Ye === Me && le.key === We[Pe].base && (Ye = te(x(ve) ? ve : ee.min)), ee.positiveValuesOnly && I(Ye) && Ye <= 0 && (Ye = void 0), ke.total = ke.stackTotal = te(Ae.total), ke.percentage = I(ke.y) && Ae.total ? ke.y / Ae.total * 100 : void 0, ke.stackY = Ee, this.irregularWidths || Ae.setOffset(this.pointXOffset || 0, this.barW || 0, void 0, void 0, void 0, this.xAxis))), ke.yBottom = I(Ye) ? de(ee.translate(Ye, !1, !0, !1, !0)) : void 0, this.dataModify && (Ee = this.dataModify.modifyValue(Ee, Z)), x(Ee) && ke.plotX !== void 0 && (fe = x(fe = ee.translate(Ee, !1, !0, !1, !0)) ? de(fe) : void 0), ke.plotY = fe, ke.isInside = this.isPointInside(ke), ke.clientX = me ? K(w.translate(Pe, !1, !1, !1, !0, he)) : V, ke.negative = (ke.y || 0) < (ve || 0), ke.category = te(H && H[ke.x], ke.x), ke.isNull || ke.visible === !1 || (re !== void 0 && (be = Math.min(be, Math.abs(V - re))), re = V), ke.zone = this.zones.length ? ke.getZone() : void 0, !ke.graphic && this.group && U && (ke.isNew = !0);
          }
          this.closestPointRangePx = be, c(this, "afterTranslate");
        }
        getValidPoints(f, L, w) {
          let H = this.chart;
          return (f || this.points || []).filter(function(U) {
            let { plotX: ee, plotY: ae } = U;
            return !!((w || !U.isNull && x(ae)) && (!L || H.isInsidePlot(ee, ae, { inverted: H.inverted }))) && U.visible !== !1;
          });
        }
        getClipBox() {
          let { chart: f, xAxis: L, yAxis: w } = this, { x: H, y: U, width: ee, height: ae } = J(f.clipBox);
          return L && L.len !== f.plotSizeX && (ee = L.len), w && w.len !== f.plotSizeY && (ae = w.len), f.inverted && !this.invertible && ([ee, ae] = [ae, ee]), { x: H, y: U, width: ee, height: ae };
        }
        getSharedClipKey() {
          return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0), this.sharedClipKey;
        }
        setClip() {
          let { chart: f, group: L, markerGroup: w } = this, H = f.sharedClips, U = f.renderer, ee = this.getClipBox(), ae = this.getSharedClipKey(), ne = H[ae];
          ne ? ne.animate(ee) : H[ae] = ne = U.clipRect(ee), L && L.clip(this.options.clip === !1 ? void 0 : ne), w && w.clip();
        }
        animate(f) {
          let { chart: L, group: w, markerGroup: H } = this, U = L.inverted, ee = b(this.options.animation), ae = [this.getSharedClipKey(), ee.duration, ee.easing, ee.defer].join(","), ne = L.sharedClips[ae], he = L.sharedClips[ae + "m"];
          if (f && w) {
            let me = this.getClipBox();
            if (ne)
              ne.attr("height", me.height);
            else {
              me.width = 0, U && (me.x = L.plotHeight), ne = L.renderer.clipRect(me), L.sharedClips[ae] = ne;
              let ve = { x: -99, y: -99, width: U ? L.plotWidth + 199 : 99, height: U ? 99 : L.plotHeight + 199 };
              he = L.renderer.clipRect(ve), L.sharedClips[ae + "m"] = he;
            }
            w.clip(ne), H == null || H.clip(he);
          } else if (ne && !ne.hasClass("highcharts-animating")) {
            let me = this.getClipBox(), ve = ee.step;
            (H != null && H.element.childNodes.length || L.series.length > 1) && (ee.step = function(Me, Z) {
              ve && ve.apply(Z, arguments), Z.prop === "width" && (he != null && he.element) && he.attr(U ? "height" : "width", Me + 99);
            }), ne.addClass("highcharts-animating").animate(me, ee);
          }
        }
        afterAnimate() {
          this.setClip(), ie(this.chart.sharedClips, (f, L, w) => {
            f && !this.chart.container.querySelector(`[clip-path="url(#${f.id})"]`) && (f.destroy(), delete w[L]);
          }), this.finishedAnimating = !0, c(this, "afterAnimate");
        }
        drawPoints(f = this.points) {
          let L, w, H, U, ee, ae, ne, he = this.chart, me = he.styledMode, { colorAxis: ve, options: Me } = this, Z = Me.marker, V = this[this.specialGroup || "markerGroup"], re = this.xAxis, le = te(Z.enabled, !re || !!re.isRadial || null, this.closestPointRangePx >= Z.enabledThreshold * Z.radius);
          if (Z.enabled !== !1 || this._hasPointMarkers)
            for (L = 0; L < f.length; L++)
              if (U = (H = (w = f[L]).graphic) ? "animate" : "attr", ee = w.marker || {}, ae = !!w.marker, (le && ee.enabled === void 0 || ee.enabled) && !w.isNull && w.visible !== !1) {
                let be = te(ee.symbol, this.symbol, "rect");
                ne = this.markerAttribs(w, w.selected && "select"), this.enabledDataSorting && (w.startXPos = re.reversed ? -(ne.width || 0) : re.width);
                let de = w.isInside !== !1;
                if (!H && de && ((ne.width || 0) > 0 || w.hasImage) && (w.graphic = H = he.renderer.symbol(be, ne.x, ne.y, ne.width, ne.height, ae ? ee : Z).add(V), this.enabledDataSorting && he.hasRendered && (H.attr({ x: w.startXPos }), U = "animate")), H && U === "animate" && H[de ? "show" : "hide"](de).animate(ne), H) {
                  let ge = this.pointAttribs(w, me || !w.selected ? void 0 : "select");
                  me ? ve && H.css({ fill: ge.fill }) : H[U](ge);
                }
                H && H.addClass(w.getClassName(), !0);
              } else
                H && (w.graphic = H.destroy());
        }
        markerAttribs(f, L) {
          let w = this.options, H = w.marker, U = f.marker || {}, ee = U.symbol || H.symbol, ae = {}, ne, he, me = te(U.radius, H && H.radius);
          L && (ne = H.states[L], me = te((he = U.states && U.states[L]) && he.radius, ne && ne.radius, me && me + (ne && ne.radiusPlus || 0))), f.hasImage = ee && ee.indexOf("url") === 0, f.hasImage && (me = 0);
          let ve = f.pos();
          return x(me) && ve && (ae.x = ve[0] - me, ae.y = ve[1] - me, w.crisp && (ae.x = Math.floor(ae.x))), me && (ae.width = ae.height = 2 * me), ae;
        }
        pointAttribs(f, L) {
          let w = this.options.marker, H = f && f.options, U = H && H.marker || {}, ee = H && H.color, ae = f && f.color, ne = f && f.zone && f.zone.color, he, me, ve = this.color, Me, Z, V = te(U.lineWidth, w.lineWidth), re = 1;
          return ve = ee || ne || ae || ve, Me = U.fillColor || w.fillColor || ve, Z = U.lineColor || w.lineColor || ve, L = L || "normal", he = w.states[L] || {}, V = te((me = U.states && U.states[L] || {}).lineWidth, he.lineWidth, V + te(me.lineWidthPlus, he.lineWidthPlus, 0)), Me = me.fillColor || he.fillColor || Me, { stroke: Z = me.lineColor || he.lineColor || Z, "stroke-width": V, fill: Me, opacity: re = te(me.opacity, he.opacity, re) };
        }
        destroy(f) {
          let L, w, H, U = this, ee = U.chart, ae = /AppleWebKit\/533/.test(C.navigator.userAgent), ne = U.data || [];
          for (c(U, "destroy", { keepEventsForUpdate: f }), this.removeEvents(f), (U.axisTypes || []).forEach(function(he) {
            (H = U[he]) && H.series && (h(H.series, U), H.isDirty = H.forceRedraw = !0);
          }), U.legendItem && U.chart.legend.destroyItem(U), L = ne.length; L--; )
            (w = ne[L]) && w.destroy && w.destroy();
          for (let he of U.zones)
            z(he, void 0, !0);
          O.clearTimeout(U.animationTimeout), ie(U, function(he, me) {
            he instanceof B && !he.survive && he[ae && me === "group" ? "hide" : "destroy"]();
          }), ee.hoverSeries === U && (ee.hoverSeries = void 0), h(ee.series, U), ee.orderItems("series"), ie(U, function(he, me) {
            f && me === "hcEvents" || delete U[me];
          });
        }
        applyZones() {
          let { area: f, chart: L, graph: w, zones: H, points: U, xAxis: ee, yAxis: ae, zoneAxis: ne } = this, { inverted: he, renderer: me } = L, ve = this[`${ne}Axis`], { isXAxis: Me, len: Z = 0 } = ve || {}, V = ((w == null ? void 0 : w.strokeWidth()) || 0) / 2 + 1, re = (le, be = 0, de = 0) => {
            he && (de = Z - de);
            let { translated: ge = 0, lineClip: fe } = le, ke = de - ge;
            fe == null || fe.push(["L", be, Math.abs(ke) < V ? de - V * (ke <= 0 ? -1 : 1) : ge]);
          };
          if (H.length && (w || f) && ve && x(ve.min)) {
            let le = ve.getExtremes().max, be = (fe) => {
              fe.forEach((ke, Pe) => {
                (ke[0] === "M" || ke[0] === "L") && (fe[Pe] = [ke[0], Me ? Z - ke[1] : ke[1], Me ? ke[2] : Z - ke[2]]);
              });
            };
            if (H.forEach((fe) => {
              fe.lineClip = [], fe.translated = R(ve.toPixels(te(fe.value, le), !0) || 0, 0, Z);
            }), w && !this.showLine && w.hide(), f && f.hide(), ne === "y" && U.length < ee.len)
              for (let fe of U) {
                let { plotX: ke, plotY: Pe, zone: Ae } = fe, Le = Ae && H[H.indexOf(Ae) - 1];
                Ae && re(Ae, ke, Pe), Le && re(Le, ke, Pe);
              }
            let de = [], ge = ve.toPixels(ve.getExtremes().min, !0);
            H.forEach((fe) => {
              var Ze, ut;
              let ke = fe.lineClip || [], Pe = Math.round(fe.translated || 0);
              ee.reversed && ke.reverse();
              let { clip: Ae, simpleClip: Le } = fe, Ee = 0, Ye = 0, We = ee.len, Ne = ae.len;
              Me ? (Ee = Pe, We = ge) : (Ye = Pe, Ne = ge);
              let Xe = [["M", Ee, Ye], ["L", We, Ye], ["L", We, Ne], ["L", Ee, Ne], ["Z"]], et = [Xe[0], ...ke, Xe[1], Xe[2], ...de, Xe[3], Xe[4]];
              de = ke.reverse(), ge = Pe, he && (be(et), f && be(Xe)), Ae ? (Ae.animate({ d: et }), Le == null || Le.animate({ d: Xe })) : (Ae = fe.clip = me.path(et), f && (Le = fe.simpleClip = me.path(Xe))), w && ((Ze = fe.graph) == null || Ze.clip(Ae)), f && ((ut = fe.area) == null || ut.clip(Le));
            });
          } else
            this.visible && (w && w.show(), f && f.show());
        }
        plotGroup(f, L, w, H, U) {
          let ee = this[f], ae = !ee, ne = { visibility: w, zIndex: H || 0.1 };
          return I(this.opacity) && !this.chart.styledMode && this.state !== "inactive" && (ne.opacity = this.opacity), ee || (this[f] = ee = this.chart.renderer.g().add(U)), ee.addClass("highcharts-" + L + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (I(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (ee.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), !0), ee.attr(ne)[ae ? "attr" : "animate"](this.getPlotBox(L)), ee;
        }
        getPlotBox(f) {
          let L = this.xAxis, w = this.yAxis, H = this.chart, U = H.inverted && !H.polar && L && this.invertible && f === "series";
          return H.inverted && (L = w, w = this.xAxis), { translateX: L ? L.left : H.plotLeft, translateY: w ? w.top : H.plotTop, rotation: U ? 90 : 0, rotationOriginX: U ? (L.len - w.len) / 2 : 0, rotationOriginY: U ? (L.len + w.len) / 2 : 0, scaleX: U ? -1 : 1, scaleY: 1 };
        }
        removeEvents(f) {
          let { eventsToUnbind: L } = this;
          f || $(this), L.length && (L.forEach((w) => {
            w();
          }), L.length = 0);
        }
        render() {
          var me, ve, Me, Z, V;
          let f = this, { chart: L, options: w, hasRendered: H } = f, U = b(w.animation), ee = f.visible ? "inherit" : "hidden", ae = w.zIndex, ne = L.seriesGroup, he = f.finishedAnimating ? 0 : U.duration;
          c(this, "render"), f.plotGroup("group", "series", ee, ae, ne), f.markerGroup = f.plotGroup("markerGroup", "markers", ee, ae, ne), w.clip !== !1 && f.setClip(), he && ((me = f.animate) == null || me.call(f, !0)), f.drawGraph && (f.drawGraph(), f.applyZones()), f.visible && f.drawPoints(), (ve = f.drawDataLabels) == null || ve.call(f), (Me = f.redrawPoints) == null || Me.call(f), w.enableMouseTracking && ((Z = f.drawTracker) == null || Z.call(f)), he && ((V = f.animate) == null || V.call(f)), H || (he && U.defer && (he += U.defer), f.animationTimeout = p(() => {
            f.afterAnimate();
          }, he || 0)), f.isDirty = !1, f.hasRendered = !0, c(f, "afterRender");
        }
        redraw() {
          let f = this.isDirty || this.isDirtyData;
          this.translate(), this.render(), f && delete this.kdTree;
        }
        reserveSpace() {
          return this.visible || !this.chart.options.chart.ignoreHiddenSeries;
        }
        searchPoint(f, L) {
          let { xAxis: w, yAxis: H } = this, U = this.chart.inverted;
          return this.searchKDTree({ clientX: U ? w.len - f.chartY + w.pos : f.chartX - w.pos, plotY: U ? H.len - f.chartX + H.pos : f.chartY - H.pos }, L, f);
        }
        buildKDTree(f) {
          this.buildingKdTree = !0;
          let L = this, w = L.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
          delete L.kdTree, p(function() {
            L.kdTree = function H(U, ee, ae) {
              let ne, he, me = U == null ? void 0 : U.length;
              if (me)
                return ne = L.kdAxisArray[ee % ae], U.sort((ve, Me) => (ve[ne] || 0) - (Me[ne] || 0)), { point: U[he = Math.floor(me / 2)], left: H(U.slice(0, he), ee + 1, ae), right: H(U.slice(he + 1), ee + 1, ae) };
            }(L.getValidPoints(void 0, !L.directTouch), w, w), L.buildingKdTree = !1;
          }, L.options.kdNow || (f == null ? void 0 : f.type) === "touchstart" ? 0 : 1);
        }
        searchKDTree(f, L, w) {
          let H = this, [U, ee] = this.kdAxisArray, ae = L ? "distX" : "dist", ne = (H.options.findNearestPointBy || "").indexOf("y") > -1 ? 2 : 1, he = !!H.isBubble;
          if (this.kdTree || this.buildingKdTree || this.buildKDTree(w), this.kdTree)
            return function me(ve, Me, Z, V) {
              var Ae;
              let re = Me.point, le = H.kdAxisArray[Z % V], be, de, ge = re;
              (function(Le, Ee) {
                var it;
                let Ye = Le[U], We = Ee[U], Ne = I(Ye) && I(We) ? Ye - We : null, Xe = Le[ee], et = Ee[ee], Ze = I(Xe) && I(et) ? Xe - et : 0, ut = he && ((it = Ee.marker) == null ? void 0 : it.radius) || 0;
                Ee.dist = Math.sqrt((Ne && Ne * Ne || 0) + Ze * Ze) - ut, Ee.distX = I(Ne) ? Math.abs(Ne) - ut : Number.MAX_VALUE;
              })(ve, re);
              let fe = (ve[le] || 0) - (re[le] || 0) + (he && ((Ae = re.marker) == null ? void 0 : Ae.radius) || 0), ke = fe < 0 ? "left" : "right", Pe = fe < 0 ? "right" : "left";
              return Me[ke] && (ge = (be = me(ve, Me[ke], Z + 1, V))[ae] < ge[ae] ? be : re), Me[Pe] && Math.sqrt(fe * fe) < ge[ae] && (ge = (de = me(ve, Me[Pe], Z + 1, V))[ae] < ge[ae] ? de : ge), ge;
            }(f, this.kdTree, ne, ne);
        }
        pointPlacementToXValue() {
          let { options: f, xAxis: L } = this, w = f.pointPlacement;
          return w === "between" && (w = L.reversed ? -0.5 : 0.5), x(w) ? w * (f.pointRange || L.pointRange) : 0;
        }
        isPointInside(f) {
          let { chart: L, xAxis: w, yAxis: H } = this, { plotX: U = -1, plotY: ee = -1 } = f;
          return ee >= 0 && ee <= (H ? H.len : L.plotHeight) && U >= 0 && U <= (w ? w.len : L.plotWidth);
        }
        drawTracker() {
          var Me;
          let f = this, L = f.options, w = L.trackByArea, H = [].concat((w ? f.areaPath : f.graphPath) || []), U = f.chart, ee = U.pointer, ae = U.renderer, ne = ((Me = U.options.tooltip) == null ? void 0 : Me.snap) || 0, he = () => {
            L.enableMouseTracking && U.hoverSeries !== f && f.onMouseOver();
          }, me = "rgba(192,192,192," + (g ? 1e-4 : 2e-3) + ")", ve = f.tracker;
          ve ? ve.attr({ d: H }) : f.graph && (f.tracker = ve = ae.path(H).attr({ visibility: f.visible ? "inherit" : "hidden", zIndex: 2 }).addClass(w ? "highcharts-tracker-area" : "highcharts-tracker-line").add(f.group), U.styledMode || ve.attr({ "stroke-linecap": "round", "stroke-linejoin": "round", stroke: me, fill: w ? me : "none", "stroke-width": f.graph.strokeWidth() + (w ? 0 : 2 * ne) }), [f.tracker, f.markerGroup, f.dataLabelsGroup].forEach((Z) => {
            Z && (Z.addClass("highcharts-tracker").on("mouseover", he).on("mouseout", (V) => {
              ee == null || ee.onTrackerMouseOut(V);
            }), L.cursor && !U.styledMode && Z.css({ cursor: L.cursor }), Z.on("touchstart", he));
          })), c(this, "afterDrawTracker");
        }
        addPoint(f, L, w, H, U) {
          let ee, ae, ne = this.options, he = this.data, me = this.chart, ve = this.xAxis, Me = ve && ve.hasNames && ve.names, Z = ne.data, V = this.xData;
          L = te(L, !0);
          let re = { series: this };
          this.pointClass.prototype.applyOptions.apply(re, [f]);
          let le = re.x;
          if (ae = V.length, this.requireSorting && le < V[ae - 1])
            for (ee = !0; ae && V[ae - 1] > le; )
              ae--;
          this.updateParallelArrays(re, "splice", [ae, 0, 0]), this.updateParallelArrays(re, ae), Me && re.name && (Me[le] = re.name), Z.splice(ae, 0, f), (ee || this.processedData) && (this.data.splice(ae, 0, null), this.processData()), ne.legendType === "point" && this.generatePoints(), w && (he[0] && he[0].remove ? he[0].remove(!1) : (he.shift(), this.updateParallelArrays(re, "shift"), Z.shift())), U !== !1 && c(this, "addPoint", { point: re }), this.isDirty = !0, this.isDirtyData = !0, L && me.redraw(H);
        }
        removePoint(f, L, w) {
          let H = this, U = H.data, ee = U[f], ae = H.points, ne = H.chart, he = function() {
            ae && ae.length === U.length && ae.splice(f, 1), U.splice(f, 1), H.options.data.splice(f, 1), H.updateParallelArrays(ee || { series: H }, "splice", [f, 1]), ee && ee.destroy(), H.isDirty = !0, H.isDirtyData = !0, L && ne.redraw();
          };
          v(w, ne), L = te(L, !0), ee ? ee.firePointEvent("remove", null, he) : he();
        }
        remove(f, L, w, H) {
          let U = this, ee = U.chart;
          function ae() {
            U.destroy(H), ee.isDirtyLegend = ee.isDirtyBox = !0, ee.linkSeries(H), te(f, !0) && ee.redraw(L);
          }
          w !== !1 ? c(U, "remove", null, ae) : ae();
        }
        update(f, L) {
          var be, de, ge;
          c(this, "update", { options: f = k(f, this.userOptions) });
          let w = this, H = w.chart, U = w.userOptions, ee = w.initialType || w.type, ae = H.options.plotOptions, ne = j[ee].prototype, he = w.finishedAnimating && { animation: !1 }, me = {}, ve, Me, Z = ["colorIndex", "eventOptions", "navigatorSeries", "symbolIndex", "baseSeries"], V = f.type || U.type || H.options.chart.type, re = !(this.hasDerivedData || V && V !== this.type || f.pointStart !== void 0 || f.pointInterval !== void 0 || f.relativeXValue !== void 0 || f.joinBy || f.mapData || ["dataGrouping", "pointStart", "pointInterval", "pointIntervalUnit", "keys"].some((fe) => w.hasOptionChanged(fe)));
          V = V || ee, re && (Z.push("data", "isDirtyData", "isDirtyCanvas", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "hasDataLabels", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX", "transformGroups"), f.visible !== !1 && Z.push("area", "graph"), w.parallelArrays.forEach(function(fe) {
            Z.push(fe + "Data");
          }), f.data && (f.dataSorting && o(w.options.dataSorting, f.dataSorting), this.setData(f.data, !1))), f = J(U, { index: U.index === void 0 ? w.index : U.index, pointStart: ((be = ae == null ? void 0 : ae.series) == null ? void 0 : be.pointStart) ?? U.pointStart ?? ((de = w.xData) == null ? void 0 : de[0]) }, !re && { data: w.options.data }, f, he), re && f.data && (f.data = w.options.data), (Z = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(Z)).forEach(function(fe) {
            Z[fe] = w[fe], delete w[fe];
          });
          let le = !1;
          if (j[V]) {
            if (le = V !== w.type, w.remove(!1, !1, !1, !0), le)
              if (H.propFromSeries(), Object.setPrototypeOf)
                Object.setPrototypeOf(w, j[V].prototype);
              else {
                let fe = Object.hasOwnProperty.call(w, "hcEvents") && w.hcEvents;
                for (Me in ne)
                  w[Me] = void 0;
                o(w, j[V].prototype), fe ? w.hcEvents = fe : delete w.hcEvents;
              }
          } else
            F(17, !0, H, { missingModuleFor: V });
          if (Z.forEach(function(fe) {
            w[fe] = Z[fe];
          }), w.init(H, f), re && this.points)
            for (let fe of ((ve = w.options).visible === !1 ? (me.graphic = 1, me.dataLabel = 1) : (this.hasMarkerChanged(ve, U) && (me.graphic = 1), (ge = w.hasDataLabels) != null && ge.call(w) || (me.dataLabel = 1)), this.points))
              fe && fe.series && (fe.resolveColor(), Object.keys(me).length && fe.destroyElements(me), ve.showInLegend === !1 && fe.legendItem && H.legend.destroyItem(fe));
          w.initialType = ee, H.linkSeries(), H.setSortedData(), le && w.linkedSeries.length && (w.isDirtyData = !0), c(this, "afterUpdate"), te(L, !0) && H.redraw(!!re && void 0);
        }
        setName(f) {
          this.name = this.options.name = this.userOptions.name = f, this.chart.isDirtyLegend = !0;
        }
        hasOptionChanged(f) {
          var ae, ne;
          let L = this.chart, w = this.options[f], H = L.options.plotOptions, U = this.userOptions[f], ee = te((ae = H == null ? void 0 : H[this.type]) == null ? void 0 : ae[f], (ne = H == null ? void 0 : H.series) == null ? void 0 : ne[f]);
          return U && !I(ee) ? w !== U : w !== te(ee, w);
        }
        onMouseOver() {
          let f = this.chart, L = f.hoverSeries, w = f.pointer;
          w == null || w.setHoverChartIndex(), L && L !== this && L.onMouseOut(), this.options.events.mouseOver && c(this, "mouseOver"), this.setState("hover"), f.hoverSeries = this;
        }
        onMouseOut() {
          let f = this.options, L = this.chart, w = L.tooltip, H = L.hoverPoint;
          L.hoverSeries = null, H && H.onMouseOut(), this && f.events.mouseOut && c(this, "mouseOut"), w && !this.stickyTracking && (!w.shared || this.noSharedTooltip) && w.hide(), L.series.forEach(function(U) {
            U.setState("", !0);
          });
        }
        setState(f, L) {
          let w = this, H = w.options, U = w.graph, ee = H.inactiveOtherPoints, ae = H.states, ne = te(ae[f || "normal"] && ae[f || "normal"].animation, w.chart.options.chart.animation), he = H.lineWidth, me = H.opacity;
          if (f = f || "", w.state !== f && ([w.group, w.markerGroup, w.dataLabelsGroup].forEach(function(ve) {
            ve && (w.state && ve.removeClass("highcharts-series-" + w.state), f && ve.addClass("highcharts-series-" + f));
          }), w.state = f, !w.chart.styledMode)) {
            if (ae[f] && ae[f].enabled === !1)
              return;
            if (f && (he = ae[f].lineWidth || he + (ae[f].lineWidthPlus || 0), me = te(ae[f].opacity, me)), U && !U.dashstyle && x(he))
              for (let ve of [U, ...this.zones.map((Me) => Me.graph)])
                ve == null || ve.animate({ "stroke-width": he }, ne);
            ee || [w.group, w.markerGroup, w.dataLabelsGroup, w.labelBySeries].forEach(function(ve) {
              ve && ve.animate({ opacity: me }, ne);
            });
          }
          L && ee && w.points && w.setAllPointsToState(f || void 0);
        }
        setAllPointsToState(f) {
          this.points.forEach(function(L) {
            L.setState && L.setState(f);
          });
        }
        setVisible(f, L) {
          var ne;
          let w = this, H = w.chart, U = H.options.chart.ignoreHiddenSeries, ee = w.visible;
          w.visible = f = w.options.visible = w.userOptions.visible = f === void 0 ? !ee : f;
          let ae = f ? "show" : "hide";
          ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach((he) => {
            var me;
            (me = w[he]) == null || me[ae]();
          }), (H.hoverSeries === w || ((ne = H.hoverPoint) == null ? void 0 : ne.series) === w) && w.onMouseOut(), w.legendItem && H.legend.colorizeItem(w, f), w.isDirty = !0, w.options.stacking && H.series.forEach((he) => {
            he.options.stacking && he.visible && (he.isDirty = !0);
          }), w.linkedSeries.forEach((he) => {
            he.setVisible(f, !1);
          }), U && (H.isDirtyBox = !0), c(w, ae), L !== !1 && H.redraw();
        }
        show() {
          this.setVisible(!0);
        }
        hide() {
          this.setVisible(!1);
        }
        select(f) {
          this.selected = f = this.options.selected = f === void 0 ? !this.selected : f, this.checkbox && (this.checkbox.checked = f), c(this, f ? "select" : "unselect");
        }
        shouldShowTooltip(f, L, w = {}) {
          return w.series = this, w.visiblePlotOnly = !0, this.chart.isInsidePlot(f, L, w);
        }
        drawLegendSymbol(f, L) {
          var w;
          (w = A[this.options.legendSymbol || "rectangle"]) == null || w.call(this, f, L);
        }
      }
      return W.defaultOptions = q, W.types = T.seriesTypes, W.registerType = T.registerSeriesType, o(W.prototype, { axisTypes: ["xAxis", "yAxis"], coll: "series", colorCounter: 0, directTouch: !1, invertible: !0, isCartesian: !0, kdAxisArray: ["clientX", "plotY"], parallelArrays: ["x", "y"], pointClass: Y, requireSorting: !0, sorted: !0 }), T.series = W, W;
    }), i(e, "Core/Chart/Chart.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Axis/Axis.js"], e["Core/Defaults.js"], e["Core/Templating.js"], e["Core/Foundation.js"], e["Core/Globals.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Time.js"], e["Core/Utilities.js"], e["Core/Renderer/HTML/AST.js"], e["Core/Axis/Tick.js"]], function(n, s, l, m, A, Y, q, T, B, O, b, v, E, M) {
      let { animate: g, animObject: C, setAnimation: j } = n, { defaultOptions: D, defaultTime: u } = l, { numberFormat: R } = m, { registerEventOptions: K } = A, { charts: I, doc: z, marginNames: k, svg: h, win: F } = Y, { seriesTypes: o } = B, { addEvent: a, attr: c, createElement: d, css: S, defined: P, diffObjects: G, discardElement: x, erase: Q, error: J, extend: ie, find: te, fireEvent: $, getStyle: oe, isArray: p, isNumber: W, isObject: X, isString: f, merge: L, objectEach: w, pick: H, pInt: U, relativeLength: ee, removeEvent: ae, splat: ne, syncTimeout: he, uniqueKey: me } = v;
      class ve {
        static chart(Z, V, re) {
          return new ve(Z, V, re);
        }
        constructor(Z, V, re) {
          this.sharedClips = {};
          let le = [...arguments];
          (f(Z) || Z.nodeName) && (this.renderTo = le.shift()), this.init(le[0], le[1]);
        }
        setZoomOptions() {
          let Z = this.options.chart, V = Z.zooming;
          this.zooming = { ...V, type: H(Z.zoomType, V.type), key: H(Z.zoomKey, V.key), pinchType: H(Z.pinchType, V.pinchType), singleTouch: H(Z.zoomBySingleTouch, V.singleTouch, !1), resetButton: L(V.resetButton, Z.resetZoomButton) };
        }
        init(Z, V) {
          $(this, "init", { args: arguments }, function() {
            let re = L(D, Z), le = re.chart;
            this.userOptions = ie({}, Z), this.margin = [], this.spacing = [], this.labelCollectors = [], this.callback = V, this.isResizing = 0, this.options = re, this.axes = [], this.series = [], this.time = Z.time && Object.keys(Z.time).length ? new b(Z.time) : Y.time, this.numberFormatter = le.numberFormatter || R, this.styledMode = le.styledMode, this.hasCartesianSeries = le.showAxes, this.index = I.length, I.push(this), Y.chartCount++, K(this, le), this.xAxis = [], this.yAxis = [], this.pointCount = this.colorCounter = this.symbolCounter = 0, this.setZoomOptions(), $(this, "afterInit"), this.firstRender();
          });
        }
        initSeries(Z) {
          let V = this.options.chart, re = Z.type || V.type, le = o[re];
          le || J(17, !0, this, { missingModuleFor: re });
          let be = new le();
          return typeof be.init == "function" && be.init(this, Z), be;
        }
        setSortedData() {
          this.getSeriesOrderByLinks().forEach(function(Z) {
            Z.points || Z.data || !Z.enabledDataSorting || Z.setData(Z.options.data, !1);
          });
        }
        getSeriesOrderByLinks() {
          return this.series.concat().sort(function(Z, V) {
            return Z.linkedSeries.length || V.linkedSeries.length ? V.linkedSeries.length - Z.linkedSeries.length : 0;
          });
        }
        orderItems(Z, V = 0) {
          let re = this[Z], le = this.options[Z] = ne(this.options[Z]).slice(), be = this.userOptions[Z] = this.userOptions[Z] ? ne(this.userOptions[Z]).slice() : [];
          if (this.hasRendered && (le.splice(V), be.splice(V)), re)
            for (let de = V, ge = re.length; de < ge; ++de) {
              let fe = re[de];
              fe && (fe.index = de, fe instanceof T && (fe.name = fe.getName()), fe.options.isInternal || (le[de] = fe.options, be[de] = fe.userOptions));
            }
        }
        isInsidePlot(Z, V, re = {}) {
          var Ne;
          let { inverted: le, plotBox: be, plotLeft: de, plotTop: ge, scrollablePlotBox: fe } = this, { scrollLeft: ke = 0, scrollTop: Pe = 0 } = re.visiblePlotOnly && ((Ne = this.scrollablePlotArea) == null ? void 0 : Ne.scrollingContainer) || {}, Ae = re.series, Le = re.visiblePlotOnly && fe || be, Ee = re.inverted ? V : Z, Ye = re.inverted ? Z : V, We = { x: Ee, y: Ye, isInsidePlot: !0, options: re };
          if (!re.ignoreX) {
            let Xe = Ae && (le && !this.polar ? Ae.yAxis : Ae.xAxis) || { pos: de, len: 1 / 0 }, et = re.paneCoordinates ? Xe.pos + Ee : de + Ee;
            et >= Math.max(ke + de, Xe.pos) && et <= Math.min(ke + de + Le.width, Xe.pos + Xe.len) || (We.isInsidePlot = !1);
          }
          if (!re.ignoreY && We.isInsidePlot) {
            let Xe = !le && re.axis && !re.axis.isXAxis && re.axis || Ae && (le ? Ae.xAxis : Ae.yAxis) || { pos: ge, len: 1 / 0 }, et = re.paneCoordinates ? Xe.pos + Ye : ge + Ye;
            et >= Math.max(Pe + ge, Xe.pos) && et <= Math.min(Pe + ge + Le.height, Xe.pos + Xe.len) || (We.isInsidePlot = !1);
          }
          return $(this, "afterIsInsidePlot", We), We.isInsidePlot;
        }
        redraw(Z) {
          $(this, "beforeRedraw");
          let V = this.hasCartesianSeries ? this.axes : this.colorAxis || [], re = this.series, le = this.pointer, be = this.legend, de = this.userOptions.legend, ge = this.renderer, fe = ge.isHidden(), ke = [], Pe, Ae, Le, Ee = this.isDirtyBox, Ye = this.isDirtyLegend, We;
          for (ge.rootFontSize = ge.boxWrapper.getStyle("font-size"), this.setResponsive && this.setResponsive(!1), j(!!this.hasRendered && Z, this), fe && this.temporaryDisplay(), this.layOutTitles(!1), Le = re.length; Le--; )
            if (((We = re[Le]).options.stacking || We.options.centerInCategory) && (Ae = !0, We.isDirty)) {
              Pe = !0;
              break;
            }
          if (Pe)
            for (Le = re.length; Le--; )
              (We = re[Le]).options.stacking && (We.isDirty = !0);
          re.forEach(function(Ne) {
            Ne.isDirty && (Ne.options.legendType === "point" ? (typeof Ne.updateTotals == "function" && Ne.updateTotals(), Ye = !0) : de && (de.labelFormatter || de.labelFormat) && (Ye = !0)), Ne.isDirtyData && $(Ne, "updatedData");
          }), Ye && be && be.options.enabled && (be.render(), this.isDirtyLegend = !1), Ae && this.getStacks(), V.forEach(function(Ne) {
            Ne.updateNames(), Ne.setScale();
          }), this.getMargins(), V.forEach(function(Ne) {
            Ne.isDirty && (Ee = !0);
          }), V.forEach(function(Ne) {
            let Xe = Ne.min + "," + Ne.max;
            Ne.extKey !== Xe && (Ne.extKey = Xe, ke.push(function() {
              $(Ne, "afterSetExtremes", ie(Ne.eventArgs, Ne.getExtremes())), delete Ne.eventArgs;
            })), (Ee || Ae) && Ne.redraw();
          }), Ee && this.drawChartBox(), $(this, "predraw"), re.forEach(function(Ne) {
            (Ee || Ne.isDirty) && Ne.visible && Ne.redraw(), Ne.isDirtyData = !1;
          }), le && le.reset(!0), ge.draw(), $(this, "redraw"), $(this, "render"), fe && this.temporaryDisplay(!0), ke.forEach(function(Ne) {
            Ne.call();
          });
        }
        get(Z) {
          let V = this.series;
          function re(be) {
            return be.id === Z || be.options && be.options.id === Z;
          }
          let le = te(this.axes, re) || te(this.series, re);
          for (let be = 0; !le && be < V.length; be++)
            le = te(V[be].points || [], re);
          return le;
        }
        getAxes() {
          let Z = this.userOptions;
          for (let V of ($(this, "getAxes"), ["xAxis", "yAxis"]))
            for (let re of Z[V] = ne(Z[V] || {}))
              new s(this, re, V);
          $(this, "afterGetAxes");
        }
        getSelectedPoints() {
          return this.series.reduce((Z, V) => (V.getPointsCollection().forEach((re) => {
            H(re.selectedStaging, re.selected) && Z.push(re);
          }), Z), []);
        }
        getSelectedSeries() {
          return this.series.filter(function(Z) {
            return Z.selected;
          });
        }
        setTitle(Z, V, re) {
          this.applyDescription("title", Z), this.applyDescription("subtitle", V), this.applyDescription("caption", void 0), this.layOutTitles(re);
        }
        applyDescription(Z, V) {
          let re = this, le = this.options[Z] = L(this.options[Z], V), be = this[Z];
          be && V && (this[Z] = be = be.destroy()), le && !be && ((be = this.renderer.text(le.text, 0, 0, le.useHTML).attr({ align: le.align, class: "highcharts-" + Z, zIndex: le.zIndex || 4 }).add()).update = function(de, ge) {
            re.applyDescription(Z, de), re.layOutTitles(ge);
          }, this.styledMode || be.css(ie(Z === "title" ? { fontSize: this.options.isStock ? "1em" : "1.2em" } : {}, le.style)), this[Z] = be);
        }
        layOutTitles(Z = !0) {
          let V = [0, 0, 0], re = this.renderer, le = this.spacingBox;
          ["title", "subtitle", "caption"].forEach(function(de) {
            let ge = this[de], fe = this.options[de], ke = fe.verticalAlign || "top", Pe = de === "title" ? ke === "top" ? -3 : 0 : ke === "top" ? V[0] + 2 : 0;
            if (ge) {
              ge.css({ width: (fe.width || le.width + (fe.widthAdjust || 0)) + "px" });
              let Ae = re.fontMetrics(ge).b, Le = Math.round(ge.getBBox(fe.useHTML).height);
              ge.align(ie({ y: ke === "bottom" ? Ae : Pe + Ae, height: Le }, fe), !1, "spacingBox"), fe.floating || (ke === "top" ? V[0] = Math.ceil(V[0] + Le) : ke === "bottom" && (V[2] = Math.ceil(V[2] + Le)));
            }
          }, this), V[0] && (this.options.title.verticalAlign || "top") === "top" && (V[0] += this.options.title.margin), V[2] && this.options.caption.verticalAlign === "bottom" && (V[2] += this.options.caption.margin);
          let be = !this.titleOffset || this.titleOffset.join(",") !== V.join(",");
          this.titleOffset = V, $(this, "afterLayOutTitles"), !this.isDirtyBox && be && (this.isDirtyBox = this.isDirtyLegend = be, this.hasRendered && Z && this.isDirtyBox && this.redraw());
        }
        getContainerBox() {
          return { width: oe(this.renderTo, "width", !0) || 0, height: oe(this.renderTo, "height", !0) || 0 };
        }
        getChartSize() {
          let Z = this.options.chart, V = Z.width, re = Z.height, le = this.getContainerBox();
          this.chartWidth = Math.max(0, V || le.width || 600), this.chartHeight = Math.max(0, ee(re, this.chartWidth) || (le.height > 1 ? le.height : 400)), this.containerBox = le;
        }
        temporaryDisplay(Z) {
          let V = this.renderTo, re;
          if (Z)
            for (; V && V.style; )
              V.hcOrigStyle && (S(V, V.hcOrigStyle), delete V.hcOrigStyle), V.hcOrigDetached && (z.body.removeChild(V), V.hcOrigDetached = !1), V = V.parentNode;
          else
            for (; V && V.style && (z.body.contains(V) || V.parentNode || (V.hcOrigDetached = !0, z.body.appendChild(V)), (oe(V, "display", !1) === "none" || V.hcOricDetached) && (V.hcOrigStyle = { display: V.style.display, height: V.style.height, overflow: V.style.overflow }, re = { display: "block", overflow: "hidden" }, V !== this.renderTo && (re.height = 0), S(V, re), V.offsetWidth || V.style.setProperty("display", "block", "important")), (V = V.parentNode) !== z.body); )
              ;
        }
        setClassName(Z) {
          this.container.className = "highcharts-container " + (Z || "");
        }
        getContainer() {
          var Le;
          let Z = this.options, V = Z.chart, re = "data-highcharts-chart", le = me(), be, de = this.renderTo;
          de || (this.renderTo = de = V.renderTo), f(de) && (this.renderTo = de = z.getElementById(de)), de || J(13, !0, this);
          let ge = U(c(de, re));
          W(ge) && I[ge] && I[ge].hasRendered && I[ge].destroy(), c(de, re, this.index), de.innerHTML = E.emptyHTML, V.skipClone || de.offsetWidth || this.temporaryDisplay(), this.getChartSize();
          let fe = this.chartHeight, ke = this.chartWidth;
          S(de, { overflow: "hidden" }), this.styledMode || (be = ie({ position: "relative", overflow: "hidden", width: ke + "px", height: fe + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)", userSelect: "none", "touch-action": "manipulation", outline: "none" }, V.style || {}));
          let Pe = d("div", { id: le }, be, de);
          this.container = Pe, this.getChartSize(), ke === this.chartWidth || (ke = this.chartWidth, this.styledMode || S(Pe, { width: H((Le = V.style) == null ? void 0 : Le.width, ke + "px") })), this.containerBox = this.getContainerBox(), this._cursor = Pe.style.cursor;
          let Ae = V.renderer || !h ? q.getRendererType(V.renderer) : O;
          if (this.renderer = new Ae(Pe, ke, fe, void 0, V.forExport, Z.exporting && Z.exporting.allowHTML, this.styledMode), j(void 0, this), this.setClassName(V.className), this.styledMode)
            for (let Ee in Z.defs)
              this.renderer.definition(Z.defs[Ee]);
          else
            this.renderer.setStyle(V.style);
          this.renderer.chartIndex = this.index, $(this, "afterGetContainer");
        }
        getMargins(Z) {
          let { spacing: V, margin: re, titleOffset: le } = this;
          this.resetMargins(), le[0] && !P(re[0]) && (this.plotTop = Math.max(this.plotTop, le[0] + V[0])), le[2] && !P(re[2]) && (this.marginBottom = Math.max(this.marginBottom, le[2] + V[2])), this.legend && this.legend.display && this.legend.adjustMargins(re, V), $(this, "getMargins"), Z || this.getAxisMargins();
        }
        getAxisMargins() {
          let Z = this, V = Z.axisOffset = [0, 0, 0, 0], re = Z.colorAxis, le = Z.margin, be = function(de) {
            de.forEach(function(ge) {
              ge.visible && ge.getOffset();
            });
          };
          Z.hasCartesianSeries ? be(Z.axes) : re && re.length && be(re), k.forEach(function(de, ge) {
            P(le[ge]) || (Z[de] += V[ge]);
          }), Z.setChartSize();
        }
        getOptions() {
          return G(this.userOptions, D);
        }
        reflow(Z) {
          var be;
          let V = this, re = V.containerBox, le = V.getContainerBox();
          (be = V.pointer) == null || delete be.chartPosition, !V.isPrinting && !V.isResizing && re && le.width && ((le.width !== re.width || le.height !== re.height) && (v.clearTimeout(V.reflowTimeout), V.reflowTimeout = he(function() {
            V.container && V.setSize(void 0, void 0, !1);
          }, Z ? 100 : 0)), V.containerBox = le);
        }
        setReflow() {
          let Z = this, V = (re) => {
            var le;
            (le = Z.options) != null && le.chart.reflow && Z.hasLoaded && Z.reflow(re);
          };
          if (typeof ResizeObserver == "function")
            new ResizeObserver(V).observe(Z.renderTo);
          else {
            let re = a(F, "resize", V);
            a(this, "destroy", re);
          }
        }
        setSize(Z, V, re) {
          let le = this, be = le.renderer;
          le.isResizing += 1, j(re, le);
          let de = be.globalAnimation;
          le.oldChartHeight = le.chartHeight, le.oldChartWidth = le.chartWidth, Z !== void 0 && (le.options.chart.width = Z), V !== void 0 && (le.options.chart.height = V), le.getChartSize();
          let { chartWidth: ge, chartHeight: fe, scrollablePixelsX: ke = 0, scrollablePixelsY: Pe = 0 } = le;
          (le.isDirtyBox || ge !== le.oldChartWidth || fe !== le.oldChartHeight) && (le.styledMode || (de ? g : S)(le.container, { width: `${ge + ke}px`, height: `${fe + Pe}px` }, de), le.setChartSize(!0), be.setSize(ge, fe, de), le.axes.forEach(function(Ae) {
            Ae.isDirty = !0, Ae.setScale();
          }), le.isDirtyLegend = !0, le.isDirtyBox = !0, le.layOutTitles(), le.getMargins(), le.redraw(de), le.oldChartHeight = void 0, $(le, "resize"), setTimeout(() => {
            le && $(le, "endResize");
          }, C(de).duration)), le.isResizing -= 1;
        }
        setChartSize(Z) {
          let V, re, le, be, de = this.inverted, ge = this.renderer, fe = this.chartWidth, ke = this.chartHeight, Pe = this.options.chart, Ae = this.spacing, Le = this.clipOffset;
          this.plotLeft = V = Math.round(this.plotLeft), this.plotTop = re = Math.round(this.plotTop), this.plotWidth = le = Math.max(0, Math.round(fe - V - this.marginRight)), this.plotHeight = be = Math.max(0, Math.round(ke - re - this.marginBottom)), this.plotSizeX = de ? be : le, this.plotSizeY = de ? le : be, this.plotBorderWidth = Pe.plotBorderWidth || 0, this.spacingBox = ge.spacingBox = { x: Ae[3], y: Ae[0], width: fe - Ae[3] - Ae[1], height: ke - Ae[0] - Ae[2] }, this.plotBox = ge.plotBox = { x: V, y: re, width: le, height: be };
          let Ee = 2 * Math.floor(this.plotBorderWidth / 2), Ye = Math.ceil(Math.max(Ee, Le[3]) / 2), We = Math.ceil(Math.max(Ee, Le[0]) / 2);
          this.clipBox = { x: Ye, y: We, width: Math.floor(this.plotSizeX - Math.max(Ee, Le[1]) / 2 - Ye), height: Math.max(0, Math.floor(this.plotSizeY - Math.max(Ee, Le[2]) / 2 - We)) }, Z || (this.axes.forEach(function(Ne) {
            Ne.setAxisSize(), Ne.setAxisTranslation();
          }), ge.alignElements()), $(this, "afterSetChartSize", { skipAxes: Z });
        }
        resetMargins() {
          $(this, "resetMargins");
          let Z = this, V = Z.options.chart;
          ["margin", "spacing"].forEach(function(re) {
            let le = V[re], be = X(le) ? le : [le, le, le, le];
            ["Top", "Right", "Bottom", "Left"].forEach(function(de, ge) {
              Z[re][ge] = H(V[re + de], be[ge]);
            });
          }), k.forEach(function(re, le) {
            Z[re] = H(Z.margin[le], Z.spacing[le]);
          }), Z.axisOffset = [0, 0, 0, 0], Z.clipOffset = [0, 0, 0, 0];
        }
        drawChartBox() {
          let Z = this.options.chart, V = this.renderer, re = this.chartWidth, le = this.chartHeight, be = this.styledMode, de = this.plotBGImage, ge = Z.backgroundColor, fe = Z.plotBackgroundColor, ke = Z.plotBackgroundImage, Pe = this.plotLeft, Ae = this.plotTop, Le = this.plotWidth, Ee = this.plotHeight, Ye = this.plotBox, We = this.clipRect, Ne = this.clipBox, Xe = this.chartBackground, et = this.plotBackground, Ze = this.plotBorder, ut, it, kt, ze = "animate";
          Xe || (this.chartBackground = Xe = V.rect().addClass("highcharts-background").add(), ze = "attr"), be ? ut = it = Xe.strokeWidth() : (it = (ut = Z.borderWidth || 0) + (Z.shadow ? 8 : 0), kt = { fill: ge || "none" }, (ut || Xe["stroke-width"]) && (kt.stroke = Z.borderColor, kt["stroke-width"] = ut), Xe.attr(kt).shadow(Z.shadow)), Xe[ze]({ x: it / 2, y: it / 2, width: re - it - ut % 2, height: le - it - ut % 2, r: Z.borderRadius }), ze = "animate", et || (ze = "attr", this.plotBackground = et = V.rect().addClass("highcharts-plot-background").add()), et[ze](Ye), !be && (et.attr({ fill: fe || "none" }).shadow(Z.plotShadow), ke && (de ? (ke !== de.attr("href") && de.attr("href", ke), de.animate(Ye)) : this.plotBGImage = V.image(ke, Pe, Ae, Le, Ee).add())), We ? We.animate({ width: Ne.width, height: Ne.height }) : this.clipRect = V.clipRect(Ne), ze = "animate", Ze || (ze = "attr", this.plotBorder = Ze = V.rect().addClass("highcharts-plot-border").attr({ zIndex: 1 }).add()), be || Ze.attr({ stroke: Z.plotBorderColor, "stroke-width": Z.plotBorderWidth || 0, fill: "none" }), Ze[ze](Ze.crisp({ x: Pe, y: Ae, width: Le, height: Ee }, -Ze.strokeWidth())), this.isDirtyBox = !1, $(this, "afterDrawChartBox");
        }
        propFromSeries() {
          let Z, V, re, le = this, be = le.options.chart, de = le.options.series;
          ["inverted", "angular", "polar"].forEach(function(ge) {
            for (V = o[be.type], re = be[ge] || V && V.prototype[ge], Z = de && de.length; !re && Z--; )
              (V = o[de[Z].type]) && V.prototype[ge] && (re = !0);
            le[ge] = re;
          });
        }
        linkSeries(Z) {
          let V = this, re = V.series;
          re.forEach(function(le) {
            le.linkedSeries.length = 0;
          }), re.forEach(function(le) {
            let { linkedTo: be } = le.options;
            if (f(be)) {
              let de;
              (de = be === ":previous" ? V.series[le.index - 1] : V.get(be)) && de.linkedParent !== le && (de.linkedSeries.push(le), le.linkedParent = de, de.enabledDataSorting && le.setDataSortingOptions(), le.visible = H(le.options.visible, de.options.visible, le.visible));
            }
          }), $(this, "afterLinkSeries", { isUpdating: Z });
        }
        renderSeries() {
          this.series.forEach(function(Z) {
            Z.translate(), Z.render();
          });
        }
        render() {
          var Pe;
          let Z = this.axes, V = this.colorAxis, re = this.renderer, le = this.options.chart.axisLayoutRuns || 2, be = (Ae) => {
            Ae.forEach((Le) => {
              Le.visible && Le.render();
            });
          }, de = 0, ge = !0, fe, ke = 0;
          for (let Ae of (this.setTitle(), $(this, "beforeMargins"), (Pe = this.getStacks) == null || Pe.call(this), this.getMargins(!0), this.setChartSize(), Z)) {
            let { options: Le } = Ae, { labels: Ee } = Le;
            if (Ae.horiz && Ae.visible && Ee.enabled && Ae.series.length && Ae.coll !== "colorAxis" && !this.polar) {
              de = Le.tickLength, Ae.createGroups();
              let Ye = new M(Ae, 0, "", !0), We = Ye.createLabel("x", Ee);
              if (Ye.destroy(), We && H(Ee.reserveSpace, !W(Le.crossing)) && (de = We.getBBox().height + Ee.distance + Math.max(Le.offset || 0, 0)), de) {
                We == null || We.destroy();
                break;
              }
            }
          }
          for (this.plotHeight = Math.max(this.plotHeight - de, 0); (ge || fe || le > 1) && ke < le; ) {
            let Ae = this.plotWidth, Le = this.plotHeight;
            for (let Ee of Z)
              ke === 0 ? Ee.setScale() : (Ee.horiz && ge || !Ee.horiz && fe) && Ee.setTickInterval(!0);
            ke === 0 ? this.getAxisMargins() : this.getMargins(), ge = Ae / this.plotWidth > (ke ? 1 : 1.1), fe = Le / this.plotHeight > (ke ? 1 : 1.05), ke++;
          }
          this.drawChartBox(), this.hasCartesianSeries ? be(Z) : V && V.length && be(V), this.seriesGroup || (this.seriesGroup = re.g("series-group").attr({ zIndex: 3 }).shadow(this.options.chart.seriesGroupShadow).add()), this.renderSeries(), this.addCredits(), this.setResponsive && this.setResponsive(), this.hasRendered = !0;
        }
        addCredits(Z) {
          let V = this, re = L(!0, this.options.credits, Z);
          re.enabled && !this.credits && (this.credits = this.renderer.text(re.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
            re.href && (F.location.href = re.href);
          }).attr({ align: re.position.align, zIndex: 8 }), V.styledMode || this.credits.css(re.style), this.credits.add().align(re.position), this.credits.update = function(le) {
            V.credits = V.credits.destroy(), V.addCredits(le);
          });
        }
        destroy() {
          let Z, V = this, re = V.axes, le = V.series, be = V.container, de = be && be.parentNode;
          for ($(V, "destroy"), V.renderer.forExport ? Q(I, V) : I[V.index] = void 0, Y.chartCount--, V.renderTo.removeAttribute("data-highcharts-chart"), ae(V), Z = re.length; Z--; )
            re[Z] = re[Z].destroy();
          for (this.scroller && this.scroller.destroy && this.scroller.destroy(), Z = le.length; Z--; )
            le[Z] = le[Z].destroy();
          ["title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer"].forEach(function(ge) {
            let fe = V[ge];
            fe && fe.destroy && (V[ge] = fe.destroy());
          }), be && (be.innerHTML = E.emptyHTML, ae(be), de && x(be)), w(V, function(ge, fe) {
            delete V[fe];
          });
        }
        firstRender() {
          var le;
          let Z = this, V = Z.options;
          Z.getContainer(), Z.resetMargins(), Z.setChartSize(), Z.propFromSeries(), Z.getAxes();
          let re = p(V.series) ? V.series : [];
          V.series = [], re.forEach(function(be) {
            Z.initSeries(be);
          }), Z.linkSeries(), Z.setSortedData(), $(Z, "beforeRender"), Z.render(), (le = Z.pointer) == null || le.getChartPosition(), Z.renderer.imgCount || Z.hasLoaded || Z.onload(), Z.temporaryDisplay(!0);
        }
        onload() {
          this.callbacks.concat([this.callback]).forEach(function(Z) {
            Z && this.index !== void 0 && Z.apply(this, [this]);
          }, this), $(this, "load"), $(this, "render"), P(this.index) && this.setReflow(), this.warnIfA11yModuleNotLoaded(), this.hasLoaded = !0;
        }
        warnIfA11yModuleNotLoaded() {
          let { options: Z, title: V } = this;
          !Z || this.accessibility || (this.renderer.boxWrapper.attr({ role: "img", "aria-label": (V && V.element.textContent || "").replace(/</g, "&lt;") }), Z.accessibility && Z.accessibility.enabled === !1 || J('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));
        }
        addSeries(Z, V, re) {
          let le, be = this;
          return Z && (V = H(V, !0), $(be, "addSeries", { options: Z }, function() {
            le = be.initSeries(Z), be.isDirtyLegend = !0, be.linkSeries(), le.enabledDataSorting && le.setData(Z.data, !1), $(be, "afterAddSeries", { series: le }), V && be.redraw(re);
          })), le;
        }
        addAxis(Z, V, re, le) {
          return this.createAxis(V ? "xAxis" : "yAxis", { axis: Z, redraw: re, animation: le });
        }
        addColorAxis(Z, V, re) {
          return this.createAxis("colorAxis", { axis: Z, redraw: V, animation: re });
        }
        createAxis(Z, V) {
          let re = new s(this, V.axis, Z);
          return H(V.redraw, !0) && this.redraw(V.animation), re;
        }
        showLoading(Z) {
          let V = this, re = V.options, le = re.loading, be = function() {
            de && S(de, { left: V.plotLeft + "px", top: V.plotTop + "px", width: V.plotWidth + "px", height: V.plotHeight + "px" });
          }, de = V.loadingDiv, ge = V.loadingSpan;
          de || (V.loadingDiv = de = d("div", { className: "highcharts-loading highcharts-loading-hidden" }, null, V.container)), ge || (V.loadingSpan = ge = d("span", { className: "highcharts-loading-inner" }, null, de), a(V, "redraw", be)), de.className = "highcharts-loading", E.setElementHTML(ge, H(Z, re.lang.loading, "")), V.styledMode || (S(de, ie(le.style, { zIndex: 10 })), S(ge, le.labelStyle), V.loadingShown || (S(de, { opacity: 0, display: "" }), g(de, { opacity: le.style.opacity || 0.5 }, { duration: le.showDuration || 0 }))), V.loadingShown = !0, be();
        }
        hideLoading() {
          let Z = this.options, V = this.loadingDiv;
          V && (V.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || g(V, { opacity: 0 }, { duration: Z.loading.hideDuration || 100, complete: function() {
            S(V, { display: "none" });
          } })), this.loadingShown = !1;
        }
        update(Z, V, re, le) {
          let be, de, ge, fe = this, ke = { credits: "addCredits", title: "setTitle", subtitle: "setSubtitle", caption: "setCaption" }, Pe = Z.isResponsiveOptions, Ae = [];
          $(fe, "update", { options: Z }), Pe || fe.setResponsive(!1, !0), Z = G(Z, fe.options), fe.userOptions = L(fe.userOptions, Z);
          let Le = Z.chart;
          Le && (L(!0, fe.options.chart, Le), this.setZoomOptions(), "className" in Le && fe.setClassName(Le.className), ("inverted" in Le || "polar" in Le || "type" in Le) && (fe.propFromSeries(), be = !0), "alignTicks" in Le && (be = !0), "events" in Le && K(this, Le), w(Le, function(We, Ne) {
            fe.propsRequireUpdateSeries.indexOf("chart." + Ne) !== -1 && (de = !0), fe.propsRequireDirtyBox.indexOf(Ne) !== -1 && (fe.isDirtyBox = !0), fe.propsRequireReflow.indexOf(Ne) === -1 || (fe.isDirtyBox = !0, Pe || (ge = !0));
          }), !fe.styledMode && Le.style && fe.renderer.setStyle(fe.options.chart.style || {})), !fe.styledMode && Z.colors && (this.options.colors = Z.colors), Z.time && (this.time === u && (this.time = new b(Z.time)), L(!0, fe.options.time, Z.time)), w(Z, function(We, Ne) {
            fe[Ne] && typeof fe[Ne].update == "function" ? fe[Ne].update(We, !1) : typeof fe[ke[Ne]] == "function" ? fe[ke[Ne]](We) : Ne !== "colors" && fe.collectionsWithUpdate.indexOf(Ne) === -1 && L(!0, fe.options[Ne], Z[Ne]), Ne !== "chart" && fe.propsRequireUpdateSeries.indexOf(Ne) !== -1 && (de = !0);
          }), this.collectionsWithUpdate.forEach(function(We) {
            Z[We] && (ne(Z[We]).forEach(function(Ne, Xe) {
              let et, Ze = P(Ne.id);
              Ze && (et = fe.get(Ne.id)), !et && fe[We] && (et = fe[We][H(Ne.index, Xe)]) && (Ze && P(et.options.id) || et.options.isInternal) && (et = void 0), et && et.coll === We && (et.update(Ne, !1), re && (et.touched = !0)), !et && re && fe.collectionsWithInit[We] && (fe.collectionsWithInit[We][0].apply(fe, [Ne].concat(fe.collectionsWithInit[We][1] || []).concat([!1])).touched = !0);
            }), re && fe[We].forEach(function(Ne) {
              Ne.touched || Ne.options.isInternal ? delete Ne.touched : Ae.push(Ne);
            }));
          }), Ae.forEach(function(We) {
            We.chart && We.remove && We.remove(!1);
          }), be && fe.axes.forEach(function(We) {
            We.update({}, !1);
          }), de && fe.getSeriesOrderByLinks().forEach(function(We) {
            We.chart && We.update({}, !1);
          }, this);
          let Ee = Le && Le.width, Ye = Le && (f(Le.height) ? ee(Le.height, Ee || fe.chartWidth) : Le.height);
          ge || W(Ee) && Ee !== fe.chartWidth || W(Ye) && Ye !== fe.chartHeight ? fe.setSize(Ee, Ye, le) : H(V, !0) && fe.redraw(le), $(fe, "afterUpdate", { options: Z, redraw: V, animation: le });
        }
        setSubtitle(Z, V) {
          this.applyDescription("subtitle", Z), this.layOutTitles(V);
        }
        setCaption(Z, V) {
          this.applyDescription("caption", Z), this.layOutTitles(V);
        }
        showResetZoom() {
          let Z = this, V = D.lang, re = Z.zooming.resetButton, le = re.theme, be = re.relativeTo === "chart" || re.relativeTo === "spacingBox" ? null : "plotBox";
          function de() {
            Z.zoomOut();
          }
          $(this, "beforeShowResetZoom", null, function() {
            Z.resetZoomButton = Z.renderer.button(V.resetZoom, null, null, de, le).attr({ align: re.position.align, title: V.resetZoomTitle }).addClass("highcharts-reset-zoom").add().align(re.position, !1, be);
          }), $(this, "afterShowResetZoom");
        }
        zoomOut() {
          $(this, "selection", { resetSelection: !0 }, () => this.transform({ reset: !0, trigger: "zoom" }));
        }
        pan(Z, V) {
          let re = this, le = typeof V == "object" ? V : { enabled: V, type: "x" }, be = le.type, de = be && re[{ x: "xAxis", xy: "axes", y: "yAxis" }[be]].filter((fe) => fe.options.panningEnabled && !fe.options.isInternal), ge = re.options.chart;
          ge != null && ge.panning && (ge.panning = le), $(this, "pan", { originalEvent: Z }, () => {
            re.transform({ axes: de, event: Z, to: { x: Z.chartX - (re.mouseDownX || 0), y: Z.chartY - (re.mouseDownY || 0) }, trigger: "pan" }), S(re.container, { cursor: "move" });
          });
        }
        transform(Z) {
          var Le;
          let { axes: V = this.axes, event: re, from: le = {}, reset: be, selection: de, to: ge = {}, trigger: fe } = Z, { inverted: ke } = this, Pe = !1, Ae;
          for (let Ee of ((Le = this.hoverPoints) == null || Le.forEach((Ye) => Ye.setState()), V)) {
            let { horiz: Ye, len: We, minPointOffset: Ne = 0, options: Xe, reversed: et } = Ee, Ze = Ye ? "width" : "height", ut = Ye ? "x" : "y", it = ge[Ze] || Ee.len, kt = le[Ze] || Ee.len, ze = 10 > Math.abs(it) ? 1 : it / kt, nt = (le[ut] || 0) + kt / 2 - Ee.pos, jt = nt - ((ge[ut] ?? Ee.pos) + it / 2 - Ee.pos) / ze, Vt = et && !ke || !et && ke ? -1 : 1;
            if (!be && (nt < 0 || nt > Ee.len))
              continue;
            let Be = Ee.toValue(jt, !0) + (de ? 0 : Ne * Vt), Ve = Ee.toValue(jt + We / ze, !0) - (de ? 0 : Ne * Vt || 0), Je = Ee.allExtremes;
            if (Be > Ve && ([Be, Ve] = [Ve, Be]), ze === 1 && !be && Ee.coll === "yAxis" && !Je) {
              for (let st of Ee.series) {
                let ft = st.getExtremes(st.getProcessedData(!0).yData, !0);
                Je ?? (Je = { dataMin: Number.MAX_VALUE, dataMax: -Number.MAX_VALUE }), W(ft.dataMin) && W(ft.dataMax) && (Je.dataMin = Math.min(ft.dataMin, Je.dataMin), Je.dataMax = Math.max(ft.dataMax, Je.dataMax));
              }
              Ee.allExtremes = Je;
            }
            let { dataMin: Dt, dataMax: It, min: _t, max: $t } = ie(Ee.getExtremes(), Je || {}), Bt = Dt ?? Xe.min, ue = It ?? Xe.max, Oe = Ve - Be, He = Ee.categories ? 0 : Math.min(Oe, ue - Bt), tt = Bt - He * (P(Xe.min) ? 0 : Xe.minPadding), ct = ue + He * (P(Xe.max) ? 0 : Xe.maxPadding), mt = Ee.allowZoomOutside || ze === 1 || fe !== "zoom" && ze > 1, ot = Math.min(Xe.min ?? tt, tt, mt ? _t : tt), at = Math.max(Xe.max ?? ct, ct, mt ? $t : ct);
            (!Ee.isOrdinal || ze !== 1 || be) && (Be < ot && (Be = ot, ze >= 1 && (Ve = Be + Oe)), Ve > at && (Ve = at, ze >= 1 && (Be = Ve - Oe)), (be || Ee.series.length && (Be !== _t || Ve !== $t) && Be >= ot && Ve <= at) && (de ? de[Ee.coll].push({ axis: Ee, min: Be, max: Ve }) : (Ee.isPanning = fe !== "zoom", Ee.setExtremes(be ? void 0 : Be, be ? void 0 : Ve, !1, !1, { move: jt, trigger: fe, scale: ze }), !be && (Be > ot || Ve < at) && fe !== "mousewheel" && (Ae = !0)), Pe = !0), re && (this[Ye ? "mouseDownX" : "mouseDownY"] = re[Ye ? "chartX" : "chartY"]));
          }
          return Pe && (de ? $(this, "selection", de, () => {
            delete Z.selection, Z.trigger = "zoom", this.transform(Z);
          }) : (Ae && !this.resetZoomButton ? this.showResetZoom() : !Ae && this.resetZoomButton && (this.resetZoomButton = this.resetZoomButton.destroy()), this.redraw(fe === "zoom" && (this.options.chart.animation ?? this.pointCount < 100)))), Pe;
        }
      }
      return ie(ve.prototype, { callbacks: [], collectionsWithInit: { xAxis: [ve.prototype.addAxis, [!0]], yAxis: [ve.prototype.addAxis, [!1]], series: [ve.prototype.addSeries] }, collectionsWithUpdate: ["xAxis", "yAxis", "series"], propsRequireDirtyBox: ["backgroundColor", "borderColor", "borderWidth", "borderRadius", "plotBackgroundColor", "plotBackgroundImage", "plotBorderColor", "plotBorderWidth", "plotShadow", "shadow"], propsRequireReflow: ["margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "spacing", "spacingTop", "spacingRight", "spacingBottom", "spacingLeft"], propsRequireUpdateSeries: ["chart.inverted", "chart.polar", "chart.ignoreHiddenSeries", "chart.type", "colors", "plotOptions", "time", "tooltip"] }), ve;
    }), i(e, "Extensions/ScrollablePlotArea.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Globals.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Utilities.js"]], function(n, s, l, m) {
      let { stop: A } = n, { composed: Y } = s, { addEvent: q, createElement: T, css: B, defined: O, merge: b, pushUnique: v } = m;
      function E() {
        let C = this.scrollablePlotArea;
        (this.scrollablePixelsX || this.scrollablePixelsY) && !C && (this.scrollablePlotArea = C = new g(this)), C == null || C.applyFixed();
      }
      function M() {
        this.chart.scrollablePlotArea && (this.chart.scrollablePlotArea.isDirty = !0);
      }
      class g {
        static compose(j, D, u) {
          v(Y, this.compose) && (q(j, "afterInit", M), q(D, "afterSetChartSize", (R) => this.afterSetSize(R.target, R)), q(D, "render", E), q(u, "show", M));
        }
        static afterSetSize(j, D) {
          let u, R, K, { minWidth: I, minHeight: z } = j.options.chart.scrollablePlotArea || {}, { clipBox: k, plotBox: h, inverted: F, renderer: o } = j;
          if (!o.forExport && (I ? (j.scrollablePixelsX = u = Math.max(0, I - j.chartWidth), u && (j.scrollablePlotBox = b(j.plotBox), h.width = j.plotWidth += u, k[F ? "height" : "width"] += u, K = !0)) : z && (j.scrollablePixelsY = R = Math.max(0, z - j.chartHeight), O(R) && (j.scrollablePlotBox = b(j.plotBox), h.height = j.plotHeight += R, k[F ? "width" : "height"] += R, K = !1)), O(K) && !D.skipAxes))
            for (let a of j.axes)
              a.horiz === K && (a.setAxisSize(), a.setAxisTranslation());
        }
        constructor(j) {
          var c;
          let D, u = j.options.chart, R = l.getRendererType(), K = u.scrollablePlotArea || {}, I = this.moveFixedElements.bind(this), z = { WebkitOverflowScrolling: "touch", overflowX: "hidden", overflowY: "hidden" };
          j.scrollablePixelsX && (z.overflowX = "auto"), j.scrollablePixelsY && (z.overflowY = "auto"), this.chart = j;
          let k = this.parentDiv = T("div", { className: "highcharts-scrolling-parent" }, { position: "relative" }, j.renderTo), h = this.scrollingContainer = T("div", { className: "highcharts-scrolling" }, z, k), F = this.innerContainer = T("div", { className: "highcharts-inner-container" }, void 0, h), o = this.fixedDiv = T("div", { className: "highcharts-fixed" }, { position: "absolute", overflow: "hidden", pointerEvents: "none", zIndex: (((c = u.style) == null ? void 0 : c.zIndex) || 0) + 2, top: 0 }, void 0, !0), a = this.fixedRenderer = new R(o, j.chartWidth, j.chartHeight, u.style);
          this.mask = a.path().attr({ fill: u.backgroundColor || "#fff", "fill-opacity": K.opacity ?? 0.85, zIndex: -1 }).addClass("highcharts-scrollable-mask").add(), h.parentNode.insertBefore(o, h), B(j.renderTo, { overflow: "visible" }), q(j, "afterShowResetZoom", I), q(j, "afterApplyDrilldown", I), q(j, "afterLayOutTitles", I), q(h, "scroll", () => {
            let { pointer: d, hoverPoint: S } = j;
            d && (delete d.chartPosition, S && (D = S), d.runPointActions(void 0, D, !0));
          }), F.appendChild(j.container);
        }
        applyFixed() {
          var W;
          let { chart: j, fixedRenderer: D, isDirty: u, scrollingContainer: R } = this, { axisOffset: K, chartWidth: I, chartHeight: z, container: k, plotHeight: h, plotLeft: F, plotTop: o, plotWidth: a, scrollablePixelsX: c = 0, scrollablePixelsY: d = 0 } = j, { scrollPositionX: S = 0, scrollPositionY: P = 0 } = j.options.chart.scrollablePlotArea || {}, G = I + c, x = z + d;
          D.setSize(I, z), (u ?? !0) && (this.isDirty = !1, this.moveFixedElements()), A(j.container), B(k, { width: `${G}px`, height: `${x}px` }), j.renderer.boxWrapper.attr({ width: G, height: x, viewBox: [0, 0, G, x].join(" ") }), (W = j.chartBackground) == null || W.attr({ width: G, height: x }), B(R, { width: `${I}px`, height: `${z}px` }), O(u) || (R.scrollLeft = c * S, R.scrollTop = d * P);
          let Q = o - K[0] - 1, J = F - K[3] - 1, ie = o + h + K[2] + 1, te = F + a + K[1] + 1, $ = F + a - c, oe = o + h - d, p = [["M", 0, 0]];
          c ? p = [["M", 0, Q], ["L", F - 1, Q], ["L", F - 1, ie], ["L", 0, ie], ["Z"], ["M", $, Q], ["L", I, Q], ["L", I, ie], ["L", $, ie], ["Z"]] : d && (p = [["M", J, 0], ["L", J, o - 1], ["L", te, o - 1], ["L", te, 0], ["Z"], ["M", J, oe], ["L", J, z], ["L", te, z], ["L", te, oe], ["Z"]]), j.redrawTrigger !== "adjustHeight" && this.mask.attr({ d: p });
        }
        moveFixedElements() {
          let j, { container: D, inverted: u, scrollablePixelsX: R, scrollablePixelsY: K } = this.chart, I = this.fixedRenderer, z = [".highcharts-breadcrumbs-group", ".highcharts-contextbutton", ".highcharts-caption", ".highcharts-credits", ".highcharts-legend", ".highcharts-legend-checkbox", ".highcharts-navigator-series", ".highcharts-navigator-xaxis", ".highcharts-navigator-yaxis", ".highcharts-navigator", ".highcharts-reset-zoom", ".highcharts-drillup-button", ".highcharts-scrollbar", ".highcharts-subtitle", ".highcharts-title"];
          for (let k of (R && !u ? j = ".highcharts-yaxis" : R && u || K && !u ? j = ".highcharts-xaxis" : K && u && (j = ".highcharts-yaxis"), j && z.push(`${j}:not(.highcharts-radial-axis)`, `${j}-labels:not(.highcharts-radial-axis-labels)`), z))
            [].forEach.call(D.querySelectorAll(k), (h) => {
              (h.namespaceURI === I.SVG_NS ? I.box : I.box.parentNode).appendChild(h), h.style.pointerEvents = "auto";
            });
        }
      }
      return g;
    }), i(e, "Core/Axis/Stacking/StackItem.js", [e["Core/Templating.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(n, s, l) {
      let { format: m } = n, { series: A } = s, { destroyObjectProperties: Y, fireEvent: q, isNumber: T, pick: B } = l;
      return class {
        constructor(O, b, v, E, M) {
          let g = O.chart.inverted, C = O.reversed;
          this.axis = O;
          let j = this.isNegative = !!v != !!C;
          this.options = b = b || {}, this.x = E, this.total = null, this.cumulative = null, this.points = {}, this.hasValidPoints = !1, this.stack = M, this.leftCliff = 0, this.rightCliff = 0, this.alignOptions = { align: b.align || (g ? j ? "left" : "right" : "center"), verticalAlign: b.verticalAlign || (g ? "middle" : j ? "bottom" : "top"), y: b.y, x: b.x }, this.textAlign = b.textAlign || (g ? j ? "right" : "left" : "center");
        }
        destroy() {
          Y(this, this.axis);
        }
        render(O) {
          let b = this.axis.chart, v = this.options, E = v.format, M = E ? m(E, this, b) : v.formatter.call(this);
          if (this.label)
            this.label.attr({ text: M, visibility: "hidden" });
          else {
            this.label = b.renderer.label(M, null, void 0, v.shape, void 0, void 0, v.useHTML, !1, "stack-labels");
            let g = { r: v.borderRadius || 0, text: M, padding: B(v.padding, 5), visibility: "hidden" };
            b.styledMode || (g.fill = v.backgroundColor, g.stroke = v.borderColor, g["stroke-width"] = v.borderWidth, this.label.css(v.style || {})), this.label.attr(g), this.label.added || this.label.add(O);
          }
          this.label.labelrank = b.plotSizeY, q(this, "afterRender");
        }
        setOffset(O, b, v, E, M, g) {
          let { alignOptions: C, axis: j, label: D, options: u, textAlign: R } = this, K = j.chart, I = this.getStackBox({ xOffset: O, width: b, boxBottom: v, boxTop: E, defaultX: M, xAxis: g }), { verticalAlign: z } = C;
          if (D && I) {
            let k = D.getBBox(void 0, 0), h = D.padding, F = B(u.overflow, "justify") === "justify", o;
            C.x = u.x || 0, C.y = u.y || 0;
            let { x: a, y: c } = this.adjustStackPosition({ labelBox: k, verticalAlign: z, textAlign: R });
            I.x -= a, I.y -= c, D.align(C, !1, I), (o = K.isInsidePlot(D.alignAttr.x + C.x + a, D.alignAttr.y + C.y + c)) || (F = !1), F && A.prototype.justifyDataLabel.call(j, D, C, D.alignAttr, k, I), D.attr({ x: D.alignAttr.x, y: D.alignAttr.y, rotation: u.rotation, rotationOriginX: k.width * { left: 0, center: 0.5, right: 1 }[u.textAlign || "center"], rotationOriginY: k.height / 2 }), B(!F && u.crop, !0) && (o = T(D.x) && T(D.y) && K.isInsidePlot(D.x - h + (D.width || 0), D.y) && K.isInsidePlot(D.x + h, D.y)), D[o ? "show" : "hide"]();
          }
          q(this, "afterSetOffset", { xOffset: O, width: b });
        }
        adjustStackPosition({ labelBox: O, verticalAlign: b, textAlign: v }) {
          let E = { bottom: 0, middle: 1, top: 2, right: 1, center: 0, left: -1 }, M = E[b], g = E[v];
          return { x: O.width / 2 + O.width / 2 * g, y: O.height / 2 * M };
        }
        getStackBox(O) {
          let b = this.axis, v = b.chart, { boxTop: E, defaultX: M, xOffset: g, width: C, boxBottom: j } = O, D = b.stacking.usePercentage ? 100 : B(E, this.total, 0), u = b.toPixels(D), R = O.xAxis || v.xAxis[0], K = B(M, R.translate(this.x)) + g, I = Math.abs(u - b.toPixels(j || T(b.min) && b.logarithmic && b.logarithmic.lin2log(b.min) || 0)), z = v.inverted, k = this.isNegative;
          return z ? { x: (k ? u : u - I) - v.plotLeft, y: R.height - K - C, width: I, height: C } : { x: K + R.transB - v.plotLeft, y: (k ? u - I : u) - v.plotTop, width: C, height: I };
        }
      };
    }), i(e, "Core/Axis/Stacking/StackingAxis.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Axis/Axis.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Axis/Stacking/StackItem.js"], e["Core/Utilities.js"]], function(n, s, l, m, A) {
      var Y;
      let { getDeferredAnimation: q } = n, { series: { prototype: T } } = l, { addEvent: B, correctFloat: O, defined: b, destroyObjectProperties: v, fireEvent: E, isArray: M, isNumber: g, objectEach: C, pick: j } = A;
      function D() {
        let o = this.inverted;
        this.axes.forEach((a) => {
          a.stacking && a.stacking.stacks && a.hasVisibleSeries && (a.stacking.oldStacks = a.stacking.stacks);
        }), this.series.forEach((a) => {
          let c = a.xAxis && a.xAxis.options || {};
          a.options.stacking && a.reserveSpace() && (a.stackKey = [a.type, j(a.options.stack, ""), o ? c.top : c.left, o ? c.height : c.width].join(","));
        });
      }
      function u() {
        var a;
        let o = this.stacking;
        if (o) {
          let c = o.stacks;
          C(c, (d, S) => {
            v(d), delete c[S];
          }), (a = o.stackTotalGroup) == null || a.destroy();
        }
      }
      function R() {
        this.stacking || (this.stacking = new F(this));
      }
      function K(o, a, c, d) {
        return !b(o) || o.x !== a || d && o.stackKey !== d ? o = { x: a, index: 0, key: d, stackKey: d } : o.index++, o.key = [c, a, o.index].join(","), o;
      }
      function I() {
        let o, a = this, c = a.yAxis, d = a.stackKey || "", S = c.stacking.stacks, P = a.processedXData, G = a.options.stacking, x = a[G + "Stacker"];
        x && [d, "-" + d].forEach((Q) => {
          var oe;
          let J = P.length, ie, te, $;
          for (; J--; )
            ie = P[J], o = a.getStackIndicator(o, ie, a.index, Q), te = (oe = S[Q]) == null ? void 0 : oe[ie], ($ = te == null ? void 0 : te.points[o.key || ""]) && x.call(a, $, te, J);
        });
      }
      function z(o, a, c) {
        let d = a.total ? 100 / a.total : 0;
        o[0] = O(o[0] * d), o[1] = O(o[1] * d), this.stackedYData[c] = o[1];
      }
      function k(o) {
        (this.is("column") || this.is("columnrange")) && (this.options.centerInCategory && !this.options.stacking && this.chart.series.length > 1 ? T.setStackedPoints.call(this, o, "group") : o.stacking.resetStacks());
      }
      function h(o, a) {
        var me, ve;
        let c, d, S, P, G, x, Q, J, ie, te = a || this.options.stacking;
        if (!te || !this.reserveSpace() || ({ group: "xAxis" }[te] || "yAxis") !== o.coll)
          return;
        let $ = this.processedXData, oe = this.processedYData, p = [], W = oe.length, X = this.options, f = X.threshold || 0, L = X.startFromThreshold ? f : 0, w = X.stack, H = a ? `${this.type},${te}` : this.stackKey || "", U = "-" + H, ee = this.negStacks, ae = o.stacking, ne = ae.stacks, he = ae.oldStacks;
        for (ae.stacksTouched += 1, Q = 0; Q < W; Q++) {
          J = $[Q], ie = oe[Q], x = (c = this.getStackIndicator(c, J, this.index)).key || "", ne[G = (d = ee && ie < (L ? 0 : f)) ? U : H] || (ne[G] = {}), ne[G][J] || ((me = he[G]) != null && me[J] ? (ne[G][J] = he[G][J], ne[G][J].total = null) : ne[G][J] = new m(o, o.options.stackLabels, !!d, J, w)), S = ne[G][J], ie !== null ? (S.points[x] = S.points[this.index] = [j(S.cumulative, L)], b(S.cumulative) || (S.base = x), S.touched = ae.stacksTouched, c.index > 0 && this.singleStacks === !1 && (S.points[x][0] = S.points[this.index + "," + J + ",0"][0])) : (delete S.points[x], delete S.points[this.index]);
          let Me = S.total || 0;
          te === "percent" ? (P = d ? H : U, Me = ee && ((ve = ne[P]) != null && ve[J]) ? (P = ne[P][J]).total = Math.max(P.total || 0, Me) + Math.abs(ie) || 0 : O(Me + (Math.abs(ie) || 0))) : te === "group" ? (M(ie) && (ie = ie[0]), ie !== null && Me++) : Me = O(Me + (ie || 0)), te === "group" ? S.cumulative = (Me || 1) - 1 : S.cumulative = O(j(S.cumulative, L) + (ie || 0)), S.total = Me, ie !== null && (S.points[x].push(S.cumulative), p[Q] = S.cumulative, S.hasValidPoints = !0);
        }
        te === "percent" && (ae.usePercentage = !0), te !== "group" && (this.stackedYData = p), ae.oldStacks = {};
      }
      class F {
        constructor(a) {
          this.oldStacks = {}, this.stacks = {}, this.stacksTouched = 0, this.axis = a;
        }
        buildStacks() {
          let a, c, d = this.axis, S = d.series, P = d.coll === "xAxis", G = d.options.reversedStacks, x = S.length;
          for (this.resetStacks(), this.usePercentage = !1, c = x; c--; )
            a = S[G ? c : x - c - 1], P && a.setGroupedPoints(d), a.setStackedPoints(d);
          if (!P)
            for (c = 0; c < x; c++)
              S[c].modifyStacks();
          E(d, "afterBuildStacks");
        }
        cleanStacks() {
          this.oldStacks && (this.stacks = this.oldStacks, C(this.stacks, (a) => {
            C(a, (c) => {
              c.cumulative = c.total;
            });
          }));
        }
        resetStacks() {
          C(this.stacks, (a) => {
            C(a, (c, d) => {
              g(c.touched) && c.touched < this.stacksTouched ? (c.destroy(), delete a[d]) : (c.total = null, c.cumulative = null);
            });
          });
        }
        renderStackTotals() {
          var x;
          let a = this.axis, c = a.chart, d = c.renderer, S = this.stacks, P = q(c, ((x = a.options.stackLabels) == null ? void 0 : x.animation) || !1), G = this.stackTotalGroup = this.stackTotalGroup || d.g("stack-labels").attr({ zIndex: 6, opacity: 0 }).add();
          G.translate(c.plotLeft, c.plotTop), C(S, (Q) => {
            C(Q, (J) => {
              J.render(G);
            });
          }), G.animate({ opacity: 1 }, P);
        }
      }
      return (Y || (Y = {})).compose = function(o, a, c) {
        let d = a.prototype, S = c.prototype;
        d.getStacks || (B(o, "init", R), B(o, "destroy", u), d.getStacks = D, S.getStackIndicator = K, S.modifyStacks = I, S.percentStacker = z, S.setGroupedPoints = k, S.setStackedPoints = h);
      }, Y;
    }), i(e, "Series/Line/LineSeries.js", [e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(n, s, l) {
      let { defined: m, merge: A, isObject: Y } = l;
      class q extends n {
        drawGraph() {
          let B = this.options, O = (this.gappedPath || this.getGraphPath).call(this), b = this.chart.styledMode;
          [this, ...this.zones].forEach((v, E) => {
            let M, g = v.graph, C = g ? "animate" : "attr", j = v.dashStyle || B.dashStyle;
            g ? (g.endX = this.preventGraphAnimation ? null : O.xMap, g.animate({ d: O })) : O.length && (v.graph = g = this.chart.renderer.path(O).addClass("highcharts-graph" + (E ? ` highcharts-zone-graph-${E - 1} ` : " ") + (E && v.className || "")).attr({ zIndex: 1 }).add(this.group)), g && !b && (M = { stroke: !E && B.lineColor || v.color || this.color || "#cccccc", "stroke-width": B.lineWidth || 0, fill: this.fillGraph && this.color || "none" }, j ? M.dashstyle = j : B.linecap !== "square" && (M["stroke-linecap"] = M["stroke-linejoin"] = "round"), g[C](M).shadow(E < 2 && B.shadow && A({ filterUnits: "userSpaceOnUse" }, Y(B.shadow) ? B.shadow : {}))), g && (g.startX = O.xMap, g.isArea = O.isArea);
          });
        }
        getGraphPath(B, O, b) {
          let v = this, E = v.options, M = [], g = [], C, j = E.step, D = (B = B || v.points).reversed;
          return D && B.reverse(), (j = { right: 1, center: 2 }[j] || j && 3) && D && (j = 4 - j), (B = this.getValidPoints(B, !1, !(E.connectNulls && !O && !b))).forEach(function(u, R) {
            let K, I = u.plotX, z = u.plotY, k = B[R - 1], h = u.isNull || typeof z != "number";
            (u.leftCliff || k && k.rightCliff) && !b && (C = !0), h && !m(O) && R > 0 ? C = !E.connectNulls : h && !O ? C = !0 : (R === 0 || C ? K = [["M", u.plotX, u.plotY]] : v.getPointSpline ? K = [v.getPointSpline(B, u, R)] : j ? (K = j === 1 ? [["L", k.plotX, z]] : j === 2 ? [["L", (k.plotX + I) / 2, k.plotY], ["L", (k.plotX + I) / 2, z]] : [["L", I, k.plotY]]).push(["L", I, z]) : K = [["L", I, z]], g.push(u.x), j && (g.push(u.x), j === 2 && g.push(u.x)), M.push.apply(M, K), C = !1);
          }), M.xMap = g, v.graphPath = M, M;
        }
      }
      return q.defaultOptions = A(n.defaultOptions, { legendSymbol: "lineMarker" }), s.registerSeriesType("line", q), q;
    }), i(e, "Series/Area/AreaSeries.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(n, s) {
      let { seriesTypes: { line: l } } = n, { extend: m, merge: A, objectEach: Y, pick: q } = s;
      class T extends l {
        drawGraph() {
          this.areaPath = [], super.drawGraph.apply(this);
          let { areaPath: O, options: b } = this;
          [this, ...this.zones].forEach((v, E) => {
            let M = {}, g = v.fillColor || b.fillColor, C = v.area, j = C ? "animate" : "attr";
            C ? (C.endX = this.preventGraphAnimation ? null : O.xMap, C.animate({ d: O })) : (M.zIndex = 0, (C = v.area = this.chart.renderer.path(O).addClass("highcharts-area" + (E ? ` highcharts-zone-area-${E - 1} ` : " ") + (E && v.className || "")).add(this.group)).isArea = !0), this.chart.styledMode || (M.fill = g || v.color || this.color, M["fill-opacity"] = g ? 1 : b.fillOpacity ?? 0.75, C.css({ pointerEvents: this.stickyTracking ? "none" : "auto" })), C[j](M), C.startX = O.xMap, C.shiftUnit = b.step ? 2 : 1;
          });
        }
        getGraphPath(O) {
          let b, v, E, M = l.prototype.getGraphPath, g = this.options, C = g.stacking, j = this.yAxis, D = [], u = [], R = this.index, K = j.stacking.stacks[this.stackKey], I = g.threshold, z = Math.round(j.getThreshold(g.threshold)), k = q(g.connectNulls, C === "percent"), h = function(S, P, G) {
            let x = O[S], Q = C && K[x.x].points[R], J = x[G + "Null"] || 0, ie = x[G + "Cliff"] || 0, te, $, oe = !0;
            ie || J ? (te = (J ? Q[0] : Q[1]) + ie, $ = Q[0] + ie, oe = !!J) : !C && O[P] && O[P].isNull && (te = $ = I), te !== void 0 && (u.push({ plotX: b, plotY: te === null ? z : j.getThreshold(te), isNull: oe, isCliff: !0 }), D.push({ plotX: b, plotY: $ === null ? z : j.getThreshold($), doCurve: !1 }));
          };
          O = O || this.points, C && (O = this.getStackPoints(O));
          for (let S = 0, P = O.length; S < P; ++S)
            C || (O[S].leftCliff = O[S].rightCliff = O[S].leftNull = O[S].rightNull = void 0), v = O[S].isNull, b = q(O[S].rectPlotX, O[S].plotX), E = C ? q(O[S].yBottom, z) : z, v && !k || (k || h(S, S - 1, "left"), v && !C && k || (u.push(O[S]), D.push({ x: S, plotX: b, plotY: E })), k || h(S, S + 1, "right"));
          let F = M.call(this, u, !0, !0);
          D.reversed = !0;
          let o = M.call(this, D, !0, !0), a = o[0];
          a && a[0] === "M" && (o[0] = ["L", a[1], a[2]]);
          let c = F.concat(o);
          c.length && c.push(["Z"]);
          let d = M.call(this, u, !1, k);
          return c.xMap = F.xMap, this.areaPath = c, d;
        }
        getStackPoints(O) {
          let b = this, v = [], E = [], M = this.xAxis, g = this.yAxis, C = g.stacking.stacks[this.stackKey], j = {}, D = g.series, u = D.length, R = g.options.reversedStacks ? 1 : -1, K = D.indexOf(b);
          if (O = O || this.points, this.options.stacking) {
            for (let z = 0; z < O.length; z++)
              O[z].leftNull = O[z].rightNull = void 0, j[O[z].x] = O[z];
            Y(C, function(z, k) {
              z.total !== null && E.push(k);
            }), E.sort(function(z, k) {
              return z - k;
            });
            let I = D.map((z) => z.visible);
            E.forEach(function(z, k) {
              let h = 0, F, o;
              if (j[z] && !j[z].isNull)
                v.push(j[z]), [-1, 1].forEach(function(a) {
                  let c = a === 1 ? "rightNull" : "leftNull", d = C[E[k + a]], S = 0;
                  if (d) {
                    let P = K;
                    for (; P >= 0 && P < u; ) {
                      let G = D[P].index;
                      !(F = d.points[G]) && (G === b.index ? j[z][c] = !0 : I[P] && (o = C[z].points[G]) && (S -= o[1] - o[0])), P += R;
                    }
                  }
                  j[z][a === 1 ? "rightCliff" : "leftCliff"] = S;
                });
              else {
                let a = K;
                for (; a >= 0 && a < u; ) {
                  let c = D[a].index;
                  if (F = C[z].points[c]) {
                    h = F[1];
                    break;
                  }
                  a += R;
                }
                h = q(h, 0), h = g.translate(h, 0, 1, 0, 1), v.push({ isNull: !0, plotX: M.translate(z, 0, 0, 0, 1), x: z, plotY: h, yBottom: h });
              }
            });
          }
          return v;
        }
      }
      return T.defaultOptions = A(l.defaultOptions, { threshold: 0, legendSymbol: "areaMarker" }), m(T.prototype, { singleStacks: !1 }), n.registerSeriesType("area", T), T;
    }), i(e, "Series/Spline/SplineSeries.js", [e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(n, s) {
      let { line: l } = n.seriesTypes, { merge: m, pick: A } = s;
      class Y extends l {
        getPointSpline(T, B, O) {
          let b, v, E, M, g = B.plotX || 0, C = B.plotY || 0, j = T[O - 1], D = T[O + 1];
          function u(K) {
            return K && !K.isNull && K.doCurve !== !1 && !B.isCliff;
          }
          if (u(j) && u(D)) {
            let K = j.plotX || 0, I = j.plotY || 0, z = D.plotX || 0, k = D.plotY || 0, h = 0;
            b = (1.5 * g + K) / 2.5, v = (1.5 * C + I) / 2.5, E = (1.5 * g + z) / 2.5, M = (1.5 * C + k) / 2.5, E !== b && (h = (M - v) * (E - g) / (E - b) + C - M), v += h, M += h, v > I && v > C ? (v = Math.max(I, C), M = 2 * C - v) : v < I && v < C && (v = Math.min(I, C), M = 2 * C - v), M > k && M > C ? (M = Math.max(k, C), v = 2 * C - M) : M < k && M < C && (M = Math.min(k, C), v = 2 * C - M), B.rightContX = E, B.rightContY = M, B.controlPoints = { low: [b, v], high: [E, M] };
          }
          let R = ["C", A(j.rightContX, j.plotX, 0), A(j.rightContY, j.plotY, 0), A(b, g, 0), A(v, C, 0), g, C];
          return j.rightContX = j.rightContY = void 0, R;
        }
      }
      return Y.defaultOptions = m(l.defaultOptions), n.registerSeriesType("spline", Y), Y;
    }), i(e, "Series/AreaSpline/AreaSplineSeries.js", [e["Series/Spline/SplineSeries.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(n, s, l) {
      let { area: m, area: { prototype: A } } = s.seriesTypes, { extend: Y, merge: q } = l;
      class T extends n {
      }
      return T.defaultOptions = q(n.defaultOptions, m.defaultOptions), Y(T.prototype, { getGraphPath: A.getGraphPath, getStackPoints: A.getStackPoints, drawGraph: A.drawGraph }), s.registerSeriesType("areaspline", T), T;
    }), i(e, "Series/Column/ColumnSeriesDefaults.js", [], function() {
      return { borderRadius: 3, centerInCategory: !1, groupPadding: 0.2, marker: null, pointPadding: 0.1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: { hover: { halo: !1, brightness: 0.1 }, select: { color: "#cccccc", borderColor: "#000000" } }, dataLabels: { align: void 0, verticalAlign: void 0, y: void 0 }, startFromThreshold: !0, stickyTracking: !1, tooltip: { distance: 6 }, threshold: 0, borderColor: "#ffffff" };
    }), i(e, "Series/Column/ColumnSeries.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Color/Color.js"], e["Series/Column/ColumnSeriesDefaults.js"], e["Core/Globals.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(n, s, l, m, A, Y, q) {
      let { animObject: T } = n, { parse: B } = s, { noop: O } = m, { clamp: b, defined: v, extend: E, fireEvent: M, isArray: g, isNumber: C, merge: j, pick: D, objectEach: u } = q;
      class R extends A {
        animate(I) {
          let z, k, h = this, F = this.yAxis, o = F.pos, a = h.options, c = this.chart.inverted, d = {}, S = c ? "translateX" : "translateY";
          I ? (d.scaleY = 1e-3, k = b(F.toPixels(a.threshold), o, o + F.len), c ? d.translateX = k - F.len : d.translateY = k, h.clipBox && h.setClip(), h.group.attr(d)) : (z = Number(h.group.attr(S)), h.group.animate({ scaleY: 1 }, E(T(h.options.animation), { step: function(P, G) {
            h.group && (d[S] = z + G.pos * (o - z), h.group.attr(d));
          } })));
        }
        init(I, z) {
          super.init.apply(this, arguments);
          let k = this;
          (I = k.chart).hasRendered && I.series.forEach(function(h) {
            h.type === k.type && (h.isDirty = !0);
          });
        }
        getColumnMetrics() {
          var J, ie;
          let I = this, z = I.options, k = I.xAxis, h = I.yAxis, F = k.options.reversedStacks, o = k.reversed && !F || !k.reversed && F, a = {}, c, d = 0;
          z.grouping === !1 ? d = 1 : I.chart.series.forEach(function(te) {
            let $, oe = te.yAxis, p = te.options;
            te.type === I.type && te.reserveSpace() && h.len === oe.len && h.pos === oe.pos && (p.stacking && p.stacking !== "group" ? (a[c = te.stackKey] === void 0 && (a[c] = d++), $ = a[c]) : p.grouping !== !1 && ($ = d++), te.columnIndex = $);
          });
          let S = Math.min(Math.abs(k.transA) * (!((J = k.brokenAxis) != null && J.hasBreaks) && ((ie = k.ordinal) == null ? void 0 : ie.slope) || z.pointRange || k.closestPointRange || k.tickInterval || 1), k.len), P = S * z.groupPadding, G = (S - 2 * P) / (d || 1), x = Math.min(z.maxPointWidth || k.len, D(z.pointWidth, G * (1 - 2 * z.pointPadding))), Q = (I.columnIndex || 0) + (o ? 1 : 0);
          return I.columnMetrics = { width: x, offset: (G - x) / 2 + (P + Q * G - S / 2) * (o ? -1 : 1), paddedWidth: G, columnCount: d }, I.columnMetrics;
        }
        crispCol(I, z, k, h) {
          let F = this.borderWidth, o = -(F % 2 ? 0.5 : 0), a = F % 2 ? 0.5 : 1;
          this.options.crisp && (k = Math.round(I + k) + o - (I = Math.round(I) + o));
          let c = Math.round(z + h) + a, d = 0.5 >= Math.abs(z) && c > 0.5;
          return h = c - (z = Math.round(z) + a), d && h && (z -= 1, h += 1), { x: I, y: z, width: k, height: h };
        }
        adjustForMissingColumns(I, z, k, h) {
          var F;
          if (!k.isNull && h.columnCount > 1) {
            let o = this.xAxis.series.filter((S) => S.visible).map((S) => S.index), a = 0, c = 0;
            u((F = this.xAxis.stacking) == null ? void 0 : F.stacks, (S) => {
              if (typeof k.x == "number") {
                let P = S[k.x.toString()];
                if (P && g(P.points[this.index])) {
                  let G = Object.keys(P.points).filter((x) => !x.match(",") && P.points[x] && P.points[x].length > 1).map(parseFloat).filter((x) => o.indexOf(x) !== -1).sort((x, Q) => Q - x);
                  a = G.indexOf(this.index), c = G.length;
                }
              }
            }), a = this.xAxis.reversed ? c - 1 - a : a;
            let d = (c - 1) * h.paddedWidth + z;
            I = (k.plotX || 0) + d / 2 - z - a * h.paddedWidth;
          }
          return I;
        }
        translate() {
          let I = this, z = I.chart, k = I.options, h = I.dense = I.closestPointRange * I.xAxis.transA < 2, F = I.borderWidth = D(k.borderWidth, h ? 0 : 1), o = I.xAxis, a = I.yAxis, c = k.threshold, d = D(k.minPointLength, 5), S = I.getColumnMetrics(), P = S.width, G = I.pointXOffset = S.offset, x = I.dataMin, Q = I.dataMax, J = I.barW = Math.max(P, 1 + 2 * F), ie = I.translatedThreshold = a.getThreshold(c);
          z.inverted && (ie -= 0.5), k.pointPadding && (J = Math.ceil(J)), A.prototype.translate.apply(I), I.points.forEach(function(te) {
            let $ = D(te.yBottom, ie), oe = 999 + Math.abs($), p = te.plotX || 0, W = b(te.plotY, -oe, a.len + oe), X, f = Math.min(W, $), L = Math.max(W, $) - f, w = P, H = p + G, U = J;
            d && Math.abs(L) < d && (L = d, X = !a.reversed && !te.negative || a.reversed && te.negative, C(c) && C(Q) && te.y === c && Q <= c && (a.min || 0) < c && (x !== Q || (a.max || 0) <= c) && (X = !X, te.negative = !te.negative), f = Math.abs(f - ie) > d ? $ - d : ie - (X ? d : 0)), v(te.options.pointWidth) && (H -= Math.round(((w = U = Math.ceil(te.options.pointWidth)) - P) / 2)), k.centerInCategory && !k.stacking && (H = I.adjustForMissingColumns(H, w, te, S)), te.barX = H, te.pointWidth = w, te.tooltipPos = z.inverted ? [b(a.len + a.pos - z.plotLeft - W, a.pos - z.plotLeft, a.len + a.pos - z.plotLeft), o.len + o.pos - z.plotTop - H - U / 2, L] : [o.left - z.plotLeft + H + U / 2, b(W + a.pos - z.plotTop, a.pos - z.plotTop, a.len + a.pos - z.plotTop), L], te.shapeType = I.pointClass.prototype.shapeType || "roundedRect", te.shapeArgs = I.crispCol(H, te.isNull ? ie : f, U, te.isNull ? 0 : L);
          }), M(this, "afterColumnTranslate");
        }
        drawGraph() {
          this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
        }
        pointAttribs(I, z) {
          let k = this.options, h = this.pointAttrToOptions || {}, F = h.stroke || "borderColor", o = h["stroke-width"] || "borderWidth", a, c, d, S = I && I.color || this.color, P = I && I[F] || k[F] || S, G = I && I.options.dashStyle || k.dashStyle, x = I && I[o] || k[o] || this[o] || 0, Q = D(I && I.opacity, k.opacity, 1);
          I && this.zones.length && (c = I.getZone(), S = I.options.color || c && (c.color || I.nonZonedColor) || this.color, c && (P = c.borderColor || P, G = c.dashStyle || G, x = c.borderWidth || x)), z && I && (d = (a = j(k.states[z], I.options.states && I.options.states[z] || {})).brightness, S = a.color || d !== void 0 && B(S).brighten(a.brightness).get() || S, P = a[F] || P, x = a[o] || x, G = a.dashStyle || G, Q = D(a.opacity, Q));
          let J = { fill: S, stroke: P, "stroke-width": x, opacity: Q };
          return G && (J.dashstyle = G), J;
        }
        drawPoints(I = this.points) {
          let z, k = this, h = this.chart, F = k.options, o = h.renderer, a = F.animationLimit || 250;
          I.forEach(function(c) {
            let d = c.plotY, S = c.graphic, P = !!S, G = S && h.pointCount < a ? "animate" : "attr";
            C(d) && c.y !== null ? (z = c.shapeArgs, S && c.hasNewShapeType() && (S = S.destroy()), k.enabledDataSorting && (c.startXPos = k.xAxis.reversed ? -(z && z.width || 0) : k.xAxis.width), !S && (c.graphic = S = o[c.shapeType](z).add(c.group || k.group), S && k.enabledDataSorting && h.hasRendered && h.pointCount < a && (S.attr({ x: c.startXPos }), P = !0, G = "animate")), S && P && S[G](j(z)), h.styledMode || S[G](k.pointAttribs(c, c.selected && "select")).shadow(c.allowShadow !== !1 && F.shadow), S && (S.addClass(c.getClassName(), !0), S.attr({ visibility: c.visible ? "inherit" : "hidden" }))) : S && (c.graphic = S.destroy());
          });
        }
        drawTracker(I = this.points) {
          let z, k = this, h = k.chart, F = h.pointer, o = function(a) {
            let c = F == null ? void 0 : F.getPointFromEvent(a);
            F && c && k.options.enableMouseTracking && (F.isDirectTouch = !0, c.onMouseOver(a));
          };
          I.forEach(function(a) {
            z = g(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [], a.graphic && (a.graphic.element.point = a), z.forEach(function(c) {
              (c.div || c.element).point = a;
            });
          }), k._hasTracking || (k.trackerGroups.forEach(function(a) {
            k[a] && (k[a].addClass("highcharts-tracker").on("mouseover", o).on("mouseout", function(c) {
              F == null || F.onTrackerMouseOut(c);
            }).on("touchstart", o), !h.styledMode && k.options.cursor && k[a].css({ cursor: k.options.cursor }));
          }), k._hasTracking = !0), M(this, "afterDrawTracker");
        }
        remove() {
          let I = this, z = I.chart;
          z.hasRendered && z.series.forEach(function(k) {
            k.type === I.type && (k.isDirty = !0);
          }), A.prototype.remove.apply(I, arguments);
        }
      }
      return R.defaultOptions = j(A.defaultOptions, l), E(R.prototype, { directTouch: !0, getSymbol: O, negStacks: !0, trackerGroups: ["group", "dataLabelsGroup"] }), Y.registerSeriesType("column", R), R;
    }), i(e, "Core/Series/DataLabel.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Templating.js"], e["Core/Utilities.js"]], function(n, s, l) {
      var m;
      let { getDeferredAnimation: A } = n, { format: Y } = s, { defined: q, extend: T, fireEvent: B, isArray: O, isString: b, merge: v, objectEach: E, pick: M, pInt: g, splat: C } = l;
      return function(j) {
        function D() {
          return h(this).some((o) => o == null ? void 0 : o.enabled);
        }
        function u(o, a, c, d, S) {
          let P = this.chart, G = this.isCartesian && P.inverted, x = this.enabledDataSorting, Q = o.plotX, J = o.plotY, ie = c.rotation || 0, te = q(Q) && q(J) && P.isInsidePlot(Q, Math.round(J), { inverted: G, paneCoordinates: !0, series: this }), $ = ie === 0 && M(c.overflow, x ? "none" : "justify") === "justify", oe = this.visible && o.visible !== !1 && q(Q) && (o.series.forceDL || x && !$ || te || M(c.inside, !!this.options.stacking) && d && P.isInsidePlot(Q, G ? d.x + 1 : d.y + d.height - 1, { inverted: G, paneCoordinates: !0, series: this })), p = o.pos();
          if (oe && p) {
            var W;
            let X = a.getBBox(), f = a.getBBox(void 0, 0), L = { right: 1, center: 0.5 }[c.align || 0] || 0, w = { bottom: 1, middle: 0.5 }[c.verticalAlign || 0] || 0;
            if (d = T({ x: p[0], y: Math.round(p[1]), width: 0, height: 0 }, d || {}), T(c, { width: X.width, height: X.height }), W = d, x && this.xAxis && !$ && this.setDataLabelStartPos(o, a, S, te, W), a.align(v(c, { width: f.width, height: f.height }), !1, d, !1), a.alignAttr.x += L * (f.width - X.width), a.alignAttr.y += w * (f.height - X.height), a[a.placed ? "animate" : "attr"]({ x: a.alignAttr.x + (X.width - f.width) / 2, y: a.alignAttr.y + (X.height - f.height) / 2, rotationOriginX: (a.width || 0) / 2, rotationOriginY: (a.height || 0) / 2 }), $ && d.height >= 0)
              this.justifyDataLabel(a, c, a.alignAttr, X, d, S);
            else if (M(c.crop, !0)) {
              let { x: H, y: U } = a.alignAttr;
              oe = P.isInsidePlot(H, U, { paneCoordinates: !0, series: this }) && P.isInsidePlot(H + X.width - 1, U + X.height - 1, { paneCoordinates: !0, series: this });
            }
            c.shape && !ie && a[S ? "attr" : "animate"]({ anchorX: p[0], anchorY: p[1] });
          }
          S && x && (a.placed = !1), oe || x && !$ ? (a.show(), a.placed = !0) : (a.hide(), a.placed = !1);
        }
        function R() {
          return this.plotGroup("dataLabelsGroup", "data-labels", this.hasRendered ? "inherit" : "hidden", this.options.dataLabels.zIndex || 6);
        }
        function K(o) {
          let a = this.hasRendered || 0, c = this.initDataLabelsGroup().attr({ opacity: +a });
          return !a && c && (this.visible && c.show(), this.options.animation ? c.animate({ opacity: 1 }, o) : c.attr({ opacity: 1 })), c;
        }
        function I(o) {
          var oe;
          let a;
          o = o || this.points;
          let c = this, d = c.chart, S = c.options, P = d.renderer, { backgroundColor: G, plotBackgroundColor: x } = d.options.chart, Q = P.getContrast(b(x) && x || b(G) && G || "#000000"), J = h(c), { animation: ie, defer: te } = J[0], $ = te ? A(d, ie, c) : { defer: 0, duration: 0 };
          B(this, "drawDataLabels"), (oe = c.hasDataLabels) != null && oe.call(c) && (a = this.initDataLabels($), o.forEach((p) => {
            var f, L;
            let W = p.dataLabels || [];
            C(k(J, p.dlOptions || ((f = p.options) == null ? void 0 : f.dataLabels))).forEach((w, H) => {
              var de;
              let U = w.enabled && (p.visible || p.dataLabelOnHidden) && (!p.isNull || p.dataLabelOnNull) && function(ge, fe) {
                let ke = fe.filter;
                if (ke) {
                  let Pe = ke.operator, Ae = ge[ke.property], Le = ke.value;
                  return Pe === ">" && Ae > Le || Pe === "<" && Ae < Le || Pe === ">=" && Ae >= Le || Pe === "<=" && Ae <= Le || Pe === "==" && Ae == Le || Pe === "===" && Ae === Le || Pe === "!=" && Ae != Le || Pe === "!==" && Ae !== Le;
                }
                return !0;
              }(p, w), { backgroundColor: ee, borderColor: ae, distance: ne, style: he = {} } = w, me, ve, Me, Z, V = {}, re = W[H], le = !re, be;
              if (U && (ve = M(w[p.formatPrefix + "Format"], w.format), me = p.getLabelConfig(), Me = q(ve) ? Y(ve, me, d) : (w[p.formatPrefix + "Formatter"] || w.formatter).call(me, w), Z = w.rotation, !d.styledMode && (he.color = M(w.color, he.color, b(c.color) ? c.color : void 0, "#000000"), he.color === "contrast" ? (ee !== "none" && (be = ee), p.contrastColor = P.getContrast(be !== "auto" && be || p.color || c.color), he.color = be || !q(ne) && w.inside || 0 > g(ne || 0) || S.stacking ? p.contrastColor : Q) : delete p.contrastColor, S.cursor && (he.cursor = S.cursor)), V = { r: w.borderRadius || 0, rotation: Z, padding: w.padding, zIndex: 1 }, d.styledMode || (V.fill = ee === "auto" ? p.color : ee, V.stroke = ae === "auto" ? p.color : ae, V["stroke-width"] = w.borderWidth), E(V, (ge, fe) => {
                ge === void 0 && delete V[fe];
              })), !re || U && q(Me) && !!re.div == !!w.useHTML && (re.rotation && w.rotation || re.rotation === w.rotation) || (re = void 0, le = !0), U && q(Me) && (re ? V.text = Me : (re = P.label(Me, 0, 0, w.shape, void 0, void 0, w.useHTML, void 0, "data-label")).addClass(" highcharts-data-label-color-" + p.colorIndex + " " + (w.className || "") + (w.useHTML ? " highcharts-tracker" : "")), re)) {
                re.options = w, re.attr(V), d.styledMode || re.css(he).shadow(w.shadow);
                let ge = w[p.formatPrefix + "TextPath"] || w.textPath;
                ge && !w.useHTML && (re.setTextPath(((de = p.getDataLabelPath) == null ? void 0 : de.call(p, re)) || p.graphic, ge), p.dataLabelPath && !ge.enabled && (p.dataLabelPath = p.dataLabelPath.destroy())), re.added || re.add(a), c.alignDataLabel(p, re, w, void 0, le), re.isActive = !0, W[H] && W[H] !== re && W[H].destroy(), W[H] = re;
              }
            });
            let X = W.length;
            for (; X--; )
              W[X] && W[X].isActive ? W[X].isActive = !1 : ((L = W[X]) == null || L.destroy(), W.splice(X, 1));
            p.dataLabel = W[0], p.dataLabels = W;
          })), B(this, "afterDrawDataLabels");
        }
        function z(o, a, c, d, S, P) {
          let G = this.chart, x = a.align, Q = a.verticalAlign, J = o.box ? 0 : o.padding || 0, { x: ie = 0, y: te = 0 } = a, $, oe;
          return ($ = (c.x || 0) + J) < 0 && (x === "right" && ie >= 0 ? (a.align = "left", a.inside = !0) : ie -= $, oe = !0), ($ = (c.x || 0) + d.width - J) > G.plotWidth && (x === "left" && ie <= 0 ? (a.align = "right", a.inside = !0) : ie += G.plotWidth - $, oe = !0), ($ = c.y + J) < 0 && (Q === "bottom" && te >= 0 ? (a.verticalAlign = "top", a.inside = !0) : te -= $, oe = !0), ($ = (c.y || 0) + d.height - J) > G.plotHeight && (Q === "top" && te <= 0 ? (a.verticalAlign = "bottom", a.inside = !0) : te += G.plotHeight - $, oe = !0), oe && (a.x = ie, a.y = te, o.placed = !P, o.align(a, void 0, S)), oe;
        }
        function k(o, a) {
          let c = [], d;
          if (O(o) && !O(a))
            c = o.map(function(S) {
              return v(S, a);
            });
          else if (O(a) && !O(o))
            c = a.map(function(S) {
              return v(o, S);
            });
          else if (O(o) || O(a)) {
            if (O(o) && O(a))
              for (d = Math.max(o.length, a.length); d--; )
                c[d] = v(o[d], a[d]);
          } else
            c = v(o, a);
          return c;
        }
        function h(o) {
          var c, d;
          let a = o.chart.options.plotOptions;
          return C(k(k((c = a == null ? void 0 : a.series) == null ? void 0 : c.dataLabels, (d = a == null ? void 0 : a[o.type]) == null ? void 0 : d.dataLabels), o.options.dataLabels));
        }
        function F(o, a, c, d, S) {
          let P = this.chart, G = P.inverted, x = this.xAxis, Q = x.reversed, J = ((G ? a.height : a.width) || 0) / 2, ie = o.pointWidth, te = ie ? ie / 2 : 0;
          a.startXPos = G ? S.x : Q ? -J - te : x.width - J + te, a.startYPos = G ? Q ? this.yAxis.height - J + te : -J - te : S.y, d ? a.visibility === "hidden" && (a.show(), a.attr({ opacity: 0 }).animate({ opacity: 1 })) : a.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, a.hide), P.hasRendered && (c && a.attr({ x: a.startXPos, y: a.startYPos }), a.placed = !0);
        }
        j.compose = function(o) {
          let a = o.prototype;
          a.initDataLabels || (a.initDataLabels = K, a.initDataLabelsGroup = R, a.alignDataLabel = u, a.drawDataLabels = I, a.justifyDataLabel = z, a.setDataLabelStartPos = F, a.hasDataLabels = D);
        };
      }(m || (m = {})), m;
    }), i(e, "Series/Column/ColumnDataLabel.js", [e["Core/Series/DataLabel.js"], e["Core/Globals.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(n, s, l, m) {
      var A;
      let { composed: Y } = s, { series: q } = l, { merge: T, pick: B, pushUnique: O } = m;
      return function(b) {
        function v(E, M, g, C, j) {
          let D = this.chart.inverted, u = E.series, R = (u.xAxis ? u.xAxis.len : this.chart.plotSizeX) || 0, K = (u.yAxis ? u.yAxis.len : this.chart.plotSizeY) || 0, I = E.dlBox || E.shapeArgs, z = B(E.below, E.plotY > B(this.translatedThreshold, K)), k = B(g.inside, !!this.options.stacking);
          if (I) {
            if (C = T(I), !(g.overflow === "allow" && g.crop === !1)) {
              C.y < 0 && (C.height += C.y, C.y = 0);
              let h = C.y + C.height - K;
              h > 0 && h < C.height && (C.height -= h);
            }
            D && (C = { x: K - C.y - C.height, y: R - C.x - C.width, width: C.height, height: C.width }), k || (D ? (C.x += z ? 0 : C.width, C.width = 0) : (C.y += z ? C.height : 0, C.height = 0));
          }
          g.align = B(g.align, !D || k ? "center" : z ? "right" : "left"), g.verticalAlign = B(g.verticalAlign, D || k ? "middle" : z ? "top" : "bottom"), q.prototype.alignDataLabel.call(this, E, M, g, C, j), g.inside && E.contrastColor && M.css({ color: E.contrastColor });
        }
        b.compose = function(E) {
          n.compose(q), O(Y, "ColumnDataLabel") && (E.prototype.alignDataLabel = v);
        };
      }(A || (A = {})), A;
    }), i(e, "Series/Bar/BarSeries.js", [e["Series/Column/ColumnSeries.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(n, s, l) {
      let { extend: m, merge: A } = l;
      class Y extends n {
      }
      return Y.defaultOptions = A(n.defaultOptions, {}), m(Y.prototype, { inverted: !0 }), s.registerSeriesType("bar", Y), Y;
    }), i(e, "Series/Scatter/ScatterSeriesDefaults.js", [], function() {
      return { lineWidth: 0, findNearestPointBy: "xy", jitter: { x: 0, y: 0 }, marker: { enabled: !0 }, tooltip: { headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 0.8em"> {series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>" } };
    }), i(e, "Series/Scatter/ScatterSeries.js", [e["Series/Scatter/ScatterSeriesDefaults.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(n, s, l) {
      let { column: m, line: A } = s.seriesTypes, { addEvent: Y, extend: q, merge: T } = l;
      class B extends A {
        applyJitter() {
          let b = this, v = this.options.jitter, E = this.points.length;
          v && this.points.forEach(function(M, g) {
            ["x", "y"].forEach(function(C, j) {
              if (v[C] && !M.isNull) {
                let D = `plot${C.toUpperCase()}`, u = b[`${C}Axis`], R = v[C] * u.transA;
                if (u && !u.logarithmic) {
                  let K = Math.max(0, (M[D] || 0) - R), I = Math.min(u.len, (M[D] || 0) + R);
                  M[D] = K + (I - K) * function(z) {
                    let k = 1e4 * Math.sin(z);
                    return k - Math.floor(k);
                  }(g + j * E), C === "x" && (M.clientX = M.plotX);
                }
              }
            });
          });
        }
        drawGraph() {
          this.options.lineWidth ? super.drawGraph() : this.graph && (this.graph = this.graph.destroy());
        }
      }
      return B.defaultOptions = T(A.defaultOptions, n), q(B.prototype, { drawTracker: m.prototype.drawTracker, sorted: !1, requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["group", "markerGroup", "dataLabelsGroup"] }), Y(B, "afterTranslate", function() {
        this.applyJitter();
      }), s.registerSeriesType("scatter", B), B;
    }), i(e, "Series/CenteredUtilities.js", [e["Core/Globals.js"], e["Core/Series/Series.js"], e["Core/Utilities.js"]], function(n, s, l) {
      var m, A;
      let { deg2rad: Y } = n, { fireEvent: q, isNumber: T, pick: B, relativeLength: O } = l;
      return (A = m || (m = {})).getCenter = function() {
        let b = this.options, v = this.chart, E = 2 * (b.slicedOffset || 0), M = v.plotWidth - 2 * E, g = v.plotHeight - 2 * E, C = b.center, j = Math.min(M, g), D = b.thickness, u, R = b.size, K = b.innerSize || 0, I, z;
        typeof R == "string" && (R = parseFloat(R)), typeof K == "string" && (K = parseFloat(K));
        let k = [B(C[0], "50%"), B(C[1], "50%"), B(R && R < 0 ? void 0 : b.size, "100%"), B(K && K < 0 ? void 0 : b.innerSize || 0, "0%")];
        for (!v.angular || this instanceof s || (k[3] = 0), I = 0; I < 4; ++I)
          z = k[I], u = I < 2 || I === 2 && /%$/.test(z), k[I] = O(z, [M, g, j, k[2]][I]) + (u ? E : 0);
        return k[3] > k[2] && (k[3] = k[2]), T(D) && 2 * D < k[2] && D > 0 && (k[3] = k[2] - 2 * D), q(this, "afterGetCenter", { positions: k }), k;
      }, A.getStartAndEndRadians = function(b, v) {
        let E = T(b) ? b : 0, M = T(v) && v > E && v - E < 360 ? v : E + 360;
        return { start: Y * (E + -90), end: Y * (M + -90) };
      }, m;
    }), i(e, "Series/Pie/PiePoint.js", [e["Core/Animation/AnimationUtilities.js"], e["Core/Series/Point.js"], e["Core/Utilities.js"]], function(n, s, l) {
      let { setAnimation: m } = n, { addEvent: A, defined: Y, extend: q, isNumber: T, pick: B, relativeLength: O } = l;
      class b extends s {
        getConnectorPath(E) {
          let M = E.dataLabelPosition, g = E.options || {}, C = g.connectorShape, j = this.connectorShapes[C] || C;
          return M && j.call(this, { ...M.computed, alignment: M.alignment }, M.connectorPosition, g) || [];
        }
        getTranslate() {
          return this.sliced && this.slicedTranslation || { translateX: 0, translateY: 0 };
        }
        haloPath(E) {
          let M = this.shapeArgs;
          return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(M.x, M.y, M.r + E, M.r + E, { innerR: M.r - 1, start: M.start, end: M.end, borderRadius: M.borderRadius });
        }
        constructor(E, M, g) {
          super(E, M, g), this.half = 0, this.name ?? (this.name = "Slice");
          let C = (j) => {
            this.slice(j.type === "select");
          };
          A(this, "select", C), A(this, "unselect", C);
        }
        isValid() {
          return T(this.y) && this.y >= 0;
        }
        setVisible(E, M = !0) {
          E !== this.visible && this.update({ visible: E ?? !this.visible }, M, void 0, !1);
        }
        slice(E, M, g) {
          let C = this.series;
          m(g, C.chart), M = B(M, !0), this.sliced = this.options.sliced = E = Y(E) ? E : !this.sliced, C.options.data[C.data.indexOf(this)] = this.options, this.graphic && this.graphic.animate(this.getTranslate());
        }
      }
      return q(b.prototype, { connectorShapes: { fixedOffset: function(v, E, M) {
        let g = E.breakAt, C = E.touchingSliceAt, j = M.softConnector ? ["C", v.x + (v.alignment === "left" ? -5 : 5), v.y, 2 * g.x - C.x, 2 * g.y - C.y, g.x, g.y] : ["L", g.x, g.y];
        return [["M", v.x, v.y], j, ["L", C.x, C.y]];
      }, straight: function(v, E) {
        let M = E.touchingSliceAt;
        return [["M", v.x, v.y], ["L", M.x, M.y]];
      }, crookedLine: function(v, E, M) {
        let { breakAt: g, touchingSliceAt: C } = E, { series: j } = this, [D, u, R] = j.center, K = R / 2, { plotLeft: I, plotWidth: z } = j.chart, k = v.alignment === "left", { x: h, y: F } = v, o = g.x;
        if (M.crookDistance) {
          let c = O(M.crookDistance, 1);
          o = k ? D + K + (z + I - D - K) * (1 - c) : I + (D - K) * c;
        } else
          o = D + (u - F) * Math.tan((this.angle || 0) - Math.PI / 2);
        let a = [["M", h, F]];
        return (k ? o <= h && o >= g.x : o >= h && o <= g.x) && a.push(["L", o, F]), a.push(["L", g.x, g.y], ["L", C.x, C.y]), a;
      } } }), b;
    }), i(e, "Series/Pie/PieSeriesDefaults.js", [], function() {
      return { borderRadius: 3, center: [null, null], clip: !1, colorByPoint: !0, dataLabels: { connectorPadding: 5, connectorShape: "crookedLine", crookDistance: void 0, distance: 30, enabled: !0, formatter: function() {
        return this.point.isNull ? void 0 : this.point.name;
      }, softConnector: !0, x: 0 }, fillColor: void 0, ignoreHiddenPoint: !0, inactiveOtherPoints: !0, legendType: "point", marker: null, size: null, showInLegend: !1, slicedOffset: 10, stickyTracking: !1, tooltip: { followPointer: !0 }, borderColor: "#ffffff", borderWidth: 1, lineWidth: void 0, states: { hover: { brightness: 0.1 } } };
    }), i(e, "Series/Pie/PieSeries.js", [e["Series/CenteredUtilities.js"], e["Series/Column/ColumnSeries.js"], e["Core/Globals.js"], e["Series/Pie/PiePoint.js"], e["Series/Pie/PieSeriesDefaults.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Renderer/SVG/Symbols.js"], e["Core/Utilities.js"]], function(n, s, l, m, A, Y, q, T, B) {
      let { getStartAndEndRadians: O } = n, { noop: b } = l, { clamp: v, extend: E, fireEvent: M, merge: g, pick: C } = B;
      class j extends Y {
        animate(u) {
          let R = this, K = R.points, I = R.startAngleRad;
          u || K.forEach(function(z) {
            let k = z.graphic, h = z.shapeArgs;
            k && h && (k.attr({ r: C(z.startR, R.center && R.center[3] / 2), start: I, end: I }), k.animate({ r: h.r, start: h.start, end: h.end }, R.options.animation));
          });
        }
        drawEmpty() {
          let u, R, K = this.startAngleRad, I = this.endAngleRad, z = this.options;
          this.total === 0 && this.center ? (u = this.center[0], R = this.center[1], this.graph || (this.graph = this.chart.renderer.arc(u, R, this.center[1] / 2, 0, K, I).addClass("highcharts-empty-series").add(this.group)), this.graph.attr({ d: T.arc(u, R, this.center[2] / 2, 0, { start: K, end: I, innerR: this.center[3] / 2 }) }), this.chart.styledMode || this.graph.attr({ "stroke-width": z.borderWidth, fill: z.fillColor || "none", stroke: z.color || "#cccccc" })) : this.graph && (this.graph = this.graph.destroy());
        }
        drawPoints() {
          let u = this.chart.renderer;
          this.points.forEach(function(R) {
            R.graphic && R.hasNewShapeType() && (R.graphic = R.graphic.destroy()), R.graphic || (R.graphic = u[R.shapeType](R.shapeArgs).add(R.series.group), R.delayedRendering = !0);
          });
        }
        generatePoints() {
          super.generatePoints(), this.updateTotals();
        }
        getX(u, R, K, I) {
          let z = this.center, k = this.radii ? this.radii[K.index] || 0 : z[2] / 2, h = I.dataLabelPosition, F = (h == null ? void 0 : h.distance) || 0, o = Math.asin(v((u - z[1]) / (k + F), -1, 1));
          return z[0] + Math.cos(o) * (k + F) * (R ? -1 : 1) + (F > 0 ? (R ? -1 : 1) * (I.padding || 0) : 0);
        }
        hasData() {
          return !!this.processedXData.length;
        }
        redrawPoints() {
          let u, R, K, I, z = this, k = z.chart;
          this.drawEmpty(), z.group && !k.styledMode && z.group.shadow(z.options.shadow), z.points.forEach(function(h) {
            let F = {};
            R = h.graphic, !h.isNull && R ? (I = h.shapeArgs, u = h.getTranslate(), k.styledMode || (K = z.pointAttribs(h, h.selected && "select")), h.delayedRendering ? (R.setRadialReference(z.center).attr(I).attr(u), k.styledMode || R.attr(K).attr({ "stroke-linejoin": "round" }), h.delayedRendering = !1) : (R.setRadialReference(z.center), k.styledMode || g(!0, F, K), g(!0, F, I, u), R.animate(F)), R.attr({ visibility: h.visible ? "inherit" : "hidden" }), R.addClass(h.getClassName(), !0)) : R && (h.graphic = R.destroy());
          });
        }
        sortByAngle(u, R) {
          u.sort(function(K, I) {
            return K.angle !== void 0 && (I.angle - K.angle) * R;
          });
        }
        translate(u) {
          M(this, "translate"), this.generatePoints();
          let R = this.options, K = R.slicedOffset, I = O(R.startAngle, R.endAngle), z = this.startAngleRad = I.start, k = (this.endAngleRad = I.end) - z, h = this.points, F = R.ignoreHiddenPoint, o = h.length, a, c, d, S, P, G, x, Q = 0;
          for (u || (this.center = u = this.getCenter()), G = 0; G < o; G++) {
            x = h[G], a = z + Q * k, x.isValid() && (!F || x.visible) && (Q += x.percentage / 100), c = z + Q * k;
            let J = { x: u[0], y: u[1], r: u[2] / 2, innerR: u[3] / 2, start: Math.round(1e3 * a) / 1e3, end: Math.round(1e3 * c) / 1e3 };
            x.shapeType = "arc", x.shapeArgs = J, (d = (c + a) / 2) > 1.5 * Math.PI ? d -= 2 * Math.PI : d < -Math.PI / 2 && (d += 2 * Math.PI), x.slicedTranslation = { translateX: Math.round(Math.cos(d) * K), translateY: Math.round(Math.sin(d) * K) }, S = Math.cos(d) * u[2] / 2, P = Math.sin(d) * u[2] / 2, x.tooltipPos = [u[0] + 0.7 * S, u[1] + 0.7 * P], x.half = d < -Math.PI / 2 || d > Math.PI / 2 ? 1 : 0, x.angle = d;
          }
          M(this, "afterTranslate");
        }
        updateTotals() {
          let u = this.points, R = u.length, K = this.options.ignoreHiddenPoint, I, z, k = 0;
          for (I = 0; I < R; I++)
            (z = u[I]).isValid() && (!K || z.visible) && (k += z.y);
          for (I = 0, this.total = k; I < R; I++)
            (z = u[I]).percentage = k > 0 && (z.visible || !K) ? z.y / k * 100 : 0, z.total = k;
        }
      }
      return j.defaultOptions = g(Y.defaultOptions, A), E(j.prototype, { axisTypes: [], directTouch: !0, drawGraph: void 0, drawTracker: s.prototype.drawTracker, getCenter: n.getCenter, getSymbol: b, invertible: !1, isCartesian: !1, noSharedTooltip: !0, pointAttribs: s.prototype.pointAttribs, pointClass: m, requireSorting: !1, searchPoint: b, trackerGroups: ["group", "dataLabelsGroup"] }), q.registerSeriesType("pie", j), j;
    }), i(e, "Series/Pie/PieDataLabel.js", [e["Core/Series/DataLabel.js"], e["Core/Globals.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Series/SeriesRegistry.js"], e["Core/Utilities.js"]], function(n, s, l, m, A) {
      var Y;
      let { composed: q, noop: T } = s, { distribute: B } = l, { series: O } = m, { arrayMax: b, clamp: v, defined: E, pick: M, pushUnique: g, relativeLength: C } = A;
      return function(j) {
        let D = { radialDistributionY: function(z, k) {
          var h;
          return (((h = k.dataLabelPosition) == null ? void 0 : h.top) || 0) + z.distributeBox.pos;
        }, radialDistributionX: function(z, k, h, F, o) {
          let a = o.dataLabelPosition;
          return z.getX(h < ((a == null ? void 0 : a.top) || 0) + 2 || h > ((a == null ? void 0 : a.bottom) || 0) - 2 ? F : h, k.half, k, o);
        }, justify: function(z, k, h, F) {
          var o;
          return F[0] + (z.half ? -1 : 1) * (h + (((o = k.dataLabelPosition) == null ? void 0 : o.distance) || 0));
        }, alignToPlotEdges: function(z, k, h, F) {
          let o = z.getBBox().width;
          return k ? o + F : h - o - F;
        }, alignToConnectors: function(z, k, h, F) {
          let o = 0, a;
          return z.forEach(function(c) {
            (a = c.dataLabel.getBBox().width) > o && (o = a);
          }), k ? o + F : h - o - F;
        } };
        function u(z, k) {
          let { center: h, options: F } = this, o = h[2] / 2, a = z.angle || 0, c = Math.cos(a), d = Math.sin(a), S = h[0] + c * o, P = h[1] + d * o, G = Math.min((F.slicedOffset || 0) + (F.borderWidth || 0), k / 5);
          return { natural: { x: S + c * k, y: P + d * k }, computed: {}, alignment: k < 0 ? "center" : z.half ? "right" : "left", connectorPosition: { breakAt: { x: S + c * G, y: P + d * G }, touchingSliceAt: { x: S, y: P } }, distance: k };
        }
        function R() {
          var oe;
          let z = this, k = z.points, h = z.chart, F = h.plotWidth, o = h.plotHeight, a = h.plotLeft, c = Math.round(h.chartWidth / 3), d = z.center, S = d[2] / 2, P = d[1], G = [[], []], x = [0, 0, 0, 0], Q = z.dataLabelPositioners, J, ie, te, $ = 0;
          z.visible && ((oe = z.hasDataLabels) != null && oe.call(z)) && (k.forEach((p) => {
            (p.dataLabels || []).forEach((W) => {
              W.shortened && (W.attr({ width: "auto" }).css({ width: "auto", textOverflow: "clip" }), W.shortened = !1);
            });
          }), O.prototype.drawDataLabels.apply(z), k.forEach((p) => {
            (p.dataLabels || []).forEach((W, X) => {
              var H;
              let f = d[2] / 2, L = W.options, w = C((L == null ? void 0 : L.distance) || 0, f);
              X === 0 && G[p.half].push(p), !E((H = L == null ? void 0 : L.style) == null ? void 0 : H.width) && W.getBBox().width > c && (W.css({ width: Math.round(0.7 * c) + "px" }), W.shortened = !0), W.dataLabelPosition = this.getDataLabelPosition(p, w), $ = Math.max($, w);
            });
          }), G.forEach((p, W) => {
            let X = p.length, f = [], L, w, H = 0, U;
            X && (z.sortByAngle(p, W - 0.5), $ > 0 && (L = Math.max(0, P - S - $), w = Math.min(P + S + $, h.plotHeight), p.forEach((ee) => {
              (ee.dataLabels || []).forEach((ae) => {
                var he;
                let ne = ae.dataLabelPosition;
                ne && ne.distance > 0 && (ne.top = Math.max(0, P - S - ne.distance), ne.bottom = Math.min(P + S + ne.distance, h.plotHeight), H = ae.getBBox().height || 21, ee.distributeBox = { target: (((he = ae.dataLabelPosition) == null ? void 0 : he.natural.y) || 0) - ne.top + H / 2, size: H, rank: ee.y }, f.push(ee.distributeBox));
              });
            }), B(f, U = w + H - L, U / 5)), p.forEach((ee) => {
              (ee.dataLabels || []).forEach((ae) => {
                let ne = ae.options || {}, he = ee.distributeBox, me = ae.dataLabelPosition, ve = (me == null ? void 0 : me.natural.y) || 0, Me = ne.connectorPadding || 0, Z = 0, V = ve, re = "inherit";
                if (me) {
                  if (f && E(he) && me.distance > 0 && (he.pos === void 0 ? re = "hidden" : (te = he.size, V = Q.radialDistributionY(ee, ae))), ne.justify)
                    Z = Q.justify(ee, ae, S, d);
                  else
                    switch (ne.alignTo) {
                      case "connectors":
                        Z = Q.alignToConnectors(p, W, F, a);
                        break;
                      case "plotEdges":
                        Z = Q.alignToPlotEdges(ae, W, F, a);
                        break;
                      default:
                        Z = Q.radialDistributionX(z, ee, V, ve, ae);
                    }
                  if (me.attribs = { visibility: re, align: me.alignment }, me.posAttribs = { x: Z + (ne.x || 0) + ({ left: Me, right: -Me }[me.alignment] || 0), y: V + (ne.y || 0) - ae.getBBox().height / 2 }, me.computed.x = Z, me.computed.y = V, M(ne.crop, !0)) {
                    let le;
                    Z - (ie = ae.getBBox().width) < Me && W === 1 ? (le = Math.round(ie - Z + Me), x[3] = Math.max(le, x[3])) : Z + ie > F - Me && W === 0 && (le = Math.round(Z + ie - F + Me), x[1] = Math.max(le, x[1])), V - te / 2 < 0 ? x[0] = Math.max(Math.round(-V + te / 2), x[0]) : V + te / 2 > o && (x[2] = Math.max(Math.round(V + te / 2 - o), x[2])), me.sideOverflow = le;
                  }
                }
              });
            }));
          }), (b(x) === 0 || this.verifyDataLabelOverflow(x)) && (this.placeDataLabels(), this.points.forEach((p) => {
            (p.dataLabels || []).forEach((W) => {
              var w;
              let { connectorColor: X, connectorWidth: f = 1 } = W.options || {}, L = W.dataLabelPosition;
              if (f) {
                let H;
                J = W.connector, L && L.distance > 0 ? (H = !J, J || (W.connector = J = h.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + p.colorIndex + (p.className ? " " + p.className : "")).add(z.dataLabelsGroup)), h.styledMode || J.attr({ "stroke-width": f, stroke: X || p.color || "#666666" }), J[H ? "attr" : "animate"]({ d: p.getConnectorPath(W) }), J.attr({ visibility: (w = L.attribs) == null ? void 0 : w.visibility })) : J && (W.connector = J.destroy());
              }
            });
          })));
        }
        function K() {
          this.points.forEach((z) => {
            (z.dataLabels || []).forEach((k) => {
              var F;
              let h = k.dataLabelPosition;
              h ? (h.sideOverflow && (k.css({ width: Math.max(k.getBBox().width - h.sideOverflow, 0) + "px", textOverflow: (((F = k.options) == null ? void 0 : F.style) || {}).textOverflow || "ellipsis" }), k.shortened = !0), k.attr(h.attribs), k[k.moved ? "animate" : "attr"](h.posAttribs), k.moved = !0) : k && k.attr({ y: -9999 });
            }), delete z.distributeBox;
          }, this);
        }
        function I(z) {
          let k = this.center, h = this.options, F = h.center, o = h.minSize || 80, a = o, c = h.size !== null;
          return !c && (F[0] !== null ? a = Math.max(k[2] - Math.max(z[1], z[3]), o) : (a = Math.max(k[2] - z[1] - z[3], o), k[0] += (z[3] - z[1]) / 2), F[1] !== null ? a = v(a, o, k[2] - Math.max(z[0], z[2])) : (a = v(a, o, k[2] - z[0] - z[2]), k[1] += (z[0] - z[2]) / 2), a < k[2] ? (k[2] = a, k[3] = Math.min(h.thickness ? Math.max(0, a - 2 * h.thickness) : Math.max(0, C(h.innerSize || 0, a)), a), this.translate(k), this.drawDataLabels && this.drawDataLabels()) : c = !0), c;
        }
        j.compose = function(z) {
          if (n.compose(O), g(q, "PieDataLabel")) {
            let k = z.prototype;
            k.dataLabelPositioners = D, k.alignDataLabel = T, k.drawDataLabels = R, k.getDataLabelPosition = u, k.placeDataLabels = K, k.verifyDataLabelOverflow = I;
          }
        };
      }(Y || (Y = {})), Y;
    }), i(e, "Extensions/OverlappingDataLabels.js", [e["Core/Utilities.js"]], function(n) {
      let { addEvent: s, fireEvent: l, objectEach: m, pick: A } = n;
      function Y(B) {
        let O = B.length, b = (D, u) => !(u.x >= D.x + D.width || u.x + u.width <= D.x || u.y >= D.y + D.height || u.y + u.height <= D.y), v, E, M, g, C, j = !1;
        for (let D = 0; D < O; D++)
          (v = B[D]) && (v.oldOpacity = v.opacity, v.newOpacity = 1, v.absoluteBox = function(u) {
            var R, K;
            if (u && (!u.alignAttr || u.placed)) {
              let I = u.box ? 0 : u.padding || 0, z = u.alignAttr || { x: u.attr("x"), y: u.attr("y") }, k = u.getBBox();
              return u.width = k.width, u.height = k.height, { x: z.x + (((R = u.parentGroup) == null ? void 0 : R.translateX) || 0) + I, y: z.y + (((K = u.parentGroup) == null ? void 0 : K.translateY) || 0) + I, width: (u.width || 0) - 2 * I, height: (u.height || 0) - 2 * I };
            }
          }(v));
        B.sort((D, u) => (u.labelrank || 0) - (D.labelrank || 0));
        for (let D = 0; D < O; ++D) {
          g = (E = B[D]) && E.absoluteBox;
          for (let u = D + 1; u < O; ++u)
            C = (M = B[u]) && M.absoluteBox, g && C && E !== M && E.newOpacity !== 0 && M.newOpacity !== 0 && E.visibility !== "hidden" && M.visibility !== "hidden" && b(g, C) && ((E.labelrank < M.labelrank ? E : M).newOpacity = 0);
        }
        for (let D of B)
          q(D, this) && (j = !0);
        j && l(this, "afterHideAllOverlappingLabels");
      }
      function q(B, O) {
        let b, v, E = !1;
        return B && (v = B.newOpacity, B.oldOpacity !== v && (B.hasClass("highcharts-data-label") ? (B[v ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), b = function() {
          O.styledMode || B.css({ pointerEvents: v ? "auto" : "none" });
        }, E = !0, B[B.isOld ? "animate" : "attr"]({ opacity: v }, void 0, b), l(O, "afterHideOverlappingLabel")) : B.attr({ opacity: v })), B.isOld = !0), E;
      }
      function T() {
        var b;
        let B = this, O = [];
        for (let v of B.labelCollectors || [])
          O = O.concat(v());
        for (let v of B.yAxis || [])
          v.stacking && v.options.stackLabels && !v.options.stackLabels.allowOverlap && m(v.stacking.stacks, (E) => {
            m(E, (M) => {
              M.label && O.push(M.label);
            });
          });
        for (let v of B.series || [])
          if (v.visible && ((b = v.hasDataLabels) != null && b.call(v))) {
            let E = (M) => {
              for (let g of M)
                g.visible && (g.dataLabels || []).forEach((C) => {
                  var D;
                  let j = C.options || {};
                  C.labelrank = A(j.labelrank, g.labelrank, (D = g.shapeArgs) == null ? void 0 : D.height), j.allowOverlap ?? Number(j.distance) > 0 ? (C.oldOpacity = C.opacity, C.newOpacity = 1, q(C, B)) : O.push(C);
                });
            };
            E(v.nodes || []), E(v.points);
          }
        this.hideOverlappingLabels(O);
      }
      return { compose: function(B) {
        let O = B.prototype;
        O.hideOverlappingLabels || (O.hideOverlappingLabels = Y, s(B, "render", T));
      } };
    }), i(e, "Extensions/BorderRadius.js", [e["Core/Defaults.js"], e["Core/Globals.js"], e["Core/Utilities.js"]], function(n, s, l) {
      let { defaultOptions: m } = n, { noop: A } = s, { addEvent: Y, extend: q, isObject: T, merge: B, relativeLength: O } = l, b = { radius: 0, scope: "stack", where: void 0 }, v = A, E = A;
      function M(u, R, K, I, z = {}) {
        let k = v(u, R, K, I, z), { innerR: h = 0, r: F = K, start: o = 0, end: a = 0 } = z;
        if (z.open || !z.borderRadius)
          return k;
        let c = a - o, d = Math.sin(c / 2), S = Math.max(Math.min(O(z.borderRadius || 0, F - h), (F - h) / 2, F * d / (1 + d)), 0), P = Math.min(S, c / Math.PI * 2 * h), G = k.length - 1;
        for (; G--; )
          (function(x, Q, J) {
            let ie, te, $, oe = x[Q], p = x[Q + 1];
            if (p[0] === "Z" && (p = x[0]), (oe[0] === "M" || oe[0] === "L") && p[0] === "A" ? (ie = oe, te = p, $ = !0) : oe[0] === "A" && (p[0] === "M" || p[0] === "L") && (ie = p, te = oe), ie && te && te.params) {
              let W = te[1], X = te[5], f = te.params, { start: L, end: w, cx: H, cy: U } = f, ee = X ? W - J : W + J, ae = ee ? Math.asin(J / ee) : 0, ne = X ? ae : -ae, he = Math.cos(ae) * ee;
              $ ? (f.start = L + ne, ie[1] = H + he * Math.cos(L), ie[2] = U + he * Math.sin(L), x.splice(Q + 1, 0, ["A", J, J, 0, 0, 1, H + W * Math.cos(f.start), U + W * Math.sin(f.start)])) : (f.end = w - ne, te[6] = H + W * Math.cos(f.end), te[7] = U + W * Math.sin(f.end), x.splice(Q + 1, 0, ["A", J, J, 0, 0, 1, H + he * Math.cos(w), U + he * Math.sin(w)])), te[4] = Math.abs(f.end - f.start) < Math.PI ? 0 : 1;
            }
          })(k, G, G > 1 ? P : S);
        return k;
      }
      function g() {
        var u, R;
        if (this.options.borderRadius && !(this.chart.is3d && this.chart.is3d())) {
          let { options: K, yAxis: I } = this, z = K.stacking === "percent", k = (R = (u = m.plotOptions) == null ? void 0 : u[this.type]) == null ? void 0 : R.borderRadius, h = C(K.borderRadius, T(k) ? k : {}), F = I.options.reversed;
          for (let o of this.points) {
            let { shapeArgs: a } = o;
            if (o.shapeType === "roundedRect" && a) {
              let { width: c = 0, height: d = 0, y: S = 0 } = a, P = S, G = d;
              if (h.scope === "stack" && o.stackTotal) {
                let ie = I.translate(z ? 100 : o.stackTotal, !1, !0, !1, !0), te = I.translate(K.threshold || 0, !1, !0, !1, !0), $ = this.crispCol(0, Math.min(ie, te), 0, Math.abs(ie - te));
                P = $.y, G = $.height;
              }
              let x = (o.negative ? -1 : 1) * (F ? -1 : 1) == -1, Q = h.where;
              !Q && this.is("waterfall") && Math.abs((o.yBottom || 0) - (this.translatedThreshold || 0)) > this.borderWidth && (Q = "all"), Q || (Q = "end");
              let J = Math.min(O(h.radius, c), c / 2, Q === "all" ? d / 2 : 1 / 0) || 0;
              Q === "end" && (x && (P -= J), G += J), q(a, { brBoxHeight: G, brBoxY: P, r: J });
            }
          }
        }
      }
      function C(u, R) {
        return T(u) || (u = { radius: u || 0 }), B(b, R, u);
      }
      function j() {
        let u = C(this.options.borderRadius);
        for (let R of this.points) {
          let K = R.shapeArgs;
          K && (K.borderRadius = O(u.radius, (K.r || 0) - (K.innerR || 0)));
        }
      }
      function D(u, R, K, I, z = {}) {
        let k = E(u, R, K, I, z), { r: h = 0, brBoxHeight: F = I, brBoxY: o = R } = z, a = R - o, c = o + F - (R + I), d = a - h > -0.1 ? 0 : h, S = c - h > -0.1 ? 0 : h, P = Math.max(d && a, 0), G = Math.max(S && c, 0), x = [u + d, R], Q = [u + K - d, R], J = [u + K, R + d], ie = [u + K, R + I - S], te = [u + K - S, R + I], $ = [u + S, R + I], oe = [u, R + I - S], p = [u, R + d], W = (X, f) => Math.sqrt(Math.pow(X, 2) - Math.pow(f, 2));
        if (P) {
          let X = W(d, d - P);
          x[0] -= X, Q[0] += X, J[1] = p[1] = R + d - P;
        }
        if (I < d - P) {
          let X = W(d, d - P - I);
          J[0] = ie[0] = u + K - d + X, te[0] = Math.min(J[0], te[0]), $[0] = Math.max(ie[0], $[0]), oe[0] = p[0] = u + d - X, J[1] = p[1] = R + I;
        }
        if (G) {
          let X = W(S, S - G);
          te[0] += X, $[0] -= X, ie[1] = oe[1] = R + I - S + G;
        }
        if (I < S - G) {
          let X = W(S, S - G - I);
          J[0] = ie[0] = u + K - S + X, Q[0] = Math.min(J[0], Q[0]), x[0] = Math.max(ie[0], x[0]), oe[0] = p[0] = u + S - X, ie[1] = oe[1] = R;
        }
        return k.length = 0, k.push(["M", ...x], ["L", ...Q], ["A", d, d, 0, 0, 1, ...J], ["L", ...ie], ["A", S, S, 0, 0, 1, ...te], ["L", ...$], ["A", S, S, 0, 0, 1, ...oe], ["L", ...p], ["A", d, d, 0, 0, 1, ...x], ["Z"]), k;
      }
      return { compose: function(u, R, K) {
        let I = u.types.pie;
        if (!R.symbolCustomAttribs.includes("borderRadius")) {
          let z = K.prototype.symbols;
          Y(u, "afterColumnTranslate", g, { order: 9 }), Y(I, "afterTranslate", j), R.symbolCustomAttribs.push("borderRadius", "brBoxHeight", "brBoxY"), v = z.arc, E = z.roundedRect, z.arc = M, z.roundedRect = D;
        }
      }, optionsToObject: C };
    }), i(e, "Core/Responsive.js", [e["Core/Utilities.js"]], function(n) {
      var s;
      let { diffObjects: l, extend: m, find: A, merge: Y, pick: q, uniqueKey: T } = n;
      return function(B) {
        function O(v, E) {
          let M = v.condition;
          (M.callback || function() {
            return this.chartWidth <= q(M.maxWidth, Number.MAX_VALUE) && this.chartHeight <= q(M.maxHeight, Number.MAX_VALUE) && this.chartWidth >= q(M.minWidth, 0) && this.chartHeight >= q(M.minHeight, 0);
          }).call(this) && E.push(v._id);
        }
        function b(v, E) {
          let M = this.options.responsive, g = this.currentResponsive, C = [], j;
          !E && M && M.rules && M.rules.forEach((R) => {
            R._id === void 0 && (R._id = T()), this.matchResponsiveRule(R, C);
          }, this);
          let D = Y(...C.map((R) => A((M || {}).rules || [], (K) => K._id === R)).map((R) => R && R.chartOptions));
          D.isResponsiveOptions = !0, C = C.toString() || void 0;
          let u = g && g.ruleIds;
          C !== u && (g && this.update(g.undoOptions, v, !0), C ? ((j = l(D, this.options, !0, this.collectionsWithUpdate)).isResponsiveOptions = !0, this.currentResponsive = { ruleIds: C, mergedOptions: D, undoOptions: j }, this.update(D, v, !0)) : this.currentResponsive = void 0);
        }
        B.compose = function(v) {
          let E = v.prototype;
          return E.matchResponsiveRule || m(E, { matchResponsiveRule: O, setResponsive: b }), v;
        };
      }(s || (s = {})), s;
    }), i(e, "masters/highcharts.src.js", [e["Core/Globals.js"], e["Core/Utilities.js"], e["Core/Defaults.js"], e["Core/Animation/Fx.js"], e["Core/Animation/AnimationUtilities.js"], e["Core/Renderer/HTML/AST.js"], e["Core/Templating.js"], e["Core/Renderer/RendererRegistry.js"], e["Core/Renderer/RendererUtilities.js"], e["Core/Renderer/SVG/SVGElement.js"], e["Core/Renderer/SVG/SVGRenderer.js"], e["Core/Renderer/HTML/HTMLElement.js"], e["Core/Axis/Axis.js"], e["Core/Axis/DateTimeAxis.js"], e["Core/Axis/LogarithmicAxis.js"], e["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], e["Core/Axis/Tick.js"], e["Core/Tooltip.js"], e["Core/Series/Point.js"], e["Core/Pointer.js"], e["Core/Legend/Legend.js"], e["Core/Legend/LegendSymbol.js"], e["Core/Chart/Chart.js"], e["Extensions/ScrollablePlotArea.js"], e["Core/Axis/Stacking/StackingAxis.js"], e["Core/Axis/Stacking/StackItem.js"], e["Core/Series/Series.js"], e["Core/Series/SeriesRegistry.js"], e["Series/Column/ColumnDataLabel.js"], e["Series/Pie/PieDataLabel.js"], e["Core/Series/DataLabel.js"], e["Extensions/OverlappingDataLabels.js"], e["Extensions/BorderRadius.js"], e["Core/Responsive.js"], e["Core/Color/Color.js"], e["Core/Time.js"]], function(n, s, l, m, A, Y, q, T, B, O, b, v, E, M, g, C, j, D, u, R, K, I, z, k, h, F, o, a, c, d, S, P, G, x, Q, J) {
      return n.AST = Y, n.Axis = E, n.Chart = z, n.Color = Q, n.DataLabel = S, n.Fx = m, n.HTMLElement = v, n.Legend = K, n.LegendSymbol = I, n.OverlappingDataLabels = n.OverlappingDataLabels || P, n.PlotLineOrBand = C, n.Point = u, n.Pointer = R, n.RendererRegistry = T, n.Series = o, n.SeriesRegistry = a, n.StackItem = F, n.SVGElement = O, n.SVGRenderer = b, n.Templating = q, n.Tick = j, n.Time = J, n.Tooltip = D, n.animate = A.animate, n.animObject = A.animObject, n.chart = z.chart, n.color = Q.parse, n.dateFormat = q.dateFormat, n.defaultOptions = l.defaultOptions, n.distribute = B.distribute, n.format = q.format, n.getDeferredAnimation = A.getDeferredAnimation, n.getOptions = l.getOptions, n.numberFormat = q.numberFormat, n.seriesType = a.seriesType, n.setAnimation = A.setAnimation, n.setOptions = l.setOptions, n.stop = A.stop, n.time = l.defaultTime, n.timers = m.timers, G.compose(n.Series, n.SVGElement, n.SVGRenderer), c.compose(n.Series.types.column), S.compose(n.Series), M.compose(n.Axis), v.compose(n.SVGRenderer), K.compose(n.Chart), g.compose(n.Axis), P.compose(n.Chart), d.compose(n.Series.types.pie), C.compose(n.Axis), R.compose(n.Chart), x.compose(n.Chart), k.compose(n.Axis, n.Chart, n.Series), h.compose(n.Axis, n.Chart, n.Series), D.compose(n.Pointer), s.extend(n, s), n;
    }), e["masters/highcharts.src.js"]._modules = e, e["masters/highcharts.src.js"];
  });
})(ch);
var xm = ch.exports;
const hh = /* @__PURE__ */ To(xm);
var dh = { exports: {} };
(function(t, r) {
  (function(e, i) {
    t.exports = i(Qt);
  })(typeof self < "u" ? self : Mo, function(e) {
    return function(i) {
      function n(l) {
        if (s[l])
          return s[l].exports;
        var m = s[l] = { i: l, l: !1, exports: {} };
        return i[l].call(m.exports, m, m.exports, n), m.l = !0, m.exports;
      }
      var s = {};
      return n.m = i, n.c = s, n.d = function(l, m, A) {
        n.o(l, m) || Object.defineProperty(l, m, { configurable: !1, enumerable: !0, get: A });
      }, n.n = function(l) {
        var m = l && l.__esModule ? function() {
          return l.default;
        } : function() {
          return l;
        };
        return n.d(m, "a", m), m;
      }, n.o = function(l, m) {
        return Object.prototype.hasOwnProperty.call(l, m);
      }, n.p = "", n(n.s = 0);
    }([function(i, n, s) {
      function l() {
        return l = Object.assign ? Object.assign.bind() : function(g) {
          for (var C = 1; C < arguments.length; C++) {
            var j = arguments[C];
            for (var D in j)
              Object.prototype.hasOwnProperty.call(j, D) && (g[D] = j[D]);
          }
          return g;
        }, l.apply(this, arguments);
      }
      function m(g) {
        return T(g) || q(g) || Y(g) || A();
      }
      function A() {
        throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      function Y(g, C) {
        if (g) {
          if (typeof g == "string")
            return B(g, C);
          var j = Object.prototype.toString.call(g).slice(8, -1);
          return j === "Object" && g.constructor && (j = g.constructor.name), j === "Map" || j === "Set" ? Array.from(g) : j === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(j) ? B(g, C) : void 0;
        }
      }
      function q(g) {
        if (typeof Symbol < "u" && g[Symbol.iterator] != null || g["@@iterator"] != null)
          return Array.from(g);
      }
      function T(g) {
        if (Array.isArray(g))
          return B(g);
      }
      function B(g, C) {
        (C == null || C > g.length) && (C = g.length);
        for (var j = 0, D = new Array(C); j < C; j++)
          D[j] = g[j];
        return D;
      }
      function O(g) {
        "@babel/helpers - typeof";
        return (O = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(C) {
          return typeof C;
        } : function(C) {
          return C && typeof Symbol == "function" && C.constructor === Symbol && C !== Symbol.prototype ? "symbol" : typeof C;
        })(g);
      }
      Object.defineProperty(n, "__esModule", { value: !0 }), s.d(n, "HighchartsReact", function() {
        return M;
      });
      var b = s(1), v = s.n(b), E = typeof window < "u" ? b.useLayoutEffect : b.useEffect, M = Object(b.memo)(Object(b.forwardRef)(function(g, C) {
        var j = Object(b.useRef)(), D = Object(b.useRef)(), u = Object(b.useRef)(g.constructorType), R = Object(b.useRef)(g.highcharts);
        return E(function() {
          function K() {
            var z = g.highcharts || (typeof window > "u" ? "undefined" : O(window)) === "object" && window.Highcharts, k = g.constructorType || "chart";
            z ? z[k] ? g.options ? D.current = z[k](j.current, g.options, g.callback) : console.warn('The "options" property was not passed.') : console.warn('The "constructorType" property is incorrect or some required module is not imported.') : console.warn('The "highcharts" property was not passed.');
          }
          if (D.current) {
            if (g.allowChartUpdate !== !1)
              if (g.constructorType !== u.current || g.highcharts !== R.current)
                u.current = g.constructorType, R.current = g.highcharts, K();
              else if (!g.immutable && D.current) {
                var I;
                (I = D.current).update.apply(I, [g.options].concat(m(g.updateArgs || [!0, !0])));
              } else
                K();
          } else
            K();
        }, [g.options, g.allowChartUpdate, g.updateArgs, g.containerProps, g.highcharts, g.constructorType]), E(function() {
          return function() {
            D.current && (D.current.destroy(), D.current = null);
          };
        }, []), Object(b.useImperativeHandle)(C, function() {
          return { get chart() {
            return D.current;
          }, container: j };
        }, []), v.a.createElement("div", l({}, g.containerProps, { ref: j }));
      }));
      n.default = M;
    }, function(i, n) {
      i.exports = e;
    }]);
  });
})(dh);
var wm = dh.exports;
const uh = /* @__PURE__ */ To(wm);
var ts = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, mn = typeof window > "u" || "Deno" in globalThis;
function br() {
}
function km(t, r) {
  return typeof t == "function" ? t(r) : t;
}
function _a(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function fh(t, r) {
  return Math.max(t + (r || 0) - Date.now(), 0);
}
function gc(t, r) {
  const {
    type: e = "all",
    exact: i,
    fetchStatus: n,
    predicate: s,
    queryKey: l,
    stale: m
  } = t;
  if (l) {
    if (i) {
      if (r.queryHash !== Oo(l, r.options))
        return !1;
    } else if (!Wn(r.queryKey, l))
      return !1;
  }
  if (e !== "all") {
    const A = r.isActive();
    if (e === "active" && !A || e === "inactive" && A)
      return !1;
  }
  return !(typeof m == "boolean" && r.isStale() !== m || n && n !== r.state.fetchStatus || s && !s(r));
}
function mc(t, r) {
  const { exact: e, status: i, predicate: n, mutationKey: s } = t;
  if (s) {
    if (!r.options.mutationKey)
      return !1;
    if (e) {
      if (Bn(r.options.mutationKey) !== Bn(s))
        return !1;
    } else if (!Wn(r.options.mutationKey, s))
      return !1;
  }
  return !(i && r.state.status !== i || n && !n(r));
}
function Oo(t, r) {
  return ((r == null ? void 0 : r.queryKeyHashFn) || Bn)(t);
}
function Bn(t) {
  return JSON.stringify(
    t,
    (r, e) => eo(e) ? Object.keys(e).sort().reduce((i, n) => (i[n] = e[n], i), {}) : e
  );
}
function Wn(t, r) {
  return t === r ? !0 : typeof t != typeof r ? !1 : t && r && typeof t == "object" && typeof r == "object" ? !Object.keys(r).some((e) => !Wn(t[e], r[e])) : !1;
}
function ph(t, r) {
  if (t === r)
    return t;
  const e = yc(t) && yc(r);
  if (e || eo(t) && eo(r)) {
    const i = e ? t : Object.keys(t), n = i.length, s = e ? r : Object.keys(r), l = s.length, m = e ? [] : {};
    let A = 0;
    for (let Y = 0; Y < l; Y++) {
      const q = e ? Y : s[Y];
      !e && t[q] === void 0 && r[q] === void 0 && i.includes(q) ? (m[q] = void 0, A++) : (m[q] = ph(t[q], r[q]), m[q] === t[q] && t[q] !== void 0 && A++);
    }
    return n === l && A === n ? t : m;
  }
  return r;
}
function $a(t, r) {
  if (!r || Object.keys(t).length !== Object.keys(r).length)
    return !1;
  for (const e in t)
    if (t[e] !== r[e])
      return !1;
  return !0;
}
function yc(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function eo(t) {
  if (!bc(t))
    return !1;
  const r = t.constructor;
  if (r === void 0)
    return !0;
  const e = r.prototype;
  return !(!bc(e) || !e.hasOwnProperty("isPrototypeOf"));
}
function bc(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function Cm(t) {
  return new Promise((r) => {
    setTimeout(r, t);
  });
}
function to(t, r, e) {
  return typeof e.structuralSharing == "function" ? e.structuralSharing(t, r) : e.structuralSharing !== !1 ? ph(t, r) : r;
}
function Sm(t, r, e = 0) {
  const i = [...t, r];
  return e && i.length > e ? i.slice(1) : i;
}
function Mm(t, r, e = 0) {
  const i = [r, ...t];
  return e && i.length > e ? i.slice(0, -1) : i;
}
var Hn = Symbol(), Si, si, tn, Jc, Tm = (Jc = class extends ts {
  constructor() {
    super();
    _e(this, Si, void 0);
    _e(this, si, void 0);
    _e(this, tn, void 0);
    qe(this, tn, (r) => {
      if (!mn && window.addEventListener) {
        const e = () => r();
        return window.addEventListener("visibilitychange", e, !1), () => {
          window.removeEventListener("visibilitychange", e);
        };
      }
    });
  }
  onSubscribe() {
    we(this, si) || this.setEventListener(we(this, tn));
  }
  onUnsubscribe() {
    var r;
    this.hasListeners() || ((r = we(this, si)) == null || r.call(this), qe(this, si, void 0));
  }
  setEventListener(r) {
    var e;
    qe(this, tn, r), (e = we(this, si)) == null || e.call(this), qe(this, si, r((i) => {
      typeof i == "boolean" ? this.setFocused(i) : this.onFocus();
    }));
  }
  setFocused(r) {
    we(this, Si) !== r && (qe(this, Si, r), this.onFocus());
  }
  onFocus() {
    const r = this.isFocused();
    this.listeners.forEach((e) => {
      e(r);
    });
  }
  isFocused() {
    var r;
    return typeof we(this, Si) == "boolean" ? we(this, Si) : ((r = globalThis.document) == null ? void 0 : r.visibilityState) !== "hidden";
  }
}, Si = new WeakMap(), si = new WeakMap(), tn = new WeakMap(), Jc), Ao = new Tm(), rn, ai, nn, _c, Om = (_c = class extends ts {
  constructor() {
    super();
    _e(this, rn, !0);
    _e(this, ai, void 0);
    _e(this, nn, void 0);
    qe(this, nn, (r) => {
      if (!mn && window.addEventListener) {
        const e = () => r(!0), i = () => r(!1);
        return window.addEventListener("online", e, !1), window.addEventListener("offline", i, !1), () => {
          window.removeEventListener("online", e), window.removeEventListener("offline", i);
        };
      }
    });
  }
  onSubscribe() {
    we(this, ai) || this.setEventListener(we(this, nn));
  }
  onUnsubscribe() {
    var r;
    this.hasListeners() || ((r = we(this, ai)) == null || r.call(this), qe(this, ai, void 0));
  }
  setEventListener(r) {
    var e;
    qe(this, nn, r), (e = we(this, ai)) == null || e.call(this), qe(this, ai, r(this.setOnline.bind(this)));
  }
  setOnline(r) {
    we(this, rn) !== r && (qe(this, rn, r), this.listeners.forEach((i) => {
      i(r);
    }));
  }
  isOnline() {
    return we(this, rn);
  }
}, rn = new WeakMap(), ai = new WeakMap(), nn = new WeakMap(), _c), Ds = new Om();
function Am(t) {
  return Math.min(1e3 * 2 ** t, 3e4);
}
function Eo(t) {
  return (t ?? "online") === "online" ? Ds.isOnline() : !0;
}
var gh = class {
  constructor(t) {
    this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent;
  }
};
function za(t) {
  return t instanceof gh;
}
function mh(t) {
  let r = !1, e = 0, i = !1, n, s, l;
  const m = new Promise((E, M) => {
    s = E, l = M;
  }), A = (E) => {
    var M;
    i || (O(new gh(E)), (M = t.abort) == null || M.call(t));
  }, Y = () => {
    r = !0;
  }, q = () => {
    r = !1;
  }, T = () => !Ao.isFocused() || t.networkMode !== "always" && !Ds.isOnline(), B = (E) => {
    var M;
    i || (i = !0, (M = t.onSuccess) == null || M.call(t, E), n == null || n(), s(E));
  }, O = (E) => {
    var M;
    i || (i = !0, (M = t.onError) == null || M.call(t, E), n == null || n(), l(E));
  }, b = () => new Promise((E) => {
    var M;
    n = (g) => {
      const C = i || !T();
      return C && E(g), C;
    }, (M = t.onPause) == null || M.call(t);
  }).then(() => {
    var E;
    n = void 0, i || (E = t.onContinue) == null || E.call(t);
  }), v = () => {
    if (i)
      return;
    let E;
    try {
      E = t.fn();
    } catch (M) {
      E = Promise.reject(M);
    }
    Promise.resolve(E).then(B).catch((M) => {
      var u;
      if (i)
        return;
      const g = t.retry ?? (mn ? 0 : 3), C = t.retryDelay ?? Am, j = typeof C == "function" ? C(e, M) : C, D = g === !0 || typeof g == "number" && e < g || typeof g == "function" && g(e, M);
      if (r || !D) {
        O(M);
        return;
      }
      e++, (u = t.onFail) == null || u.call(t, e, M), Cm(j).then(() => {
        if (T())
          return b();
      }).then(() => {
        r ? O(M) : v();
      });
    });
  };
  return Eo(t.networkMode) ? v() : b().then(v), {
    promise: m,
    cancel: A,
    continue: () => (n == null ? void 0 : n()) ? m : Promise.resolve(),
    cancelRetry: Y,
    continueRetry: q
  };
}
function Em() {
  let t = [], r = 0, e = (B) => {
    B();
  }, i = (B) => {
    B();
  }, n = (B) => setTimeout(B, 0);
  const s = (B) => {
    n = B;
  }, l = (B) => {
    let O;
    r++;
    try {
      O = B();
    } finally {
      r--, r || Y();
    }
    return O;
  }, m = (B) => {
    r ? t.push(B) : n(() => {
      e(B);
    });
  }, A = (B) => (...O) => {
    m(() => {
      B(...O);
    });
  }, Y = () => {
    const B = t;
    t = [], B.length && n(() => {
      i(() => {
        B.forEach((O) => {
          e(O);
        });
      });
    });
  };
  return {
    batch: l,
    batchCalls: A,
    schedule: m,
    setNotifyFunction: (B) => {
      e = B;
    },
    setBatchNotifyFunction: (B) => {
      i = B;
    },
    setScheduler: s
  };
}
var rr = Em(), Mi, $c, yh = ($c = class {
  constructor() {
    _e(this, Mi, void 0);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), _a(this.gcTime) && qe(this, Mi, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (mn ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    we(this, Mi) && (clearTimeout(we(this, Mi)), qe(this, Mi, void 0));
  }
}, Mi = new WeakMap(), $c), sn, an, mr, nr, Jt, Un, Ti, Or, Xr, eh, Pm = (eh = class extends yh {
  constructor(r) {
    super();
    _e(this, Or);
    _e(this, sn, void 0);
    _e(this, an, void 0);
    _e(this, mr, void 0);
    _e(this, nr, void 0);
    _e(this, Jt, void 0);
    _e(this, Un, void 0);
    _e(this, Ti, void 0);
    qe(this, Ti, !1), qe(this, Un, r.defaultOptions), this.setOptions(r.options), qe(this, Jt, []), qe(this, mr, r.cache), this.queryKey = r.queryKey, this.queryHash = r.queryHash, qe(this, sn, r.state || Dm(this.options)), this.state = we(this, sn), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  setOptions(r) {
    this.options = { ...we(this, Un), ...r }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !we(this, Jt).length && this.state.fetchStatus === "idle" && we(this, mr).remove(this);
  }
  setData(r, e) {
    const i = to(this.state.data, r, this.options);
    return bt(this, Or, Xr).call(this, {
      data: i,
      type: "success",
      dataUpdatedAt: e == null ? void 0 : e.updatedAt,
      manual: e == null ? void 0 : e.manual
    }), i;
  }
  setState(r, e) {
    bt(this, Or, Xr).call(this, { type: "setState", state: r, setStateOptions: e });
  }
  cancel(r) {
    var i, n;
    const e = (i = we(this, nr)) == null ? void 0 : i.promise;
    return (n = we(this, nr)) == null || n.cancel(r), e ? e.then(br).catch(br) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(we(this, sn));
  }
  isActive() {
    return we(this, Jt).some(
      (r) => r.options.enabled !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? we(this, Jt).some(
      (r) => r.getCurrentResult().isStale
    ) : this.state.data === void 0;
  }
  isStaleByTime(r = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !fh(this.state.dataUpdatedAt, r);
  }
  onFocus() {
    var e;
    const r = we(this, Jt).find((i) => i.shouldFetchOnWindowFocus());
    r == null || r.refetch({ cancelRefetch: !1 }), (e = we(this, nr)) == null || e.continue();
  }
  onOnline() {
    var e;
    const r = we(this, Jt).find((i) => i.shouldFetchOnReconnect());
    r == null || r.refetch({ cancelRefetch: !1 }), (e = we(this, nr)) == null || e.continue();
  }
  addObserver(r) {
    we(this, Jt).includes(r) || (we(this, Jt).push(r), this.clearGcTimeout(), we(this, mr).notify({ type: "observerAdded", query: this, observer: r }));
  }
  removeObserver(r) {
    we(this, Jt).includes(r) && (qe(this, Jt, we(this, Jt).filter((e) => e !== r)), we(this, Jt).length || (we(this, nr) && (we(this, Ti) ? we(this, nr).cancel({ revert: !0 }) : we(this, nr).cancelRetry()), this.scheduleGc()), we(this, mr).notify({ type: "observerRemoved", query: this, observer: r }));
  }
  getObserversCount() {
    return we(this, Jt).length;
  }
  invalidate() {
    this.state.isInvalidated || bt(this, Or, Xr).call(this, { type: "invalidate" });
  }
  fetch(r, e) {
    var Y, q, T;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (e != null && e.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (we(this, nr))
        return we(this, nr).continueRetry(), we(this, nr).promise;
    }
    if (r && this.setOptions(r), !this.options.queryFn) {
      const B = we(this, Jt).find((O) => O.options.queryFn);
      B && this.setOptions(B.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const i = new AbortController(), n = {
      queryKey: this.queryKey,
      meta: this.meta
    }, s = (B) => {
      Object.defineProperty(B, "signal", {
        enumerable: !0,
        get: () => (qe(this, Ti, !0), i.signal)
      });
    };
    s(n);
    const l = () => (process.env.NODE_ENV !== "production" && this.options.queryFn === Hn && console.error(
      `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${this.options.queryHash}'`
    ), !this.options.queryFn || this.options.queryFn === Hn ? Promise.reject(
      new Error(`Missing queryFn: '${this.options.queryHash}'`)
    ) : (qe(this, Ti, !1), this.options.persister ? this.options.persister(
      this.options.queryFn,
      n,
      this
    ) : this.options.queryFn(
      n
    ))), m = {
      fetchOptions: e,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn: l
    };
    s(m), (Y = this.options.behavior) == null || Y.onFetch(
      m,
      this
    ), qe(this, an, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((q = m.fetchOptions) == null ? void 0 : q.meta)) && bt(this, Or, Xr).call(this, { type: "fetch", meta: (T = m.fetchOptions) == null ? void 0 : T.meta });
    const A = (B) => {
      var O, b, v, E;
      za(B) && B.silent || bt(this, Or, Xr).call(this, {
        type: "error",
        error: B
      }), za(B) || ((b = (O = we(this, mr).config).onError) == null || b.call(
        O,
        B,
        this
      ), (E = (v = we(this, mr).config).onSettled) == null || E.call(
        v,
        this.state.data,
        B,
        this
      )), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
    };
    return qe(this, nr, mh({
      fn: m.fetchFn,
      abort: i.abort.bind(i),
      onSuccess: (B) => {
        var O, b, v, E;
        if (B === void 0) {
          process.env.NODE_ENV !== "production" && console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), A(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        this.setData(B), (b = (O = we(this, mr).config).onSuccess) == null || b.call(O, B, this), (E = (v = we(this, mr).config).onSettled) == null || E.call(
          v,
          B,
          this.state.error,
          this
        ), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1;
      },
      onError: A,
      onFail: (B, O) => {
        bt(this, Or, Xr).call(this, { type: "failed", failureCount: B, error: O });
      },
      onPause: () => {
        bt(this, Or, Xr).call(this, { type: "pause" });
      },
      onContinue: () => {
        bt(this, Or, Xr).call(this, { type: "continue" });
      },
      retry: m.options.retry,
      retryDelay: m.options.retryDelay,
      networkMode: m.options.networkMode
    })), we(this, nr).promise;
  }
}, sn = new WeakMap(), an = new WeakMap(), mr = new WeakMap(), nr = new WeakMap(), Jt = new WeakMap(), Un = new WeakMap(), Ti = new WeakMap(), Or = new WeakSet(), Xr = function(r) {
  const e = (i) => {
    switch (r.type) {
      case "failed":
        return {
          ...i,
          fetchFailureCount: r.failureCount,
          fetchFailureReason: r.error
        };
      case "pause":
        return {
          ...i,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...i,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...i,
          ...bh(i.data, this.options),
          fetchMeta: r.meta ?? null
        };
      case "success":
        return {
          ...i,
          data: r.data,
          dataUpdateCount: i.dataUpdateCount + 1,
          dataUpdatedAt: r.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!r.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const n = r.error;
        return za(n) && n.revert && we(this, an) ? { ...we(this, an), fetchStatus: "idle" } : {
          ...i,
          error: n,
          errorUpdateCount: i.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: i.fetchFailureCount + 1,
          fetchFailureReason: n,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...i,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...i,
          ...r.state
        };
    }
  };
  this.state = e(this.state), rr.batch(() => {
    we(this, Jt).forEach((i) => {
      i.onQueryUpdate();
    }), we(this, mr).notify({ query: this, type: "updated", action: r });
  });
}, eh);
function bh(t, r) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: Eo(r.networkMode) ? "fetching" : "paused",
    ...t === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function Dm(t) {
  const r = typeof t.initialData == "function" ? t.initialData() : t.initialData, e = r !== void 0, i = e ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
  return {
    data: r,
    dataUpdateCount: 0,
    dataUpdatedAt: e ? i ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: e ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var Dr, th, Lm = (th = class extends ts {
  constructor(r = {}) {
    super();
    _e(this, Dr, void 0);
    this.config = r, qe(this, Dr, /* @__PURE__ */ new Map());
  }
  build(r, e, i) {
    const n = e.queryKey, s = e.queryHash ?? Oo(n, e);
    let l = this.get(s);
    return l || (l = new Pm({
      cache: this,
      queryKey: n,
      queryHash: s,
      options: r.defaultQueryOptions(e),
      state: i,
      defaultOptions: r.getQueryDefaults(n)
    }), this.add(l)), l;
  }
  add(r) {
    we(this, Dr).has(r.queryHash) || (we(this, Dr).set(r.queryHash, r), this.notify({
      type: "added",
      query: r
    }));
  }
  remove(r) {
    const e = we(this, Dr).get(r.queryHash);
    e && (r.destroy(), e === r && we(this, Dr).delete(r.queryHash), this.notify({ type: "removed", query: r }));
  }
  clear() {
    rr.batch(() => {
      this.getAll().forEach((r) => {
        this.remove(r);
      });
    });
  }
  get(r) {
    return we(this, Dr).get(r);
  }
  getAll() {
    return [...we(this, Dr).values()];
  }
  find(r) {
    const e = { exact: !0, ...r };
    return this.getAll().find(
      (i) => gc(e, i)
    );
  }
  findAll(r = {}) {
    const e = this.getAll();
    return Object.keys(r).length > 0 ? e.filter((i) => gc(r, i)) : e;
  }
  notify(r) {
    rr.batch(() => {
      this.listeners.forEach((e) => {
        e(r);
      });
    });
  }
  onFocus() {
    rr.batch(() => {
      this.getAll().forEach((r) => {
        r.onFocus();
      });
    });
  }
  onOnline() {
    rr.batch(() => {
      this.getAll().forEach((r) => {
        r.onOnline();
      });
    });
  }
}, Dr = new WeakMap(), th), Lr, Gn, pr, on, Rr, ni, rh, Rm = (rh = class extends yh {
  constructor(r) {
    super();
    _e(this, Rr);
    _e(this, Lr, void 0);
    _e(this, Gn, void 0);
    _e(this, pr, void 0);
    _e(this, on, void 0);
    this.mutationId = r.mutationId, qe(this, Gn, r.defaultOptions), qe(this, pr, r.mutationCache), qe(this, Lr, []), this.state = r.state || Nm(), this.setOptions(r.options), this.scheduleGc();
  }
  setOptions(r) {
    this.options = { ...we(this, Gn), ...r }, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(r) {
    we(this, Lr).includes(r) || (we(this, Lr).push(r), this.clearGcTimeout(), we(this, pr).notify({
      type: "observerAdded",
      mutation: this,
      observer: r
    }));
  }
  removeObserver(r) {
    qe(this, Lr, we(this, Lr).filter((e) => e !== r)), this.scheduleGc(), we(this, pr).notify({
      type: "observerRemoved",
      mutation: this,
      observer: r
    });
  }
  optionalRemove() {
    we(this, Lr).length || (this.state.status === "pending" ? this.scheduleGc() : we(this, pr).remove(this));
  }
  continue() {
    var r;
    return ((r = we(this, on)) == null ? void 0 : r.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(r) {
    var n, s, l, m, A, Y, q, T, B, O, b, v, E, M, g, C, j, D, u, R;
    const e = () => (qe(this, on, mh({
      fn: () => this.options.mutationFn ? this.options.mutationFn(r) : Promise.reject(new Error("No mutationFn found")),
      onFail: (K, I) => {
        bt(this, Rr, ni).call(this, { type: "failed", failureCount: K, error: I });
      },
      onPause: () => {
        bt(this, Rr, ni).call(this, { type: "pause" });
      },
      onContinue: () => {
        bt(this, Rr, ni).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode
    })), we(this, on).promise), i = this.state.status === "pending";
    try {
      if (!i) {
        bt(this, Rr, ni).call(this, { type: "pending", variables: r }), await ((s = (n = we(this, pr).config).onMutate) == null ? void 0 : s.call(
          n,
          r,
          this
        ));
        const I = await ((m = (l = this.options).onMutate) == null ? void 0 : m.call(l, r));
        I !== this.state.context && bt(this, Rr, ni).call(this, {
          type: "pending",
          context: I,
          variables: r
        });
      }
      const K = await e();
      return await ((Y = (A = we(this, pr).config).onSuccess) == null ? void 0 : Y.call(
        A,
        K,
        r,
        this.state.context,
        this
      )), await ((T = (q = this.options).onSuccess) == null ? void 0 : T.call(q, K, r, this.state.context)), await ((O = (B = we(this, pr).config).onSettled) == null ? void 0 : O.call(
        B,
        K,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((v = (b = this.options).onSettled) == null ? void 0 : v.call(b, K, null, r, this.state.context)), bt(this, Rr, ni).call(this, { type: "success", data: K }), K;
    } catch (K) {
      try {
        throw await ((M = (E = we(this, pr).config).onError) == null ? void 0 : M.call(
          E,
          K,
          r,
          this.state.context,
          this
        )), await ((C = (g = this.options).onError) == null ? void 0 : C.call(
          g,
          K,
          r,
          this.state.context
        )), await ((D = (j = we(this, pr).config).onSettled) == null ? void 0 : D.call(
          j,
          void 0,
          K,
          this.state.variables,
          this.state.context,
          this
        )), await ((R = (u = this.options).onSettled) == null ? void 0 : R.call(
          u,
          void 0,
          K,
          r,
          this.state.context
        )), K;
      } finally {
        bt(this, Rr, ni).call(this, { type: "error", error: K });
      }
    }
  }
}, Lr = new WeakMap(), Gn = new WeakMap(), pr = new WeakMap(), on = new WeakMap(), Rr = new WeakSet(), ni = function(r) {
  const e = (i) => {
    switch (r.type) {
      case "failed":
        return {
          ...i,
          failureCount: r.failureCount,
          failureReason: r.error
        };
      case "pause":
        return {
          ...i,
          isPaused: !0
        };
      case "continue":
        return {
          ...i,
          isPaused: !1
        };
      case "pending":
        return {
          ...i,
          context: r.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: !Eo(this.options.networkMode),
          status: "pending",
          variables: r.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...i,
          data: r.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...i,
          data: void 0,
          error: r.error,
          failureCount: i.failureCount + 1,
          failureReason: r.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = e(this.state), rr.batch(() => {
    we(this, Lr).forEach((i) => {
      i.onMutationUpdate(r);
    }), we(this, pr).notify({
      mutation: this,
      type: "updated",
      action: r
    });
  });
}, rh);
function Nm() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var yr, qn, Oi, ih, jm = (ih = class extends ts {
  constructor(r = {}) {
    super();
    _e(this, yr, void 0);
    _e(this, qn, void 0);
    _e(this, Oi, void 0);
    this.config = r, qe(this, yr, []), qe(this, qn, 0);
  }
  build(r, e, i) {
    const n = new Rm({
      mutationCache: this,
      mutationId: ++ws(this, qn)._,
      options: r.defaultMutationOptions(e),
      state: i
    });
    return this.add(n), n;
  }
  add(r) {
    we(this, yr).push(r), this.notify({ type: "added", mutation: r });
  }
  remove(r) {
    qe(this, yr, we(this, yr).filter((e) => e !== r)), this.notify({ type: "removed", mutation: r });
  }
  clear() {
    rr.batch(() => {
      we(this, yr).forEach((r) => {
        this.remove(r);
      });
    });
  }
  getAll() {
    return we(this, yr);
  }
  find(r) {
    const e = { exact: !0, ...r };
    return we(this, yr).find(
      (i) => mc(e, i)
    );
  }
  findAll(r = {}) {
    return we(this, yr).filter(
      (e) => mc(r, e)
    );
  }
  notify(r) {
    rr.batch(() => {
      this.listeners.forEach((e) => {
        e(r);
      });
    });
  }
  resumePausedMutations() {
    return qe(this, Oi, (we(this, Oi) ?? Promise.resolve()).then(() => {
      const r = we(this, yr).filter((e) => e.state.isPaused);
      return rr.batch(
        () => r.reduce(
          (e, i) => e.then(() => i.continue().catch(br)),
          Promise.resolve()
        )
      );
    }).then(() => {
      qe(this, Oi, void 0);
    })), we(this, Oi);
  }
}, yr = new WeakMap(), qn = new WeakMap(), Oi = new WeakMap(), ih);
function Im(t) {
  return {
    onFetch: (r, e) => {
      const i = async () => {
        var b, v, E, M, g;
        const n = r.options, s = (E = (v = (b = r.fetchOptions) == null ? void 0 : b.meta) == null ? void 0 : v.fetchMore) == null ? void 0 : E.direction, l = ((M = r.state.data) == null ? void 0 : M.pages) || [], m = ((g = r.state.data) == null ? void 0 : g.pageParams) || [], A = { pages: [], pageParams: [] };
        let Y = !1;
        const q = (C) => {
          Object.defineProperty(C, "signal", {
            enumerable: !0,
            get: () => (r.signal.aborted ? Y = !0 : r.signal.addEventListener("abort", () => {
              Y = !0;
            }), r.signal)
          });
        }, T = r.options.queryFn && r.options.queryFn !== Hn ? r.options.queryFn : () => (process.env.NODE_ENV !== "production" && r.options.queryFn === Hn && console.error(
          `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${r.options.queryHash}'`
        ), Promise.reject(
          new Error(`Missing queryFn: '${r.options.queryHash}'`)
        )), B = async (C, j, D) => {
          if (Y)
            return Promise.reject();
          if (j == null && C.pages.length)
            return Promise.resolve(C);
          const u = {
            queryKey: r.queryKey,
            pageParam: j,
            direction: D ? "backward" : "forward",
            meta: r.options.meta
          };
          q(u);
          const R = await T(
            u
          ), { maxPages: K } = r.options, I = D ? Mm : Sm;
          return {
            pages: I(C.pages, R, K),
            pageParams: I(C.pageParams, j, K)
          };
        };
        let O;
        if (s && l.length) {
          const C = s === "backward", j = C ? Fm : vc, D = {
            pages: l,
            pageParams: m
          }, u = j(n, D);
          O = await B(D, u, C);
        } else {
          O = await B(
            A,
            m[0] ?? n.initialPageParam
          );
          const C = t ?? l.length;
          for (let j = 1; j < C; j++) {
            const D = vc(n, O);
            O = await B(O, D);
          }
        }
        return O;
      };
      r.options.persister ? r.fetchFn = () => {
        var n, s;
        return (s = (n = r.options).persister) == null ? void 0 : s.call(
          n,
          i,
          {
            queryKey: r.queryKey,
            meta: r.options.meta,
            signal: r.signal
          },
          e
        );
      } : r.fetchFn = i;
    }
  };
}
function vc(t, { pages: r, pageParams: e }) {
  const i = r.length - 1;
  return t.getNextPageParam(
    r[i],
    r,
    e[i],
    e
  );
}
function Fm(t, { pages: r, pageParams: e }) {
  var i;
  return (i = t.getPreviousPageParam) == null ? void 0 : i.call(
    t,
    r[0],
    r,
    e[0],
    e
  );
}
var Wt, oi, li, ln, cn, ci, hn, dn, nh, Bm = (nh = class {
  constructor(t = {}) {
    _e(this, Wt, void 0);
    _e(this, oi, void 0);
    _e(this, li, void 0);
    _e(this, ln, void 0);
    _e(this, cn, void 0);
    _e(this, ci, void 0);
    _e(this, hn, void 0);
    _e(this, dn, void 0);
    qe(this, Wt, t.queryCache || new Lm()), qe(this, oi, t.mutationCache || new jm()), qe(this, li, t.defaultOptions || {}), qe(this, ln, /* @__PURE__ */ new Map()), qe(this, cn, /* @__PURE__ */ new Map()), qe(this, ci, 0);
  }
  mount() {
    ws(this, ci)._++, we(this, ci) === 1 && (qe(this, hn, Ao.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), we(this, Wt).onFocus());
    })), qe(this, dn, Ds.subscribe(async (t) => {
      t && (await this.resumePausedMutations(), we(this, Wt).onOnline());
    })));
  }
  unmount() {
    var t, r;
    ws(this, ci)._--, we(this, ci) === 0 && ((t = we(this, hn)) == null || t.call(this), qe(this, hn, void 0), (r = we(this, dn)) == null || r.call(this), qe(this, dn, void 0));
  }
  isFetching(t) {
    return we(this, Wt).findAll({ ...t, fetchStatus: "fetching" }).length;
  }
  isMutating(t) {
    return we(this, oi).findAll({ ...t, status: "pending" }).length;
  }
  getQueryData(t) {
    var e;
    const r = this.defaultQueryOptions({ queryKey: t });
    return (e = we(this, Wt).get(r.queryHash)) == null ? void 0 : e.state.data;
  }
  ensureQueryData(t) {
    const r = this.getQueryData(t.queryKey);
    if (r === void 0)
      return this.fetchQuery(t);
    {
      const e = this.defaultQueryOptions(t), i = we(this, Wt).build(this, e);
      return t.revalidateIfStale && i.isStaleByTime(e.staleTime) && this.prefetchQuery(e), Promise.resolve(r);
    }
  }
  getQueriesData(t) {
    return we(this, Wt).findAll(t).map(({ queryKey: r, state: e }) => {
      const i = e.data;
      return [r, i];
    });
  }
  setQueryData(t, r, e) {
    const i = this.defaultQueryOptions({ queryKey: t }), n = we(this, Wt).get(
      i.queryHash
    ), s = n == null ? void 0 : n.state.data, l = km(r, s);
    if (l !== void 0)
      return we(this, Wt).build(this, i).setData(l, { ...e, manual: !0 });
  }
  setQueriesData(t, r, e) {
    return rr.batch(
      () => we(this, Wt).findAll(t).map(({ queryKey: i }) => [
        i,
        this.setQueryData(i, r, e)
      ])
    );
  }
  getQueryState(t) {
    var e;
    const r = this.defaultQueryOptions({ queryKey: t });
    return (e = we(this, Wt).get(r.queryHash)) == null ? void 0 : e.state;
  }
  removeQueries(t) {
    const r = we(this, Wt);
    rr.batch(() => {
      r.findAll(t).forEach((e) => {
        r.remove(e);
      });
    });
  }
  resetQueries(t, r) {
    const e = we(this, Wt), i = {
      type: "active",
      ...t
    };
    return rr.batch(() => (e.findAll(t).forEach((n) => {
      n.reset();
    }), this.refetchQueries(i, r)));
  }
  cancelQueries(t = {}, r = {}) {
    const e = { revert: !0, ...r }, i = rr.batch(
      () => we(this, Wt).findAll(t).map((n) => n.cancel(e))
    );
    return Promise.all(i).then(br).catch(br);
  }
  invalidateQueries(t = {}, r = {}) {
    return rr.batch(() => {
      if (we(this, Wt).findAll(t).forEach((i) => {
        i.invalidate();
      }), t.refetchType === "none")
        return Promise.resolve();
      const e = {
        ...t,
        type: t.refetchType ?? t.type ?? "active"
      };
      return this.refetchQueries(e, r);
    });
  }
  refetchQueries(t = {}, r) {
    const e = {
      ...r,
      cancelRefetch: (r == null ? void 0 : r.cancelRefetch) ?? !0
    }, i = rr.batch(
      () => we(this, Wt).findAll(t).filter((n) => !n.isDisabled()).map((n) => {
        let s = n.fetch(void 0, e);
        return e.throwOnError || (s = s.catch(br)), n.state.fetchStatus === "paused" ? Promise.resolve() : s;
      })
    );
    return Promise.all(i).then(br);
  }
  fetchQuery(t) {
    const r = this.defaultQueryOptions(t);
    r.retry === void 0 && (r.retry = !1);
    const e = we(this, Wt).build(this, r);
    return e.isStaleByTime(r.staleTime) ? e.fetch(r) : Promise.resolve(e.state.data);
  }
  prefetchQuery(t) {
    return this.fetchQuery(t).then(br).catch(br);
  }
  fetchInfiniteQuery(t) {
    return t.behavior = Im(t.pages), this.fetchQuery(t);
  }
  prefetchInfiniteQuery(t) {
    return this.fetchInfiniteQuery(t).then(br).catch(br);
  }
  resumePausedMutations() {
    return Ds.isOnline() ? we(this, oi).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return we(this, Wt);
  }
  getMutationCache() {
    return we(this, oi);
  }
  getDefaultOptions() {
    return we(this, li);
  }
  setDefaultOptions(t) {
    qe(this, li, t);
  }
  setQueryDefaults(t, r) {
    we(this, ln).set(Bn(t), {
      queryKey: t,
      defaultOptions: r
    });
  }
  getQueryDefaults(t) {
    const r = [...we(this, ln).values()];
    let e = {};
    return r.forEach((i) => {
      Wn(t, i.queryKey) && (e = { ...e, ...i.defaultOptions });
    }), e;
  }
  setMutationDefaults(t, r) {
    we(this, cn).set(Bn(t), {
      mutationKey: t,
      defaultOptions: r
    });
  }
  getMutationDefaults(t) {
    const r = [...we(this, cn).values()];
    let e = {};
    return r.forEach((i) => {
      Wn(t, i.mutationKey) && (e = { ...e, ...i.defaultOptions });
    }), e;
  }
  defaultQueryOptions(t) {
    if (t._defaulted)
      return t;
    const r = {
      ...we(this, li).queries,
      ...this.getQueryDefaults(t.queryKey),
      ...t,
      _defaulted: !0
    };
    return r.queryHash || (r.queryHash = Oo(
      r.queryKey,
      r
    )), r.refetchOnReconnect === void 0 && (r.refetchOnReconnect = r.networkMode !== "always"), r.throwOnError === void 0 && (r.throwOnError = !!r.suspense), !r.networkMode && r.persister && (r.networkMode = "offlineFirst"), r.enabled !== !0 && r.queryFn === Hn && (r.enabled = !1), r;
  }
  defaultMutationOptions(t) {
    return t != null && t._defaulted ? t : {
      ...we(this, li).mutations,
      ...(t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey),
      ...t,
      _defaulted: !0
    };
  }
  clear() {
    we(this, Wt).clear(), we(this, oi).clear();
  }
}, Wt = new WeakMap(), oi = new WeakMap(), li = new WeakMap(), ln = new WeakMap(), cn = new WeakMap(), ci = new WeakMap(), hn = new WeakMap(), dn = new WeakMap(), nh), cr, Rt, Xn, sr, Ai, un, Nr, Qn, fn, pn, Ei, Pi, hi, gn, Di, Nn, Vn, ro, Kn, io, Zn, no, Jn, so, _n, ao, $n, oo, es, lo, Ks, vh, sh, Wm = (sh = class extends ts {
  constructor(r, e) {
    super();
    _e(this, Di);
    _e(this, Vn);
    _e(this, Kn);
    _e(this, Zn);
    _e(this, Jn);
    _e(this, _n);
    _e(this, $n);
    _e(this, es);
    _e(this, Ks);
    _e(this, cr, void 0);
    _e(this, Rt, void 0);
    _e(this, Xn, void 0);
    _e(this, sr, void 0);
    _e(this, Ai, void 0);
    _e(this, un, void 0);
    _e(this, Nr, void 0);
    _e(this, Qn, void 0);
    _e(this, fn, void 0);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    _e(this, pn, void 0);
    _e(this, Ei, void 0);
    _e(this, Pi, void 0);
    _e(this, hi, void 0);
    _e(this, gn, /* @__PURE__ */ new Set());
    this.options = e, qe(this, cr, r), qe(this, Nr, null), this.bindMethods(), this.setOptions(e);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (we(this, Rt).addObserver(this), xc(we(this, Rt), this.options) ? bt(this, Di, Nn).call(this) : this.updateResult(), bt(this, Jn, so).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return co(
      we(this, Rt),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return co(
      we(this, Rt),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), bt(this, _n, ao).call(this), bt(this, $n, oo).call(this), we(this, Rt).removeObserver(this);
  }
  setOptions(r, e) {
    const i = this.options, n = we(this, Rt);
    if (this.options = we(this, cr).defaultQueryOptions(r), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean")
      throw new Error("Expected enabled to be a boolean");
    bt(this, es, lo).call(this), we(this, Rt).setOptions(this.options), i._defaulted && !$a(this.options, i) && we(this, cr).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: we(this, Rt),
      observer: this
    });
    const s = this.hasListeners();
    s && wc(
      we(this, Rt),
      n,
      this.options,
      i
    ) && bt(this, Di, Nn).call(this), this.updateResult(e), s && (we(this, Rt) !== n || this.options.enabled !== i.enabled || this.options.staleTime !== i.staleTime) && bt(this, Vn, ro).call(this);
    const l = bt(this, Kn, io).call(this);
    s && (we(this, Rt) !== n || this.options.enabled !== i.enabled || l !== we(this, hi)) && bt(this, Zn, no).call(this, l);
  }
  getOptimisticResult(r) {
    const e = we(this, cr).getQueryCache().build(we(this, cr), r), i = this.createResult(e, r);
    return zm(this, i) && (qe(this, sr, i), qe(this, un, this.options), qe(this, Ai, we(this, Rt).state)), i;
  }
  getCurrentResult() {
    return we(this, sr);
  }
  trackResult(r, e) {
    const i = {};
    return Object.keys(r).forEach((n) => {
      Object.defineProperty(i, n, {
        configurable: !1,
        enumerable: !0,
        get: () => (this.trackProp(n), e == null || e(n), r[n])
      });
    }), i;
  }
  trackProp(r) {
    we(this, gn).add(r);
  }
  getCurrentQuery() {
    return we(this, Rt);
  }
  refetch({ ...r } = {}) {
    return this.fetch({
      ...r
    });
  }
  fetchOptimistic(r) {
    const e = we(this, cr).defaultQueryOptions(r), i = we(this, cr).getQueryCache().build(we(this, cr), e);
    return i.isFetchingOptimistic = !0, i.fetch().then(() => this.createResult(i, e));
  }
  fetch(r) {
    return bt(this, Di, Nn).call(this, {
      ...r,
      cancelRefetch: r.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), we(this, sr)));
  }
  createResult(r, e) {
    var R;
    const i = we(this, Rt), n = this.options, s = we(this, sr), l = we(this, Ai), m = we(this, un), Y = r !== i ? r.state : we(this, Xn), { state: q } = r;
    let T = { ...q }, B = !1, O;
    if (e._optimisticResults) {
      const K = this.hasListeners(), I = !K && xc(r, e), z = K && wc(r, i, e, n);
      (I || z) && (T = {
        ...T,
        ...bh(q.data, r.options)
      }), e._optimisticResults === "isRestoring" && (T.fetchStatus = "idle");
    }
    let { error: b, errorUpdatedAt: v, status: E } = T;
    if (e.select && T.data !== void 0)
      if (s && T.data === (l == null ? void 0 : l.data) && e.select === we(this, Qn))
        O = we(this, fn);
      else
        try {
          qe(this, Qn, e.select), O = e.select(T.data), O = to(s == null ? void 0 : s.data, O, e), qe(this, fn, O), qe(this, Nr, null);
        } catch (K) {
          qe(this, Nr, K);
        }
    else
      O = T.data;
    if (e.placeholderData !== void 0 && O === void 0 && E === "pending") {
      let K;
      if (s != null && s.isPlaceholderData && e.placeholderData === (m == null ? void 0 : m.placeholderData))
        K = s.data;
      else if (K = typeof e.placeholderData == "function" ? e.placeholderData(
        (R = we(this, pn)) == null ? void 0 : R.state.data,
        we(this, pn)
      ) : e.placeholderData, e.select && K !== void 0)
        try {
          K = e.select(K), qe(this, Nr, null);
        } catch (I) {
          qe(this, Nr, I);
        }
      K !== void 0 && (E = "success", O = to(
        s == null ? void 0 : s.data,
        K,
        e
      ), B = !0);
    }
    we(this, Nr) && (b = we(this, Nr), O = we(this, fn), v = Date.now(), E = "error");
    const M = T.fetchStatus === "fetching", g = E === "pending", C = E === "error", j = g && M, D = O !== void 0;
    return {
      status: E,
      fetchStatus: T.fetchStatus,
      isPending: g,
      isSuccess: E === "success",
      isError: C,
      isInitialLoading: j,
      isLoading: j,
      data: O,
      dataUpdatedAt: T.dataUpdatedAt,
      error: b,
      errorUpdatedAt: v,
      failureCount: T.fetchFailureCount,
      failureReason: T.fetchFailureReason,
      errorUpdateCount: T.errorUpdateCount,
      isFetched: T.dataUpdateCount > 0 || T.errorUpdateCount > 0,
      isFetchedAfterMount: T.dataUpdateCount > Y.dataUpdateCount || T.errorUpdateCount > Y.errorUpdateCount,
      isFetching: M,
      isRefetching: M && !g,
      isLoadingError: C && !D,
      isPaused: T.fetchStatus === "paused",
      isPlaceholderData: B,
      isRefetchError: C && D,
      isStale: Po(r, e),
      refetch: this.refetch
    };
  }
  updateResult(r) {
    const e = we(this, sr), i = this.createResult(we(this, Rt), this.options);
    if (qe(this, Ai, we(this, Rt).state), qe(this, un, this.options), we(this, Ai).data !== void 0 && qe(this, pn, we(this, Rt)), $a(i, e))
      return;
    qe(this, sr, i);
    const n = {}, s = () => {
      if (!e)
        return !0;
      const { notifyOnChangeProps: l } = this.options, m = typeof l == "function" ? l() : l;
      if (m === "all" || !m && !we(this, gn).size)
        return !0;
      const A = new Set(
        m ?? we(this, gn)
      );
      return this.options.throwOnError && A.add("error"), Object.keys(we(this, sr)).some((Y) => {
        const q = Y;
        return we(this, sr)[q] !== e[q] && A.has(q);
      });
    };
    (r == null ? void 0 : r.listeners) !== !1 && s() && (n.listeners = !0), bt(this, Ks, vh).call(this, { ...n, ...r });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && bt(this, Jn, so).call(this);
  }
}, cr = new WeakMap(), Rt = new WeakMap(), Xn = new WeakMap(), sr = new WeakMap(), Ai = new WeakMap(), un = new WeakMap(), Nr = new WeakMap(), Qn = new WeakMap(), fn = new WeakMap(), pn = new WeakMap(), Ei = new WeakMap(), Pi = new WeakMap(), hi = new WeakMap(), gn = new WeakMap(), Di = new WeakSet(), Nn = function(r) {
  bt(this, es, lo).call(this);
  let e = we(this, Rt).fetch(
    this.options,
    r
  );
  return r != null && r.throwOnError || (e = e.catch(br)), e;
}, Vn = new WeakSet(), ro = function() {
  if (bt(this, _n, ao).call(this), mn || we(this, sr).isStale || !_a(this.options.staleTime))
    return;
  const e = fh(
    we(this, sr).dataUpdatedAt,
    this.options.staleTime
  ) + 1;
  qe(this, Ei, setTimeout(() => {
    we(this, sr).isStale || this.updateResult();
  }, e));
}, Kn = new WeakSet(), io = function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(we(this, Rt)) : this.options.refetchInterval) ?? !1;
}, Zn = new WeakSet(), no = function(r) {
  bt(this, $n, oo).call(this), qe(this, hi, r), !(mn || this.options.enabled === !1 || !_a(we(this, hi)) || we(this, hi) === 0) && qe(this, Pi, setInterval(() => {
    (this.options.refetchIntervalInBackground || Ao.isFocused()) && bt(this, Di, Nn).call(this);
  }, we(this, hi)));
}, Jn = new WeakSet(), so = function() {
  bt(this, Vn, ro).call(this), bt(this, Zn, no).call(this, bt(this, Kn, io).call(this));
}, _n = new WeakSet(), ao = function() {
  we(this, Ei) && (clearTimeout(we(this, Ei)), qe(this, Ei, void 0));
}, $n = new WeakSet(), oo = function() {
  we(this, Pi) && (clearInterval(we(this, Pi)), qe(this, Pi, void 0));
}, es = new WeakSet(), lo = function() {
  const r = we(this, cr).getQueryCache().build(we(this, cr), this.options);
  if (r === we(this, Rt))
    return;
  const e = we(this, Rt);
  qe(this, Rt, r), qe(this, Xn, r.state), this.hasListeners() && (e == null || e.removeObserver(this), r.addObserver(this));
}, Ks = new WeakSet(), vh = function(r) {
  rr.batch(() => {
    r.listeners && this.listeners.forEach((e) => {
      e(we(this, sr));
    }), we(this, cr).getQueryCache().notify({
      query: we(this, Rt),
      type: "observerResultsUpdated"
    });
  });
}, sh);
function Hm(t, r) {
  return r.enabled !== !1 && t.state.data === void 0 && !(t.state.status === "error" && r.retryOnMount === !1);
}
function xc(t, r) {
  return Hm(t, r) || t.state.data !== void 0 && co(t, r, r.refetchOnMount);
}
function co(t, r, e) {
  if (r.enabled !== !1) {
    const i = typeof e == "function" ? e(t) : e;
    return i === "always" || i !== !1 && Po(t, r);
  }
  return !1;
}
function wc(t, r, e, i) {
  return (t !== r || i.enabled === !1) && (!e.suspense || t.state.status !== "error") && Po(t, e);
}
function Po(t, r) {
  return r.enabled !== !1 && t.isStaleByTime(r.staleTime);
}
function zm(t, r) {
  return !$a(t.getCurrentResult(), r);
}
var xh = vr.createContext(
  void 0
), Ym = (t) => {
  const r = vr.useContext(xh);
  if (t)
    return t;
  if (!r)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return r;
}, Um = ({
  client: t,
  children: r
}) => (vr.useEffect(() => (t.mount(), () => {
  t.unmount();
}), [t]), /* @__PURE__ */ se.jsx(xh.Provider, { value: t, children: r })), wh = vr.createContext(!1), Gm = () => vr.useContext(wh);
wh.Provider;
function qm() {
  let t = !1;
  return {
    clearReset: () => {
      t = !1;
    },
    reset: () => {
      t = !0;
    },
    isReset: () => t
  };
}
var Xm = vr.createContext(qm()), Qm = () => vr.useContext(Xm);
function Vm(t, r) {
  return typeof t == "function" ? t(...r) : !!t;
}
var Km = (t, r) => {
  (t.suspense || t.throwOnError) && (r.isReset() || (t.retryOnMount = !1));
}, Zm = (t) => {
  vr.useEffect(() => {
    t.clearReset();
  }, [t]);
}, Jm = ({
  result: t,
  errorResetBoundary: r,
  throwOnError: e,
  query: i
}) => t.isError && !r.isReset() && !t.isFetching && i && Vm(e, [t.error, i]), _m = (t) => {
  t.suspense && typeof t.staleTime != "number" && (t.staleTime = 1e3);
}, $m = (t, r) => (t == null ? void 0 : t.suspense) && r.isPending, e0 = (t, r, e) => r.fetchOptimistic(t).catch(() => {
  e.clearReset();
});
function t0(t, r, e) {
  if (process.env.NODE_ENV !== "production" && (typeof t != "object" || Array.isArray(t)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const i = Ym(e), n = Gm(), s = Qm(), l = i.defaultQueryOptions(t);
  l._optimisticResults = n ? "isRestoring" : "optimistic", _m(l), Km(l, s), Zm(s);
  const [m] = vr.useState(
    () => new r(
      i,
      l
    )
  ), A = m.getOptimisticResult(l);
  if (vr.useSyncExternalStore(
    vr.useCallback(
      (Y) => {
        const q = n ? () => {
        } : m.subscribe(rr.batchCalls(Y));
        return m.updateResult(), q;
      },
      [m, n]
    ),
    () => m.getCurrentResult(),
    () => m.getCurrentResult()
  ), vr.useEffect(() => {
    m.setOptions(l, { listeners: !1 });
  }, [l, m]), $m(l, A))
    throw e0(l, m, s);
  if (Jm({
    result: A,
    errorResetBoundary: s,
    throwOnError: l.throwOnError,
    query: i.getQueryCache().get(l.queryHash)
  }))
    throw A.error;
  return l.notifyOnChangeProps ? A : m.trackResult(A);
}
function rs(t, r) {
  return t0(t, Wm, r);
}
function kh(t, r) {
  return function() {
    return t.apply(r, arguments);
  };
}
const { toString: r0 } = Object.prototype, { getPrototypeOf: Do } = Object, Zs = /* @__PURE__ */ ((t) => (r) => {
  const e = r0.call(r);
  return t[e] || (t[e] = e.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Yr = (t) => (t = t.toLowerCase(), (r) => Zs(r) === t), Js = (t) => (r) => typeof r === t, { isArray: Cn } = Array, zn = Js("undefined");
function i0(t) {
  return t !== null && !zn(t) && t.constructor !== null && !zn(t.constructor) && xr(t.constructor.isBuffer) && t.constructor.isBuffer(t);
}
const Ch = Yr("ArrayBuffer");
function n0(t) {
  let r;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? r = ArrayBuffer.isView(t) : r = t && t.buffer && Ch(t.buffer), r;
}
const s0 = Js("string"), xr = Js("function"), Sh = Js("number"), _s = (t) => t !== null && typeof t == "object", a0 = (t) => t === !0 || t === !1, Ss = (t) => {
  if (Zs(t) !== "object")
    return !1;
  const r = Do(t);
  return (r === null || r === Object.prototype || Object.getPrototypeOf(r) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);
}, o0 = Yr("Date"), l0 = Yr("File"), c0 = Yr("Blob"), h0 = Yr("FileList"), d0 = (t) => _s(t) && xr(t.pipe), u0 = (t) => {
  let r;
  return t && (typeof FormData == "function" && t instanceof FormData || xr(t.append) && ((r = Zs(t)) === "formdata" || // detect form-data instance
  r === "object" && xr(t.toString) && t.toString() === "[object FormData]"));
}, f0 = Yr("URLSearchParams"), p0 = (t) => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function is(t, r, { allOwnKeys: e = !1 } = {}) {
  if (t === null || typeof t > "u")
    return;
  let i, n;
  if (typeof t != "object" && (t = [t]), Cn(t))
    for (i = 0, n = t.length; i < n; i++)
      r.call(null, t[i], i, t);
  else {
    const s = e ? Object.getOwnPropertyNames(t) : Object.keys(t), l = s.length;
    let m;
    for (i = 0; i < l; i++)
      m = s[i], r.call(null, t[m], m, t);
  }
}
function Mh(t, r) {
  r = r.toLowerCase();
  const e = Object.keys(t);
  let i = e.length, n;
  for (; i-- > 0; )
    if (n = e[i], r === n.toLowerCase())
      return n;
  return null;
}
const Th = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, Oh = (t) => !zn(t) && t !== Th;
function ho() {
  const { caseless: t } = Oh(this) && this || {}, r = {}, e = (i, n) => {
    const s = t && Mh(r, n) || n;
    Ss(r[s]) && Ss(i) ? r[s] = ho(r[s], i) : Ss(i) ? r[s] = ho({}, i) : Cn(i) ? r[s] = i.slice() : r[s] = i;
  };
  for (let i = 0, n = arguments.length; i < n; i++)
    arguments[i] && is(arguments[i], e);
  return r;
}
const g0 = (t, r, e, { allOwnKeys: i } = {}) => (is(r, (n, s) => {
  e && xr(n) ? t[s] = kh(n, e) : t[s] = n;
}, { allOwnKeys: i }), t), m0 = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), y0 = (t, r, e, i) => {
  t.prototype = Object.create(r.prototype, i), t.prototype.constructor = t, Object.defineProperty(t, "super", {
    value: r.prototype
  }), e && Object.assign(t.prototype, e);
}, b0 = (t, r, e, i) => {
  let n, s, l;
  const m = {};
  if (r = r || {}, t == null)
    return r;
  do {
    for (n = Object.getOwnPropertyNames(t), s = n.length; s-- > 0; )
      l = n[s], (!i || i(l, t, r)) && !m[l] && (r[l] = t[l], m[l] = !0);
    t = e !== !1 && Do(t);
  } while (t && (!e || e(t, r)) && t !== Object.prototype);
  return r;
}, v0 = (t, r, e) => {
  t = String(t), (e === void 0 || e > t.length) && (e = t.length), e -= r.length;
  const i = t.indexOf(r, e);
  return i !== -1 && i === e;
}, x0 = (t) => {
  if (!t)
    return null;
  if (Cn(t))
    return t;
  let r = t.length;
  if (!Sh(r))
    return null;
  const e = new Array(r);
  for (; r-- > 0; )
    e[r] = t[r];
  return e;
}, w0 = /* @__PURE__ */ ((t) => (r) => t && r instanceof t)(typeof Uint8Array < "u" && Do(Uint8Array)), k0 = (t, r) => {
  const i = (t && t[Symbol.iterator]).call(t);
  let n;
  for (; (n = i.next()) && !n.done; ) {
    const s = n.value;
    r.call(t, s[0], s[1]);
  }
}, C0 = (t, r) => {
  let e;
  const i = [];
  for (; (e = t.exec(r)) !== null; )
    i.push(e);
  return i;
}, S0 = Yr("HTMLFormElement"), M0 = (t) => t.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(e, i, n) {
    return i.toUpperCase() + n;
  }
), kc = (({ hasOwnProperty: t }) => (r, e) => t.call(r, e))(Object.prototype), T0 = Yr("RegExp"), Ah = (t, r) => {
  const e = Object.getOwnPropertyDescriptors(t), i = {};
  is(e, (n, s) => {
    let l;
    (l = r(n, s, t)) !== !1 && (i[s] = l || n);
  }), Object.defineProperties(t, i);
}, O0 = (t) => {
  Ah(t, (r, e) => {
    if (xr(t) && ["arguments", "caller", "callee"].indexOf(e) !== -1)
      return !1;
    const i = t[e];
    if (xr(i)) {
      if (r.enumerable = !1, "writable" in r) {
        r.writable = !1;
        return;
      }
      r.set || (r.set = () => {
        throw Error("Can not rewrite read-only method '" + e + "'");
      });
    }
  });
}, A0 = (t, r) => {
  const e = {}, i = (n) => {
    n.forEach((s) => {
      e[s] = !0;
    });
  };
  return Cn(t) ? i(t) : i(String(t).split(r)), e;
}, E0 = () => {
}, P0 = (t, r) => (t = +t, Number.isFinite(t) ? t : r), Ya = "abcdefghijklmnopqrstuvwxyz", Cc = "0123456789", Eh = {
  DIGIT: Cc,
  ALPHA: Ya,
  ALPHA_DIGIT: Ya + Ya.toUpperCase() + Cc
}, D0 = (t = 16, r = Eh.ALPHA_DIGIT) => {
  let e = "";
  const { length: i } = r;
  for (; t--; )
    e += r[Math.random() * i | 0];
  return e;
};
function L0(t) {
  return !!(t && xr(t.append) && t[Symbol.toStringTag] === "FormData" && t[Symbol.iterator]);
}
const R0 = (t) => {
  const r = new Array(10), e = (i, n) => {
    if (_s(i)) {
      if (r.indexOf(i) >= 0)
        return;
      if (!("toJSON" in i)) {
        r[n] = i;
        const s = Cn(i) ? [] : {};
        return is(i, (l, m) => {
          const A = e(l, n + 1);
          !zn(A) && (s[m] = A);
        }), r[n] = void 0, s;
      }
    }
    return i;
  };
  return e(t, 0);
}, N0 = Yr("AsyncFunction"), j0 = (t) => t && (_s(t) || xr(t)) && xr(t.then) && xr(t.catch), Re = {
  isArray: Cn,
  isArrayBuffer: Ch,
  isBuffer: i0,
  isFormData: u0,
  isArrayBufferView: n0,
  isString: s0,
  isNumber: Sh,
  isBoolean: a0,
  isObject: _s,
  isPlainObject: Ss,
  isUndefined: zn,
  isDate: o0,
  isFile: l0,
  isBlob: c0,
  isRegExp: T0,
  isFunction: xr,
  isStream: d0,
  isURLSearchParams: f0,
  isTypedArray: w0,
  isFileList: h0,
  forEach: is,
  merge: ho,
  extend: g0,
  trim: p0,
  stripBOM: m0,
  inherits: y0,
  toFlatObject: b0,
  kindOf: Zs,
  kindOfTest: Yr,
  endsWith: v0,
  toArray: x0,
  forEachEntry: k0,
  matchAll: C0,
  isHTMLForm: S0,
  hasOwnProperty: kc,
  hasOwnProp: kc,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: Ah,
  freezeMethods: O0,
  toObjectSet: A0,
  toCamelCase: M0,
  noop: E0,
  toFiniteNumber: P0,
  findKey: Mh,
  global: Th,
  isContextDefined: Oh,
  ALPHABET: Eh,
  generateString: D0,
  isSpecCompliantForm: L0,
  toJSONObject: R0,
  isAsyncFn: N0,
  isThenable: j0
};
function wt(t, r, e, i, n) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", r && (this.code = r), e && (this.config = e), i && (this.request = i), n && (this.response = n);
}
Re.inherits(wt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: Re.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const Ph = wt.prototype, Dh = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((t) => {
  Dh[t] = { value: t };
});
Object.defineProperties(wt, Dh);
Object.defineProperty(Ph, "isAxiosError", { value: !0 });
wt.from = (t, r, e, i, n, s) => {
  const l = Object.create(Ph);
  return Re.toFlatObject(t, l, function(A) {
    return A !== Error.prototype;
  }, (m) => m !== "isAxiosError"), wt.call(l, t.message, r, e, i, n), l.cause = t, l.name = t.name, s && Object.assign(l, s), l;
};
const I0 = null;
function uo(t) {
  return Re.isPlainObject(t) || Re.isArray(t);
}
function Lh(t) {
  return Re.endsWith(t, "[]") ? t.slice(0, -2) : t;
}
function Sc(t, r, e) {
  return t ? t.concat(r).map(function(n, s) {
    return n = Lh(n), !e && s ? "[" + n + "]" : n;
  }).join(e ? "." : "") : r;
}
function F0(t) {
  return Re.isArray(t) && !t.some(uo);
}
const B0 = Re.toFlatObject(Re, {}, null, function(r) {
  return /^is[A-Z]/.test(r);
});
function $s(t, r, e) {
  if (!Re.isObject(t))
    throw new TypeError("target must be an object");
  r = r || new FormData(), e = Re.toFlatObject(e, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(v, E) {
    return !Re.isUndefined(E[v]);
  });
  const i = e.metaTokens, n = e.visitor || q, s = e.dots, l = e.indexes, A = (e.Blob || typeof Blob < "u" && Blob) && Re.isSpecCompliantForm(r);
  if (!Re.isFunction(n))
    throw new TypeError("visitor must be a function");
  function Y(b) {
    if (b === null)
      return "";
    if (Re.isDate(b))
      return b.toISOString();
    if (!A && Re.isBlob(b))
      throw new wt("Blob is not supported. Use a Buffer instead.");
    return Re.isArrayBuffer(b) || Re.isTypedArray(b) ? A && typeof Blob == "function" ? new Blob([b]) : Buffer.from(b) : b;
  }
  function q(b, v, E) {
    let M = b;
    if (b && !E && typeof b == "object") {
      if (Re.endsWith(v, "{}"))
        v = i ? v : v.slice(0, -2), b = JSON.stringify(b);
      else if (Re.isArray(b) && F0(b) || (Re.isFileList(b) || Re.endsWith(v, "[]")) && (M = Re.toArray(b)))
        return v = Lh(v), M.forEach(function(C, j) {
          !(Re.isUndefined(C) || C === null) && r.append(
            // eslint-disable-next-line no-nested-ternary
            l === !0 ? Sc([v], j, s) : l === null ? v : v + "[]",
            Y(C)
          );
        }), !1;
    }
    return uo(b) ? !0 : (r.append(Sc(E, v, s), Y(b)), !1);
  }
  const T = [], B = Object.assign(B0, {
    defaultVisitor: q,
    convertValue: Y,
    isVisitable: uo
  });
  function O(b, v) {
    if (!Re.isUndefined(b)) {
      if (T.indexOf(b) !== -1)
        throw Error("Circular reference detected in " + v.join("."));
      T.push(b), Re.forEach(b, function(M, g) {
        (!(Re.isUndefined(M) || M === null) && n.call(
          r,
          M,
          Re.isString(g) ? g.trim() : g,
          v,
          B
        )) === !0 && O(M, v ? v.concat(g) : [g]);
      }), T.pop();
    }
  }
  if (!Re.isObject(t))
    throw new TypeError("data must be an object");
  return O(t), r;
}
function Mc(t) {
  const r = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(i) {
    return r[i];
  });
}
function Lo(t, r) {
  this._pairs = [], t && $s(t, this, r);
}
const Rh = Lo.prototype;
Rh.append = function(r, e) {
  this._pairs.push([r, e]);
};
Rh.toString = function(r) {
  const e = r ? function(i) {
    return r.call(this, i, Mc);
  } : Mc;
  return this._pairs.map(function(n) {
    return e(n[0]) + "=" + e(n[1]);
  }, "").join("&");
};
function W0(t) {
  return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function Nh(t, r, e) {
  if (!r)
    return t;
  const i = e && e.encode || W0, n = e && e.serialize;
  let s;
  if (n ? s = n(r, e) : s = Re.isURLSearchParams(r) ? r.toString() : new Lo(r, e).toString(i), s) {
    const l = t.indexOf("#");
    l !== -1 && (t = t.slice(0, l)), t += (t.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return t;
}
class Tc {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(r, e, i) {
    return this.handlers.push({
      fulfilled: r,
      rejected: e,
      synchronous: i ? i.synchronous : !1,
      runWhen: i ? i.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(r) {
    this.handlers[r] && (this.handlers[r] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(r) {
    Re.forEach(this.handlers, function(i) {
      i !== null && r(i);
    });
  }
}
const jh = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, H0 = typeof URLSearchParams < "u" ? URLSearchParams : Lo, z0 = typeof FormData < "u" ? FormData : null, Y0 = typeof Blob < "u" ? Blob : null, U0 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: H0,
    FormData: z0,
    Blob: Y0
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Ih = typeof window < "u" && typeof document < "u", G0 = ((t) => Ih && ["ReactNative", "NativeScript", "NS"].indexOf(t) < 0)(typeof navigator < "u" && navigator.product), q0 = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", X0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Ih,
  hasStandardBrowserEnv: G0,
  hasStandardBrowserWebWorkerEnv: q0
}, Symbol.toStringTag, { value: "Module" })), Fr = {
  ...X0,
  ...U0
};
function Q0(t, r) {
  return $s(t, new Fr.classes.URLSearchParams(), Object.assign({
    visitor: function(e, i, n, s) {
      return Fr.isNode && Re.isBuffer(e) ? (this.append(i, e.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, r));
}
function V0(t) {
  return Re.matchAll(/\w+|\[(\w*)]/g, t).map((r) => r[0] === "[]" ? "" : r[1] || r[0]);
}
function K0(t) {
  const r = {}, e = Object.keys(t);
  let i;
  const n = e.length;
  let s;
  for (i = 0; i < n; i++)
    s = e[i], r[s] = t[s];
  return r;
}
function Fh(t) {
  function r(e, i, n, s) {
    let l = e[s++];
    if (l === "__proto__")
      return !0;
    const m = Number.isFinite(+l), A = s >= e.length;
    return l = !l && Re.isArray(n) ? n.length : l, A ? (Re.hasOwnProp(n, l) ? n[l] = [n[l], i] : n[l] = i, !m) : ((!n[l] || !Re.isObject(n[l])) && (n[l] = []), r(e, i, n[l], s) && Re.isArray(n[l]) && (n[l] = K0(n[l])), !m);
  }
  if (Re.isFormData(t) && Re.isFunction(t.entries)) {
    const e = {};
    return Re.forEachEntry(t, (i, n) => {
      r(V0(i), n, e, 0);
    }), e;
  }
  return null;
}
function Z0(t, r, e) {
  if (Re.isString(t))
    try {
      return (r || JSON.parse)(t), Re.trim(t);
    } catch (i) {
      if (i.name !== "SyntaxError")
        throw i;
    }
  return (e || JSON.stringify)(t);
}
const Ro = {
  transitional: jh,
  adapter: ["xhr", "http"],
  transformRequest: [function(r, e) {
    const i = e.getContentType() || "", n = i.indexOf("application/json") > -1, s = Re.isObject(r);
    if (s && Re.isHTMLForm(r) && (r = new FormData(r)), Re.isFormData(r))
      return n ? JSON.stringify(Fh(r)) : r;
    if (Re.isArrayBuffer(r) || Re.isBuffer(r) || Re.isStream(r) || Re.isFile(r) || Re.isBlob(r))
      return r;
    if (Re.isArrayBufferView(r))
      return r.buffer;
    if (Re.isURLSearchParams(r))
      return e.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), r.toString();
    let m;
    if (s) {
      if (i.indexOf("application/x-www-form-urlencoded") > -1)
        return Q0(r, this.formSerializer).toString();
      if ((m = Re.isFileList(r)) || i.indexOf("multipart/form-data") > -1) {
        const A = this.env && this.env.FormData;
        return $s(
          m ? { "files[]": r } : r,
          A && new A(),
          this.formSerializer
        );
      }
    }
    return s || n ? (e.setContentType("application/json", !1), Z0(r)) : r;
  }],
  transformResponse: [function(r) {
    const e = this.transitional || Ro.transitional, i = e && e.forcedJSONParsing, n = this.responseType === "json";
    if (r && Re.isString(r) && (i && !this.responseType || n)) {
      const l = !(e && e.silentJSONParsing) && n;
      try {
        return JSON.parse(r);
      } catch (m) {
        if (l)
          throw m.name === "SyntaxError" ? wt.from(m, wt.ERR_BAD_RESPONSE, this, null, this.response) : m;
      }
    }
    return r;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Fr.classes.FormData,
    Blob: Fr.classes.Blob
  },
  validateStatus: function(r) {
    return r >= 200 && r < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
Re.forEach(["delete", "get", "head", "post", "put", "patch"], (t) => {
  Ro.headers[t] = {};
});
const No = Ro, J0 = Re.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), _0 = (t) => {
  const r = {};
  let e, i, n;
  return t && t.split(`
`).forEach(function(l) {
    n = l.indexOf(":"), e = l.substring(0, n).trim().toLowerCase(), i = l.substring(n + 1).trim(), !(!e || r[e] && J0[e]) && (e === "set-cookie" ? r[e] ? r[e].push(i) : r[e] = [i] : r[e] = r[e] ? r[e] + ", " + i : i);
  }), r;
}, Oc = Symbol("internals");
function Pn(t) {
  return t && String(t).trim().toLowerCase();
}
function Ms(t) {
  return t === !1 || t == null ? t : Re.isArray(t) ? t.map(Ms) : String(t);
}
function $0(t) {
  const r = /* @__PURE__ */ Object.create(null), e = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let i;
  for (; i = e.exec(t); )
    r[i[1]] = i[2];
  return r;
}
const ey = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());
function Ua(t, r, e, i, n) {
  if (Re.isFunction(i))
    return i.call(this, r, e);
  if (n && (r = e), !!Re.isString(r)) {
    if (Re.isString(i))
      return r.indexOf(i) !== -1;
    if (Re.isRegExp(i))
      return i.test(r);
  }
}
function ty(t) {
  return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (r, e, i) => e.toUpperCase() + i);
}
function ry(t, r) {
  const e = Re.toCamelCase(" " + r);
  ["get", "set", "has"].forEach((i) => {
    Object.defineProperty(t, i + e, {
      value: function(n, s, l) {
        return this[i].call(this, r, n, s, l);
      },
      configurable: !0
    });
  });
}
class ea {
  constructor(r) {
    r && this.set(r);
  }
  set(r, e, i) {
    const n = this;
    function s(m, A, Y) {
      const q = Pn(A);
      if (!q)
        throw new Error("header name must be a non-empty string");
      const T = Re.findKey(n, q);
      (!T || n[T] === void 0 || Y === !0 || Y === void 0 && n[T] !== !1) && (n[T || A] = Ms(m));
    }
    const l = (m, A) => Re.forEach(m, (Y, q) => s(Y, q, A));
    return Re.isPlainObject(r) || r instanceof this.constructor ? l(r, e) : Re.isString(r) && (r = r.trim()) && !ey(r) ? l(_0(r), e) : r != null && s(e, r, i), this;
  }
  get(r, e) {
    if (r = Pn(r), r) {
      const i = Re.findKey(this, r);
      if (i) {
        const n = this[i];
        if (!e)
          return n;
        if (e === !0)
          return $0(n);
        if (Re.isFunction(e))
          return e.call(this, n, i);
        if (Re.isRegExp(e))
          return e.exec(n);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(r, e) {
    if (r = Pn(r), r) {
      const i = Re.findKey(this, r);
      return !!(i && this[i] !== void 0 && (!e || Ua(this, this[i], i, e)));
    }
    return !1;
  }
  delete(r, e) {
    const i = this;
    let n = !1;
    function s(l) {
      if (l = Pn(l), l) {
        const m = Re.findKey(i, l);
        m && (!e || Ua(i, i[m], m, e)) && (delete i[m], n = !0);
      }
    }
    return Re.isArray(r) ? r.forEach(s) : s(r), n;
  }
  clear(r) {
    const e = Object.keys(this);
    let i = e.length, n = !1;
    for (; i--; ) {
      const s = e[i];
      (!r || Ua(this, this[s], s, r, !0)) && (delete this[s], n = !0);
    }
    return n;
  }
  normalize(r) {
    const e = this, i = {};
    return Re.forEach(this, (n, s) => {
      const l = Re.findKey(i, s);
      if (l) {
        e[l] = Ms(n), delete e[s];
        return;
      }
      const m = r ? ty(s) : String(s).trim();
      m !== s && delete e[s], e[m] = Ms(n), i[m] = !0;
    }), this;
  }
  concat(...r) {
    return this.constructor.concat(this, ...r);
  }
  toJSON(r) {
    const e = /* @__PURE__ */ Object.create(null);
    return Re.forEach(this, (i, n) => {
      i != null && i !== !1 && (e[n] = r && Re.isArray(i) ? i.join(", ") : i);
    }), e;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([r, e]) => r + ": " + e).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(r) {
    return r instanceof this ? r : new this(r);
  }
  static concat(r, ...e) {
    const i = new this(r);
    return e.forEach((n) => i.set(n)), i;
  }
  static accessor(r) {
    const i = (this[Oc] = this[Oc] = {
      accessors: {}
    }).accessors, n = this.prototype;
    function s(l) {
      const m = Pn(l);
      i[m] || (ry(n, l), i[m] = !0);
    }
    return Re.isArray(r) ? r.forEach(s) : s(r), this;
  }
}
ea.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Re.reduceDescriptors(ea.prototype, ({ value: t }, r) => {
  let e = r[0].toUpperCase() + r.slice(1);
  return {
    get: () => t,
    set(i) {
      this[e] = i;
    }
  };
});
Re.freezeMethods(ea);
const Vr = ea;
function Ga(t, r) {
  const e = this || No, i = r || e, n = Vr.from(i.headers);
  let s = i.data;
  return Re.forEach(t, function(m) {
    s = m.call(e, s, n.normalize(), r ? r.status : void 0);
  }), n.normalize(), s;
}
function Bh(t) {
  return !!(t && t.__CANCEL__);
}
function ns(t, r, e) {
  wt.call(this, t ?? "canceled", wt.ERR_CANCELED, r, e), this.name = "CanceledError";
}
Re.inherits(ns, wt, {
  __CANCEL__: !0
});
function iy(t, r, e) {
  const i = e.config.validateStatus;
  !e.status || !i || i(e.status) ? t(e) : r(new wt(
    "Request failed with status code " + e.status,
    [wt.ERR_BAD_REQUEST, wt.ERR_BAD_RESPONSE][Math.floor(e.status / 100) - 4],
    e.config,
    e.request,
    e
  ));
}
const ny = Fr.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(t, r, e, i, n, s) {
      const l = [t + "=" + encodeURIComponent(r)];
      Re.isNumber(e) && l.push("expires=" + new Date(e).toGMTString()), Re.isString(i) && l.push("path=" + i), Re.isString(n) && l.push("domain=" + n), s === !0 && l.push("secure"), document.cookie = l.join("; ");
    },
    read(t) {
      const r = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
      return r ? decodeURIComponent(r[3]) : null;
    },
    remove(t) {
      this.write(t, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function sy(t) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t);
}
function ay(t, r) {
  return r ? t.replace(/\/?\/$/, "") + "/" + r.replace(/^\/+/, "") : t;
}
function Wh(t, r) {
  return t && !sy(r) ? ay(t, r) : r;
}
const oy = Fr.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const r = /(msie|trident)/i.test(navigator.userAgent), e = document.createElement("a");
    let i;
    function n(s) {
      let l = s;
      return r && (e.setAttribute("href", l), l = e.href), e.setAttribute("href", l), {
        href: e.href,
        protocol: e.protocol ? e.protocol.replace(/:$/, "") : "",
        host: e.host,
        search: e.search ? e.search.replace(/^\?/, "") : "",
        hash: e.hash ? e.hash.replace(/^#/, "") : "",
        hostname: e.hostname,
        port: e.port,
        pathname: e.pathname.charAt(0) === "/" ? e.pathname : "/" + e.pathname
      };
    }
    return i = n(window.location.href), function(l) {
      const m = Re.isString(l) ? n(l) : l;
      return m.protocol === i.protocol && m.host === i.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
);
function ly(t) {
  const r = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
  return r && r[1] || "";
}
function cy(t, r) {
  t = t || 10;
  const e = new Array(t), i = new Array(t);
  let n = 0, s = 0, l;
  return r = r !== void 0 ? r : 1e3, function(A) {
    const Y = Date.now(), q = i[s];
    l || (l = Y), e[n] = A, i[n] = Y;
    let T = s, B = 0;
    for (; T !== n; )
      B += e[T++], T = T % t;
    if (n = (n + 1) % t, n === s && (s = (s + 1) % t), Y - l < r)
      return;
    const O = q && Y - q;
    return O ? Math.round(B * 1e3 / O) : void 0;
  };
}
function Ac(t, r) {
  let e = 0;
  const i = cy(50, 250);
  return (n) => {
    const s = n.loaded, l = n.lengthComputable ? n.total : void 0, m = s - e, A = i(m), Y = s <= l;
    e = s;
    const q = {
      loaded: s,
      total: l,
      progress: l ? s / l : void 0,
      bytes: m,
      rate: A || void 0,
      estimated: A && l && Y ? (l - s) / A : void 0,
      event: n
    };
    q[r ? "download" : "upload"] = !0, t(q);
  };
}
const hy = typeof XMLHttpRequest < "u", dy = hy && function(t) {
  return new Promise(function(e, i) {
    let n = t.data;
    const s = Vr.from(t.headers).normalize();
    let { responseType: l, withXSRFToken: m } = t, A;
    function Y() {
      t.cancelToken && t.cancelToken.unsubscribe(A), t.signal && t.signal.removeEventListener("abort", A);
    }
    let q;
    if (Re.isFormData(n)) {
      if (Fr.hasStandardBrowserEnv || Fr.hasStandardBrowserWebWorkerEnv)
        s.setContentType(!1);
      else if ((q = s.getContentType()) !== !1) {
        const [v, ...E] = q ? q.split(";").map((M) => M.trim()).filter(Boolean) : [];
        s.setContentType([v || "multipart/form-data", ...E].join("; "));
      }
    }
    let T = new XMLHttpRequest();
    if (t.auth) {
      const v = t.auth.username || "", E = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : "";
      s.set("Authorization", "Basic " + btoa(v + ":" + E));
    }
    const B = Wh(t.baseURL, t.url);
    T.open(t.method.toUpperCase(), Nh(B, t.params, t.paramsSerializer), !0), T.timeout = t.timeout;
    function O() {
      if (!T)
        return;
      const v = Vr.from(
        "getAllResponseHeaders" in T && T.getAllResponseHeaders()
      ), M = {
        data: !l || l === "text" || l === "json" ? T.responseText : T.response,
        status: T.status,
        statusText: T.statusText,
        headers: v,
        config: t,
        request: T
      };
      iy(function(C) {
        e(C), Y();
      }, function(C) {
        i(C), Y();
      }, M), T = null;
    }
    if ("onloadend" in T ? T.onloadend = O : T.onreadystatechange = function() {
      !T || T.readyState !== 4 || T.status === 0 && !(T.responseURL && T.responseURL.indexOf("file:") === 0) || setTimeout(O);
    }, T.onabort = function() {
      T && (i(new wt("Request aborted", wt.ECONNABORTED, t, T)), T = null);
    }, T.onerror = function() {
      i(new wt("Network Error", wt.ERR_NETWORK, t, T)), T = null;
    }, T.ontimeout = function() {
      let E = t.timeout ? "timeout of " + t.timeout + "ms exceeded" : "timeout exceeded";
      const M = t.transitional || jh;
      t.timeoutErrorMessage && (E = t.timeoutErrorMessage), i(new wt(
        E,
        M.clarifyTimeoutError ? wt.ETIMEDOUT : wt.ECONNABORTED,
        t,
        T
      )), T = null;
    }, Fr.hasStandardBrowserEnv && (m && Re.isFunction(m) && (m = m(t)), m || m !== !1 && oy(B))) {
      const v = t.xsrfHeaderName && t.xsrfCookieName && ny.read(t.xsrfCookieName);
      v && s.set(t.xsrfHeaderName, v);
    }
    n === void 0 && s.setContentType(null), "setRequestHeader" in T && Re.forEach(s.toJSON(), function(E, M) {
      T.setRequestHeader(M, E);
    }), Re.isUndefined(t.withCredentials) || (T.withCredentials = !!t.withCredentials), l && l !== "json" && (T.responseType = t.responseType), typeof t.onDownloadProgress == "function" && T.addEventListener("progress", Ac(t.onDownloadProgress, !0)), typeof t.onUploadProgress == "function" && T.upload && T.upload.addEventListener("progress", Ac(t.onUploadProgress)), (t.cancelToken || t.signal) && (A = (v) => {
      T && (i(!v || v.type ? new ns(null, t, T) : v), T.abort(), T = null);
    }, t.cancelToken && t.cancelToken.subscribe(A), t.signal && (t.signal.aborted ? A() : t.signal.addEventListener("abort", A)));
    const b = ly(B);
    if (b && Fr.protocols.indexOf(b) === -1) {
      i(new wt("Unsupported protocol " + b + ":", wt.ERR_BAD_REQUEST, t));
      return;
    }
    T.send(n || null);
  });
}, fo = {
  http: I0,
  xhr: dy
};
Re.forEach(fo, (t, r) => {
  if (t) {
    try {
      Object.defineProperty(t, "name", { value: r });
    } catch {
    }
    Object.defineProperty(t, "adapterName", { value: r });
  }
});
const Ec = (t) => `- ${t}`, uy = (t) => Re.isFunction(t) || t === null || t === !1, Hh = {
  getAdapter: (t) => {
    t = Re.isArray(t) ? t : [t];
    const { length: r } = t;
    let e, i;
    const n = {};
    for (let s = 0; s < r; s++) {
      e = t[s];
      let l;
      if (i = e, !uy(e) && (i = fo[(l = String(e)).toLowerCase()], i === void 0))
        throw new wt(`Unknown adapter '${l}'`);
      if (i)
        break;
      n[l || "#" + s] = i;
    }
    if (!i) {
      const s = Object.entries(n).map(
        ([m, A]) => `adapter ${m} ` + (A === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let l = r ? s.length > 1 ? `since :
` + s.map(Ec).join(`
`) : " " + Ec(s[0]) : "as no adapter specified";
      throw new wt(
        "There is no suitable adapter to dispatch the request " + l,
        "ERR_NOT_SUPPORT"
      );
    }
    return i;
  },
  adapters: fo
};
function qa(t) {
  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)
    throw new ns(null, t);
}
function Pc(t) {
  return qa(t), t.headers = Vr.from(t.headers), t.data = Ga.call(
    t,
    t.transformRequest
  ), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), Hh.getAdapter(t.adapter || No.adapter)(t).then(function(i) {
    return qa(t), i.data = Ga.call(
      t,
      t.transformResponse,
      i
    ), i.headers = Vr.from(i.headers), i;
  }, function(i) {
    return Bh(i) || (qa(t), i && i.response && (i.response.data = Ga.call(
      t,
      t.transformResponse,
      i.response
    ), i.response.headers = Vr.from(i.response.headers))), Promise.reject(i);
  });
}
const Dc = (t) => t instanceof Vr ? { ...t } : t;
function yn(t, r) {
  r = r || {};
  const e = {};
  function i(Y, q, T) {
    return Re.isPlainObject(Y) && Re.isPlainObject(q) ? Re.merge.call({ caseless: T }, Y, q) : Re.isPlainObject(q) ? Re.merge({}, q) : Re.isArray(q) ? q.slice() : q;
  }
  function n(Y, q, T) {
    if (Re.isUndefined(q)) {
      if (!Re.isUndefined(Y))
        return i(void 0, Y, T);
    } else
      return i(Y, q, T);
  }
  function s(Y, q) {
    if (!Re.isUndefined(q))
      return i(void 0, q);
  }
  function l(Y, q) {
    if (Re.isUndefined(q)) {
      if (!Re.isUndefined(Y))
        return i(void 0, Y);
    } else
      return i(void 0, q);
  }
  function m(Y, q, T) {
    if (T in r)
      return i(Y, q);
    if (T in t)
      return i(void 0, Y);
  }
  const A = {
    url: s,
    method: s,
    data: s,
    baseURL: l,
    transformRequest: l,
    transformResponse: l,
    paramsSerializer: l,
    timeout: l,
    timeoutMessage: l,
    withCredentials: l,
    withXSRFToken: l,
    adapter: l,
    responseType: l,
    xsrfCookieName: l,
    xsrfHeaderName: l,
    onUploadProgress: l,
    onDownloadProgress: l,
    decompress: l,
    maxContentLength: l,
    maxBodyLength: l,
    beforeRedirect: l,
    transport: l,
    httpAgent: l,
    httpsAgent: l,
    cancelToken: l,
    socketPath: l,
    responseEncoding: l,
    validateStatus: m,
    headers: (Y, q) => n(Dc(Y), Dc(q), !0)
  };
  return Re.forEach(Object.keys(Object.assign({}, t, r)), function(q) {
    const T = A[q] || n, B = T(t[q], r[q], q);
    Re.isUndefined(B) && T !== m || (e[q] = B);
  }), e;
}
const zh = "1.6.8", jo = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, r) => {
  jo[t] = function(i) {
    return typeof i === t || "a" + (r < 1 ? "n " : " ") + t;
  };
});
const Lc = {};
jo.transitional = function(r, e, i) {
  function n(s, l) {
    return "[Axios v" + zh + "] Transitional option '" + s + "'" + l + (i ? ". " + i : "");
  }
  return (s, l, m) => {
    if (r === !1)
      throw new wt(
        n(l, " has been removed" + (e ? " in " + e : "")),
        wt.ERR_DEPRECATED
      );
    return e && !Lc[l] && (Lc[l] = !0, console.warn(
      n(
        l,
        " has been deprecated since v" + e + " and will be removed in the near future"
      )
    )), r ? r(s, l, m) : !0;
  };
};
function fy(t, r, e) {
  if (typeof t != "object")
    throw new wt("options must be an object", wt.ERR_BAD_OPTION_VALUE);
  const i = Object.keys(t);
  let n = i.length;
  for (; n-- > 0; ) {
    const s = i[n], l = r[s];
    if (l) {
      const m = t[s], A = m === void 0 || l(m, s, t);
      if (A !== !0)
        throw new wt("option " + s + " must be " + A, wt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (e !== !0)
      throw new wt("Unknown option " + s, wt.ERR_BAD_OPTION);
  }
}
const po = {
  assertOptions: fy,
  validators: jo
}, ii = po.validators;
class Ls {
  constructor(r) {
    this.defaults = r, this.interceptors = {
      request: new Tc(),
      response: new Tc()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(r, e) {
    try {
      return await this._request(r, e);
    } catch (i) {
      if (i instanceof Error) {
        let n;
        Error.captureStackTrace ? Error.captureStackTrace(n = {}) : n = new Error();
        const s = n.stack ? n.stack.replace(/^.+\n/, "") : "";
        i.stack ? s && !String(i.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (i.stack += `
` + s) : i.stack = s;
      }
      throw i;
    }
  }
  _request(r, e) {
    typeof r == "string" ? (e = e || {}, e.url = r) : e = r || {}, e = yn(this.defaults, e);
    const { transitional: i, paramsSerializer: n, headers: s } = e;
    i !== void 0 && po.assertOptions(i, {
      silentJSONParsing: ii.transitional(ii.boolean),
      forcedJSONParsing: ii.transitional(ii.boolean),
      clarifyTimeoutError: ii.transitional(ii.boolean)
    }, !1), n != null && (Re.isFunction(n) ? e.paramsSerializer = {
      serialize: n
    } : po.assertOptions(n, {
      encode: ii.function,
      serialize: ii.function
    }, !0)), e.method = (e.method || this.defaults.method || "get").toLowerCase();
    let l = s && Re.merge(
      s.common,
      s[e.method]
    );
    s && Re.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (b) => {
        delete s[b];
      }
    ), e.headers = Vr.concat(l, s);
    const m = [];
    let A = !0;
    this.interceptors.request.forEach(function(v) {
      typeof v.runWhen == "function" && v.runWhen(e) === !1 || (A = A && v.synchronous, m.unshift(v.fulfilled, v.rejected));
    });
    const Y = [];
    this.interceptors.response.forEach(function(v) {
      Y.push(v.fulfilled, v.rejected);
    });
    let q, T = 0, B;
    if (!A) {
      const b = [Pc.bind(this), void 0];
      for (b.unshift.apply(b, m), b.push.apply(b, Y), B = b.length, q = Promise.resolve(e); T < B; )
        q = q.then(b[T++], b[T++]);
      return q;
    }
    B = m.length;
    let O = e;
    for (T = 0; T < B; ) {
      const b = m[T++], v = m[T++];
      try {
        O = b(O);
      } catch (E) {
        v.call(this, E);
        break;
      }
    }
    try {
      q = Pc.call(this, O);
    } catch (b) {
      return Promise.reject(b);
    }
    for (T = 0, B = Y.length; T < B; )
      q = q.then(Y[T++], Y[T++]);
    return q;
  }
  getUri(r) {
    r = yn(this.defaults, r);
    const e = Wh(r.baseURL, r.url);
    return Nh(e, r.params, r.paramsSerializer);
  }
}
Re.forEach(["delete", "get", "head", "options"], function(r) {
  Ls.prototype[r] = function(e, i) {
    return this.request(yn(i || {}, {
      method: r,
      url: e,
      data: (i || {}).data
    }));
  };
});
Re.forEach(["post", "put", "patch"], function(r) {
  function e(i) {
    return function(s, l, m) {
      return this.request(yn(m || {}, {
        method: r,
        headers: i ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: l
      }));
    };
  }
  Ls.prototype[r] = e(), Ls.prototype[r + "Form"] = e(!0);
});
const Ts = Ls;
class Io {
  constructor(r) {
    if (typeof r != "function")
      throw new TypeError("executor must be a function.");
    let e;
    this.promise = new Promise(function(s) {
      e = s;
    });
    const i = this;
    this.promise.then((n) => {
      if (!i._listeners)
        return;
      let s = i._listeners.length;
      for (; s-- > 0; )
        i._listeners[s](n);
      i._listeners = null;
    }), this.promise.then = (n) => {
      let s;
      const l = new Promise((m) => {
        i.subscribe(m), s = m;
      }).then(n);
      return l.cancel = function() {
        i.unsubscribe(s);
      }, l;
    }, r(function(s, l, m) {
      i.reason || (i.reason = new ns(s, l, m), e(i.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(r) {
    if (this.reason) {
      r(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(r) : this._listeners = [r];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(r) {
    if (!this._listeners)
      return;
    const e = this._listeners.indexOf(r);
    e !== -1 && this._listeners.splice(e, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let r;
    return {
      token: new Io(function(n) {
        r = n;
      }),
      cancel: r
    };
  }
}
const py = Io;
function gy(t) {
  return function(e) {
    return t.apply(null, e);
  };
}
function my(t) {
  return Re.isObject(t) && t.isAxiosError === !0;
}
const go = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(go).forEach(([t, r]) => {
  go[r] = t;
});
const yy = go;
function Yh(t) {
  const r = new Ts(t), e = kh(Ts.prototype.request, r);
  return Re.extend(e, Ts.prototype, r, { allOwnKeys: !0 }), Re.extend(e, r, null, { allOwnKeys: !0 }), e.create = function(n) {
    return Yh(yn(t, n));
  }, e;
}
const Xt = Yh(No);
Xt.Axios = Ts;
Xt.CanceledError = ns;
Xt.CancelToken = py;
Xt.isCancel = Bh;
Xt.VERSION = zh;
Xt.toFormData = $s;
Xt.AxiosError = wt;
Xt.Cancel = Xt.CanceledError;
Xt.all = function(r) {
  return Promise.all(r);
};
Xt.spread = gy;
Xt.isAxiosError = my;
Xt.mergeConfig = yn;
Xt.AxiosHeaders = Vr;
Xt.formToJSON = (t) => Fh(Re.isHTMLForm(t) ? new FormData(t) : t);
Xt.getAdapter = Hh.getAdapter;
Xt.HttpStatusCode = yy;
Xt.default = Xt;
const ss = Xt.create({
  baseURL: "http://localhost:8000/leetcode",
  headers: {
    "Content-Type": "application/json"
  }
}), by = new Bm(), i2 = ({
  children: t
}) => /* @__PURE__ */ se.jsx(Um, { client: by, children: t });
function Ce(t) {
  const r = Object.prototype.toString.call(t);
  return t instanceof Date || typeof t == "object" && r === "[object Date]" ? new t.constructor(+t) : typeof t == "number" || r === "[object Number]" || typeof t == "string" || r === "[object String]" ? new Date(t) : /* @__PURE__ */ new Date(NaN);
}
function lt(t, r) {
  return t instanceof Date ? new t.constructor(r) : new Date(r);
}
function Hr(t, r) {
  const e = Ce(t);
  return isNaN(r) ? lt(t, NaN) : (r && e.setDate(e.getDate() + r), e);
}
function as(t, r) {
  const e = Ce(t);
  if (isNaN(r))
    return lt(t, NaN);
  if (!r)
    return e;
  const i = e.getDate(), n = lt(t, e.getTime());
  n.setMonth(e.getMonth() + r + 1, 0);
  const s = n.getDate();
  return i >= s ? n : (e.setFullYear(
    n.getFullYear(),
    n.getMonth(),
    i
  ), e);
}
function Zi(t, r) {
  const {
    years: e = 0,
    months: i = 0,
    weeks: n = 0,
    days: s = 0,
    hours: l = 0,
    minutes: m = 0,
    seconds: A = 0
  } = r, Y = Ce(t), q = i || e ? as(Y, i + e * 12) : Y, T = s || n ? Hr(q, s + n * 7) : q, B = m + l * 60, b = (A + B * 60) * 1e3;
  return lt(t, T.getTime() + b);
}
function Uh(t) {
  return Ce(t).getDay() === 6;
}
function Gh(t) {
  return Ce(t).getDay() === 0;
}
function _i(t) {
  const r = Ce(t).getDay();
  return r === 0 || r === 6;
}
function qh(t, r) {
  const e = Ce(t), i = _i(e);
  if (isNaN(r))
    return lt(t, NaN);
  const n = e.getHours(), s = r < 0 ? -1 : 1, l = Math.trunc(r / 5);
  e.setDate(e.getDate() + l * 7);
  let m = Math.abs(r % 5);
  for (; m > 0; )
    e.setDate(e.getDate() + s), _i(e) || (m -= 1);
  return i && _i(e) && r !== 0 && (Uh(e) && e.setDate(e.getDate() + (s < 0 ? 2 : -1)), Gh(e) && e.setDate(e.getDate() + (s < 0 ? 1 : -2))), e.setHours(n), e;
}
function os(t, r) {
  const e = +Ce(t);
  return lt(t, e + r);
}
const Xh = 7, Rs = 365.2425, ls = 6048e5, Qh = 864e5, Kr = 6e4, Ii = 36e5, Fo = 1e3, Rc = 525600, Ji = 43200, Ns = 1440, Vh = 60, Kh = 3, Zh = 12, Jh = 4, ta = 3600, Bo = 60, Wo = ta * 24, vy = Wo * 7, _h = Wo * Rs, $h = _h / 12, xy = $h * 3;
function Ho(t, r) {
  return os(t, r * Ii);
}
let ed = {};
function or() {
  return ed;
}
function wy(t) {
  ed = t;
}
function ir(t, r) {
  var m, A, Y, q;
  const e = or(), i = (r == null ? void 0 : r.weekStartsOn) ?? ((A = (m = r == null ? void 0 : r.locale) == null ? void 0 : m.options) == null ? void 0 : A.weekStartsOn) ?? e.weekStartsOn ?? ((q = (Y = e.locale) == null ? void 0 : Y.options) == null ? void 0 : q.weekStartsOn) ?? 0, n = Ce(t), s = n.getDay(), l = (s < i ? 7 : 0) + s - i;
  return n.setDate(n.getDate() - l), n.setHours(0, 0, 0, 0), n;
}
function Ar(t) {
  return ir(t, { weekStartsOn: 1 });
}
function di(t) {
  const r = Ce(t), e = r.getFullYear(), i = lt(t, 0);
  i.setFullYear(e + 1, 0, 4), i.setHours(0, 0, 0, 0);
  const n = Ar(i), s = lt(t, 0);
  s.setFullYear(e, 0, 4), s.setHours(0, 0, 0, 0);
  const l = Ar(s);
  return r.getTime() >= n.getTime() ? e + 1 : r.getTime() >= l.getTime() ? e : e - 1;
}
function bn(t) {
  const r = Ce(t);
  return r.setHours(0, 0, 0, 0), r;
}
function dr(t) {
  const r = Ce(t), e = new Date(
    Date.UTC(
      r.getFullYear(),
      r.getMonth(),
      r.getDate(),
      r.getHours(),
      r.getMinutes(),
      r.getSeconds(),
      r.getMilliseconds()
    )
  );
  return e.setUTCFullYear(r.getFullYear()), +t - +e;
}
function Br(t, r) {
  const e = bn(t), i = bn(r), n = +e - dr(e), s = +i - dr(i);
  return Math.round((n - s) / Qh);
}
function ui(t) {
  const r = di(t), e = lt(t, 0);
  return e.setFullYear(r, 0, 4), e.setHours(0, 0, 0, 0), Ar(e);
}
function td(t, r) {
  let e = Ce(t);
  const i = Br(e, ui(e)), n = lt(t, 0);
  return n.setFullYear(r, 0, 4), n.setHours(0, 0, 0, 0), e = ui(n), e.setDate(e.getDate() + i), e;
}
function rd(t, r) {
  return td(t, di(t) + r);
}
function zo(t, r) {
  return os(t, r * Kr);
}
function Yo(t, r) {
  const e = r * 3;
  return as(t, e);
}
function id(t, r) {
  return os(t, r * 1e3);
}
function ra(t, r) {
  const e = r * 7;
  return Hr(t, e);
}
function nd(t, r) {
  return as(t, r * 12);
}
function ky(t, r, e) {
  const [i, n] = [
    +Ce(t.start),
    +Ce(t.end)
  ].sort((m, A) => m - A), [s, l] = [
    +Ce(r.start),
    +Ce(r.end)
  ].sort((m, A) => m - A);
  return e != null && e.inclusive ? i <= l && s <= n : i < l && s < n;
}
function sd(t) {
  let r;
  return t.forEach(function(e) {
    const i = Ce(e);
    (r === void 0 || r < i || isNaN(Number(i))) && (r = i);
  }), r || /* @__PURE__ */ new Date(NaN);
}
function ad(t) {
  let r;
  return t.forEach((e) => {
    const i = Ce(e);
    (!r || r > i || isNaN(+i)) && (r = i);
  }), r || /* @__PURE__ */ new Date(NaN);
}
function Cy(t, r) {
  return ad([sd([t, r.start]), r.end]);
}
function Sy(t, r) {
  const e = Ce(t);
  if (isNaN(Number(e)))
    return NaN;
  const i = e.getTime();
  let n, s;
  return r.forEach(function(l, m) {
    const A = Ce(l);
    if (isNaN(Number(A))) {
      n = NaN, s = NaN;
      return;
    }
    const Y = Math.abs(i - A.getTime());
    (n == null || Y < s) && (n = m, s = Y);
  }), n;
}
function My(t, r) {
  const e = Ce(t);
  if (isNaN(Number(e)))
    return lt(t, NaN);
  const i = e.getTime();
  let n, s;
  return r.forEach((l) => {
    const m = Ce(l);
    if (isNaN(Number(m))) {
      n = lt(t, NaN), s = NaN;
      return;
    }
    const A = Math.abs(i - m.getTime());
    (n == null || A < s) && (n = m, s = A);
  }), n;
}
function Wr(t, r) {
  const e = Ce(t), i = Ce(r), n = e.getTime() - i.getTime();
  return n < 0 ? -1 : n > 0 ? 1 : n;
}
function Ty(t, r) {
  const e = Ce(t), i = Ce(r), n = e.getTime() - i.getTime();
  return n > 0 ? -1 : n < 0 ? 1 : n;
}
function ur(t) {
  return lt(t, Date.now());
}
function Oy(t) {
  const r = t / Xh, e = Math.trunc(r);
  return e === 0 ? 0 : e;
}
function cs(t, r) {
  const e = bn(t), i = bn(r);
  return +e == +i;
}
function od(t) {
  return t instanceof Date || typeof t == "object" && Object.prototype.toString.call(t) === "[object Date]";
}
function Zr(t) {
  if (!od(t) && typeof t != "number")
    return !1;
  const r = Ce(t);
  return !isNaN(Number(r));
}
function Ay(t, r) {
  const e = Ce(t);
  let i = Ce(r);
  if (!Zr(e) || !Zr(i))
    return NaN;
  const n = Br(e, i), s = n < 0 ? -1 : 1, l = Math.trunc(n / 7);
  let m = l * 5;
  for (i = Hr(i, l * 7); !cs(e, i); )
    m += _i(i) ? 0 : s, i = Hr(i, s);
  return m === 0 ? 0 : m;
}
function ld(t, r) {
  return di(t) - di(r);
}
function Ey(t, r) {
  const e = Ar(t), i = Ar(r), n = +e - dr(e), s = +i - dr(i);
  return Math.round((n - s) / ls);
}
function js(t, r) {
  const e = Ce(t), i = Ce(r), n = e.getFullYear() - i.getFullYear(), s = e.getMonth() - i.getMonth();
  return n * 12 + s;
}
function mo(t) {
  const r = Ce(t);
  return Math.trunc(r.getMonth() / 3) + 1;
}
function Os(t, r) {
  const e = Ce(t), i = Ce(r), n = e.getFullYear() - i.getFullYear(), s = mo(e) - mo(i);
  return n * 4 + s;
}
function Is(t, r, e) {
  const i = ir(t, e), n = ir(r, e), s = +i - dr(i), l = +n - dr(n);
  return Math.round((s - l) / ls);
}
function In(t, r) {
  const e = Ce(t), i = Ce(r);
  return e.getFullYear() - i.getFullYear();
}
function Uo(t, r) {
  const e = Ce(t), i = Ce(r), n = Nc(e, i), s = Math.abs(Br(e, i));
  e.setDate(e.getDate() - n * s);
  const l = +(Nc(e, i) === -n), m = n * (s - l);
  return m === 0 ? 0 : m;
}
function Nc(t, r) {
  const e = t.getFullYear() - r.getFullYear() || t.getMonth() - r.getMonth() || t.getDate() - r.getDate() || t.getHours() - r.getHours() || t.getMinutes() - r.getMinutes() || t.getSeconds() - r.getSeconds() || t.getMilliseconds() - r.getMilliseconds();
  return e < 0 ? -1 : e > 0 ? 1 : e;
}
function gi(t) {
  return (r) => {
    const i = (t ? Math[t] : Math.trunc)(r);
    return i === 0 ? 0 : i;
  };
}
function ia(t, r) {
  return +Ce(t) - +Ce(r);
}
function Fs(t, r, e) {
  const i = ia(t, r) / Ii;
  return gi(e == null ? void 0 : e.roundingMethod)(i);
}
function cd(t, r) {
  return rd(t, -r);
}
function Py(t, r) {
  let e = Ce(t);
  const i = Ce(r), n = Wr(e, i), s = Math.abs(
    ld(e, i)
  );
  e = cd(e, n * s);
  const l = +(Wr(e, i) === -n), m = n * (s - l);
  return m === 0 ? 0 : m;
}
function Bs(t, r, e) {
  const i = ia(t, r) / Kr;
  return gi(e == null ? void 0 : e.roundingMethod)(i);
}
function Go(t) {
  const r = Ce(t);
  return r.setHours(23, 59, 59, 999), r;
}
function qo(t) {
  const r = Ce(t), e = r.getMonth();
  return r.setFullYear(r.getFullYear(), e + 1, 0), r.setHours(23, 59, 59, 999), r;
}
function hd(t) {
  const r = Ce(t);
  return +Go(r) == +qo(r);
}
function na(t, r) {
  const e = Ce(t), i = Ce(r), n = Wr(e, i), s = Math.abs(
    js(e, i)
  );
  let l;
  if (s < 1)
    l = 0;
  else {
    e.getMonth() === 1 && e.getDate() > 27 && e.setDate(30), e.setMonth(e.getMonth() - n * s);
    let m = Wr(e, i) === -n;
    hd(Ce(t)) && s === 1 && Wr(t, i) === 1 && (m = !1), l = n * (s - Number(m));
  }
  return l === 0 ? 0 : l;
}
function Dy(t, r, e) {
  const i = na(t, r) / 3;
  return gi(e == null ? void 0 : e.roundingMethod)(i);
}
function $i(t, r, e) {
  const i = ia(t, r) / 1e3;
  return gi(e == null ? void 0 : e.roundingMethod)(i);
}
function Ly(t, r, e) {
  const i = Uo(t, r) / 7;
  return gi(e == null ? void 0 : e.roundingMethod)(i);
}
function dd(t, r) {
  const e = Ce(t), i = Ce(r), n = Wr(e, i), s = Math.abs(In(e, i));
  e.setFullYear(1584), i.setFullYear(1584);
  const l = Wr(e, i) === -n, m = n * (s - +l);
  return m === 0 ? 0 : m;
}
function ud(t, r) {
  const e = Ce(t.start), i = Ce(t.end);
  let n = +e > +i;
  const s = n ? +e : +i, l = n ? i : e;
  l.setHours(0, 0, 0, 0);
  let m = (r == null ? void 0 : r.step) ?? 1;
  if (!m)
    return [];
  m < 0 && (m = -m, n = !n);
  const A = [];
  for (; +l <= s; )
    A.push(Ce(l)), l.setDate(l.getDate() + m), l.setHours(0, 0, 0, 0);
  return n ? A.reverse() : A;
}
function Ry(t, r) {
  const e = Ce(t.start), i = Ce(t.end);
  let n = +e > +i;
  const s = n ? +e : +i;
  let l = n ? i : e;
  l.setMinutes(0, 0, 0);
  let m = (r == null ? void 0 : r.step) ?? 1;
  if (!m)
    return [];
  m < 0 && (m = -m, n = !n);
  const A = [];
  for (; +l <= s; )
    A.push(Ce(l)), l = Ho(l, m);
  return n ? A.reverse() : A;
}
function Ws(t) {
  const r = Ce(t);
  return r.setSeconds(0, 0), r;
}
function Ny(t, r) {
  const e = Ws(Ce(t.start)), i = Ce(t.end);
  let n = +e > +i;
  const s = n ? +e : +i;
  let l = n ? i : e, m = (r == null ? void 0 : r.step) ?? 1;
  if (!m)
    return [];
  m < 0 && (m = -m, n = !n);
  const A = [];
  for (; +l <= s; )
    A.push(Ce(l)), l = zo(l, m);
  return n ? A.reverse() : A;
}
function jy(t, r) {
  const e = Ce(t.start), i = Ce(t.end);
  let n = +e > +i;
  const s = n ? +e : +i, l = n ? i : e;
  l.setHours(0, 0, 0, 0), l.setDate(1);
  let m = (r == null ? void 0 : r.step) ?? 1;
  if (!m)
    return [];
  m < 0 && (m = -m, n = !n);
  const A = [];
  for (; +l <= s; )
    A.push(Ce(l)), l.setMonth(l.getMonth() + m);
  return n ? A.reverse() : A;
}
function Ci(t) {
  const r = Ce(t), e = r.getMonth(), i = e - e % 3;
  return r.setMonth(i, 1), r.setHours(0, 0, 0, 0), r;
}
function Iy(t, r) {
  const e = Ce(t.start), i = Ce(t.end);
  let n = +e > +i;
  const s = n ? +Ci(e) : +Ci(i);
  let l = Ci(n ? i : e), m = (r == null ? void 0 : r.step) ?? 1;
  if (!m)
    return [];
  m < 0 && (m = -m, n = !n);
  const A = [];
  for (; +l <= s; )
    A.push(Ce(l)), l = Yo(l, m);
  return n ? A.reverse() : A;
}
function Fy(t, r) {
  const e = Ce(t.start), i = Ce(t.end);
  let n = +e > +i;
  const s = ir(n ? i : e, r), l = ir(n ? e : i, r);
  s.setHours(15), l.setHours(15);
  const m = +l.getTime();
  let A = s, Y = (r == null ? void 0 : r.step) ?? 1;
  if (!Y)
    return [];
  Y < 0 && (Y = -Y, n = !n);
  const q = [];
  for (; +A <= m; )
    A.setHours(0), q.push(Ce(A)), A = ra(A, Y), A.setHours(15);
  return n ? q.reverse() : q;
}
function Xo(t) {
  const r = ud(t), e = [];
  let i = 0;
  for (; i < r.length; ) {
    const n = r[i++];
    _i(n) && e.push(n);
  }
  return e;
}
function sa(t) {
  const r = Ce(t);
  return r.setDate(1), r.setHours(0, 0, 0, 0), r;
}
function By(t) {
  const r = sa(t), e = qo(t);
  return Xo({ start: r, end: e });
}
function fd(t) {
  const r = Ce(t), e = r.getFullYear();
  return r.setFullYear(e + 1, 0, 0), r.setHours(23, 59, 59, 999), r;
}
function Qo(t) {
  const r = Ce(t), e = lt(t, 0);
  return e.setFullYear(r.getFullYear(), 0, 1), e.setHours(0, 0, 0, 0), e;
}
function Wy(t) {
  const r = Qo(t), e = fd(t);
  return Xo({ start: r, end: e });
}
function Hy(t, r) {
  const e = Ce(t.start), i = Ce(t.end);
  let n = +e > +i;
  const s = n ? +e : +i, l = n ? i : e;
  l.setHours(0, 0, 0, 0), l.setMonth(0, 1);
  let m = (r == null ? void 0 : r.step) ?? 1;
  if (!m)
    return [];
  m < 0 && (m = -m, n = !n);
  const A = [];
  for (; +l <= s; )
    A.push(Ce(l)), l.setFullYear(l.getFullYear() + m);
  return n ? A.reverse() : A;
}
function zy(t) {
  const r = Ce(t), e = r.getFullYear(), i = 9 + Math.floor(e / 10) * 10;
  return r.setFullYear(i, 11, 31), r.setHours(23, 59, 59, 999), r;
}
function Yy(t) {
  const r = Ce(t);
  return r.setMinutes(59, 59, 999), r;
}
function pd(t, r) {
  var m, A, Y, q;
  const e = or(), i = (r == null ? void 0 : r.weekStartsOn) ?? ((A = (m = r == null ? void 0 : r.locale) == null ? void 0 : m.options) == null ? void 0 : A.weekStartsOn) ?? e.weekStartsOn ?? ((q = (Y = e.locale) == null ? void 0 : Y.options) == null ? void 0 : q.weekStartsOn) ?? 0, n = Ce(t), s = n.getDay(), l = (s < i ? -7 : 0) + 6 - (s - i);
  return n.setDate(n.getDate() + l), n.setHours(23, 59, 59, 999), n;
}
function Uy(t) {
  return pd(t, { weekStartsOn: 1 });
}
function Gy(t) {
  const r = di(t), e = lt(t, 0);
  e.setFullYear(r + 1, 0, 4), e.setHours(0, 0, 0, 0);
  const i = Ar(e);
  return i.setMilliseconds(i.getMilliseconds() - 1), i;
}
function qy(t) {
  const r = Ce(t);
  return r.setSeconds(59, 999), r;
}
function Xy(t) {
  const r = Ce(t), e = r.getMonth(), i = e - e % 3 + 3;
  return r.setMonth(i, 0), r.setHours(23, 59, 59, 999), r;
}
function Qy(t) {
  const r = Ce(t);
  return r.setMilliseconds(999), r;
}
function Vy() {
  return Go(Date.now());
}
function Ky() {
  const t = /* @__PURE__ */ new Date(), r = t.getFullYear(), e = t.getMonth(), i = t.getDate(), n = /* @__PURE__ */ new Date(0);
  return n.setFullYear(r, e, i + 1), n.setHours(23, 59, 59, 999), n;
}
function Zy() {
  const t = /* @__PURE__ */ new Date(), r = t.getFullYear(), e = t.getMonth(), i = t.getDate(), n = /* @__PURE__ */ new Date(0);
  return n.setFullYear(r, e, i - 1), n.setHours(23, 59, 59, 999), n;
}
const Jy = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, _y = (t, r, e) => {
  let i;
  const n = Jy[t];
  return typeof n == "string" ? i = n : r === 1 ? i = n.one : i = n.other.replace("{{count}}", r.toString()), e != null && e.addSuffix ? e.comparison && e.comparison > 0 ? "in " + i : i + " ago" : i;
};
function Xa(t) {
  return (r = {}) => {
    const e = r.width ? String(r.width) : t.defaultWidth;
    return t.formats[e] || t.formats[t.defaultWidth];
  };
}
const $y = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, eb = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, tb = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, rb = {
  date: Xa({
    formats: $y,
    defaultWidth: "full"
  }),
  time: Xa({
    formats: eb,
    defaultWidth: "full"
  }),
  dateTime: Xa({
    formats: tb,
    defaultWidth: "full"
  })
}, ib = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, nb = (t, r, e, i) => ib[t];
function Dn(t) {
  return (r, e) => {
    const i = e != null && e.context ? String(e.context) : "standalone";
    let n;
    if (i === "formatting" && t.formattingValues) {
      const l = t.defaultFormattingWidth || t.defaultWidth, m = e != null && e.width ? String(e.width) : l;
      n = t.formattingValues[m] || t.formattingValues[l];
    } else {
      const l = t.defaultWidth, m = e != null && e.width ? String(e.width) : t.defaultWidth;
      n = t.values[m] || t.values[l];
    }
    const s = t.argumentCallback ? t.argumentCallback(r) : r;
    return n[s];
  };
}
const sb = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, ab = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, ob = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
}, lb = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
}, cb = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, hb = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, db = (t, r) => {
  const e = Number(t), i = e % 100;
  if (i > 20 || i < 10)
    switch (i % 10) {
      case 1:
        return e + "st";
      case 2:
        return e + "nd";
      case 3:
        return e + "rd";
    }
  return e + "th";
}, ub = {
  ordinalNumber: db,
  era: Dn({
    values: sb,
    defaultWidth: "wide"
  }),
  quarter: Dn({
    values: ab,
    defaultWidth: "wide",
    argumentCallback: (t) => t - 1
  }),
  month: Dn({
    values: ob,
    defaultWidth: "wide"
  }),
  day: Dn({
    values: lb,
    defaultWidth: "wide"
  }),
  dayPeriod: Dn({
    values: cb,
    defaultWidth: "wide",
    formattingValues: hb,
    defaultFormattingWidth: "wide"
  })
};
function Ln(t) {
  return (r, e = {}) => {
    const i = e.width, n = i && t.matchPatterns[i] || t.matchPatterns[t.defaultMatchWidth], s = r.match(n);
    if (!s)
      return null;
    const l = s[0], m = i && t.parsePatterns[i] || t.parsePatterns[t.defaultParseWidth], A = Array.isArray(m) ? pb(m, (T) => T.test(l)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      fb(m, (T) => T.test(l))
    );
    let Y;
    Y = t.valueCallback ? t.valueCallback(A) : A, Y = e.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      e.valueCallback(Y)
    ) : Y;
    const q = r.slice(l.length);
    return { value: Y, rest: q };
  };
}
function fb(t, r) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e) && r(t[e]))
      return e;
}
function pb(t, r) {
  for (let e = 0; e < t.length; e++)
    if (r(t[e]))
      return e;
}
function gb(t) {
  return (r, e = {}) => {
    const i = r.match(t.matchPattern);
    if (!i)
      return null;
    const n = i[0], s = r.match(t.parsePattern);
    if (!s)
      return null;
    let l = t.valueCallback ? t.valueCallback(s[0]) : s[0];
    l = e.valueCallback ? e.valueCallback(l) : l;
    const m = r.slice(n.length);
    return { value: l, rest: m };
  };
}
const mb = /^(\d+)(th|st|nd|rd)?/i, yb = /\d+/i, bb = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, vb = {
  any: [/^b/i, /^(a|c)/i]
}, xb = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, wb = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, kb = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, Cb = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
}, Sb = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, Mb = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, Tb = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, Ob = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, Ab = {
  ordinalNumber: gb({
    matchPattern: mb,
    parsePattern: yb,
    valueCallback: (t) => parseInt(t, 10)
  }),
  era: Ln({
    matchPatterns: bb,
    defaultMatchWidth: "wide",
    parsePatterns: vb,
    defaultParseWidth: "any"
  }),
  quarter: Ln({
    matchPatterns: xb,
    defaultMatchWidth: "wide",
    parsePatterns: wb,
    defaultParseWidth: "any",
    valueCallback: (t) => t + 1
  }),
  month: Ln({
    matchPatterns: kb,
    defaultMatchWidth: "wide",
    parsePatterns: Cb,
    defaultParseWidth: "any"
  }),
  day: Ln({
    matchPatterns: Sb,
    defaultMatchWidth: "wide",
    parsePatterns: Mb,
    defaultParseWidth: "any"
  }),
  dayPeriod: Ln({
    matchPatterns: Tb,
    defaultMatchWidth: "any",
    parsePatterns: Ob,
    defaultParseWidth: "any"
  })
}, Sn = {
  code: "en-US",
  formatDistance: _y,
  formatLong: rb,
  formatRelative: nb,
  localize: ub,
  match: Ab,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
function gd(t) {
  const r = Ce(t);
  return Br(r, Qo(r)) + 1;
}
function Vo(t) {
  const r = Ce(t), e = +Ar(r) - +ui(r);
  return Math.round(e / ls) + 1;
}
function aa(t, r) {
  var q, T, B, O;
  const e = Ce(t), i = e.getFullYear(), n = or(), s = (r == null ? void 0 : r.firstWeekContainsDate) ?? ((T = (q = r == null ? void 0 : r.locale) == null ? void 0 : q.options) == null ? void 0 : T.firstWeekContainsDate) ?? n.firstWeekContainsDate ?? ((O = (B = n.locale) == null ? void 0 : B.options) == null ? void 0 : O.firstWeekContainsDate) ?? 1, l = lt(t, 0);
  l.setFullYear(i + 1, 0, s), l.setHours(0, 0, 0, 0);
  const m = ir(l, r), A = lt(t, 0);
  A.setFullYear(i, 0, s), A.setHours(0, 0, 0, 0);
  const Y = ir(A, r);
  return e.getTime() >= m.getTime() ? i + 1 : e.getTime() >= Y.getTime() ? i : i - 1;
}
function Hs(t, r) {
  var m, A, Y, q;
  const e = or(), i = (r == null ? void 0 : r.firstWeekContainsDate) ?? ((A = (m = r == null ? void 0 : r.locale) == null ? void 0 : m.options) == null ? void 0 : A.firstWeekContainsDate) ?? e.firstWeekContainsDate ?? ((q = (Y = e.locale) == null ? void 0 : Y.options) == null ? void 0 : q.firstWeekContainsDate) ?? 1, n = aa(t, r), s = lt(t, 0);
  return s.setFullYear(n, 0, i), s.setHours(0, 0, 0, 0), ir(s, r);
}
function Ko(t, r) {
  const e = Ce(t), i = +ir(e, r) - +Hs(e, r);
  return Math.round(i / ls) + 1;
}
function $e(t, r) {
  const e = t < 0 ? "-" : "", i = Math.abs(t).toString().padStart(r, "0");
  return e + i;
}
const Pr = {
  // Year
  y(t, r) {
    const e = t.getFullYear(), i = e > 0 ? e : 1 - e;
    return $e(r === "yy" ? i % 100 : i, r.length);
  },
  // Month
  M(t, r) {
    const e = t.getMonth();
    return r === "M" ? String(e + 1) : $e(e + 1, 2);
  },
  // Day of the month
  d(t, r) {
    return $e(t.getDate(), r.length);
  },
  // AM or PM
  a(t, r) {
    const e = t.getHours() / 12 >= 1 ? "pm" : "am";
    switch (r) {
      case "a":
      case "aa":
        return e.toUpperCase();
      case "aaa":
        return e;
      case "aaaaa":
        return e[0];
      case "aaaa":
      default:
        return e === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h(t, r) {
    return $e(t.getHours() % 12 || 12, r.length);
  },
  // Hour [0-23]
  H(t, r) {
    return $e(t.getHours(), r.length);
  },
  // Minute
  m(t, r) {
    return $e(t.getMinutes(), r.length);
  },
  // Second
  s(t, r) {
    return $e(t.getSeconds(), r.length);
  },
  // Fraction of second
  S(t, r) {
    const e = r.length, i = t.getMilliseconds(), n = Math.trunc(
      i * Math.pow(10, e - 3)
    );
    return $e(n, r.length);
  }
}, Qi = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, yo = {
  // Era
  G: function(t, r, e) {
    const i = t.getFullYear() > 0 ? 1 : 0;
    switch (r) {
      case "G":
      case "GG":
      case "GGG":
        return e.era(i, { width: "abbreviated" });
      case "GGGGG":
        return e.era(i, { width: "narrow" });
      case "GGGG":
      default:
        return e.era(i, { width: "wide" });
    }
  },
  // Year
  y: function(t, r, e) {
    if (r === "yo") {
      const i = t.getFullYear(), n = i > 0 ? i : 1 - i;
      return e.ordinalNumber(n, { unit: "year" });
    }
    return Pr.y(t, r);
  },
  // Local week-numbering year
  Y: function(t, r, e, i) {
    const n = aa(t, i), s = n > 0 ? n : 1 - n;
    if (r === "YY") {
      const l = s % 100;
      return $e(l, 2);
    }
    return r === "Yo" ? e.ordinalNumber(s, { unit: "year" }) : $e(s, r.length);
  },
  // ISO week-numbering year
  R: function(t, r) {
    const e = di(t);
    return $e(e, r.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(t, r) {
    const e = t.getFullYear();
    return $e(e, r.length);
  },
  // Quarter
  Q: function(t, r, e) {
    const i = Math.ceil((t.getMonth() + 1) / 3);
    switch (r) {
      case "Q":
        return String(i);
      case "QQ":
        return $e(i, 2);
      case "Qo":
        return e.ordinalNumber(i, { unit: "quarter" });
      case "QQQ":
        return e.quarter(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return e.quarter(i, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return e.quarter(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(t, r, e) {
    const i = Math.ceil((t.getMonth() + 1) / 3);
    switch (r) {
      case "q":
        return String(i);
      case "qq":
        return $e(i, 2);
      case "qo":
        return e.ordinalNumber(i, { unit: "quarter" });
      case "qqq":
        return e.quarter(i, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return e.quarter(i, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return e.quarter(i, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(t, r, e) {
    const i = t.getMonth();
    switch (r) {
      case "M":
      case "MM":
        return Pr.M(t, r);
      case "Mo":
        return e.ordinalNumber(i + 1, { unit: "month" });
      case "MMM":
        return e.month(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return e.month(i, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return e.month(i, { width: "wide", context: "formatting" });
    }
  },
  // Stand-alone month
  L: function(t, r, e) {
    const i = t.getMonth();
    switch (r) {
      case "L":
        return String(i + 1);
      case "LL":
        return $e(i + 1, 2);
      case "Lo":
        return e.ordinalNumber(i + 1, { unit: "month" });
      case "LLL":
        return e.month(i, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return e.month(i, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return e.month(i, { width: "wide", context: "standalone" });
    }
  },
  // Local week of year
  w: function(t, r, e, i) {
    const n = Ko(t, i);
    return r === "wo" ? e.ordinalNumber(n, { unit: "week" }) : $e(n, r.length);
  },
  // ISO week of year
  I: function(t, r, e) {
    const i = Vo(t);
    return r === "Io" ? e.ordinalNumber(i, { unit: "week" }) : $e(i, r.length);
  },
  // Day of the month
  d: function(t, r, e) {
    return r === "do" ? e.ordinalNumber(t.getDate(), { unit: "date" }) : Pr.d(t, r);
  },
  // Day of year
  D: function(t, r, e) {
    const i = gd(t);
    return r === "Do" ? e.ordinalNumber(i, { unit: "dayOfYear" }) : $e(i, r.length);
  },
  // Day of week
  E: function(t, r, e) {
    const i = t.getDay();
    switch (r) {
      case "E":
      case "EE":
      case "EEE":
        return e.day(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return e.day(i, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return e.day(i, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return e.day(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(t, r, e, i) {
    const n = t.getDay(), s = (n - i.weekStartsOn + 8) % 7 || 7;
    switch (r) {
      case "e":
        return String(s);
      case "ee":
        return $e(s, 2);
      case "eo":
        return e.ordinalNumber(s, { unit: "day" });
      case "eee":
        return e.day(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return e.day(n, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return e.day(n, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return e.day(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(t, r, e, i) {
    const n = t.getDay(), s = (n - i.weekStartsOn + 8) % 7 || 7;
    switch (r) {
      case "c":
        return String(s);
      case "cc":
        return $e(s, r.length);
      case "co":
        return e.ordinalNumber(s, { unit: "day" });
      case "ccc":
        return e.day(n, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return e.day(n, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return e.day(n, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return e.day(n, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(t, r, e) {
    const i = t.getDay(), n = i === 0 ? 7 : i;
    switch (r) {
      case "i":
        return String(n);
      case "ii":
        return $e(n, r.length);
      case "io":
        return e.ordinalNumber(n, { unit: "day" });
      case "iii":
        return e.day(i, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return e.day(i, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return e.day(i, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return e.day(i, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(t, r, e) {
    const n = t.getHours() / 12 >= 1 ? "pm" : "am";
    switch (r) {
      case "a":
      case "aa":
        return e.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return e.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return e.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return e.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(t, r, e) {
    const i = t.getHours();
    let n;
    switch (i === 12 ? n = Qi.noon : i === 0 ? n = Qi.midnight : n = i / 12 >= 1 ? "pm" : "am", r) {
      case "b":
      case "bb":
        return e.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return e.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return e.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return e.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(t, r, e) {
    const i = t.getHours();
    let n;
    switch (i >= 17 ? n = Qi.evening : i >= 12 ? n = Qi.afternoon : i >= 4 ? n = Qi.morning : n = Qi.night, r) {
      case "B":
      case "BB":
      case "BBB":
        return e.dayPeriod(n, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return e.dayPeriod(n, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return e.dayPeriod(n, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(t, r, e) {
    if (r === "ho") {
      let i = t.getHours() % 12;
      return i === 0 && (i = 12), e.ordinalNumber(i, { unit: "hour" });
    }
    return Pr.h(t, r);
  },
  // Hour [0-23]
  H: function(t, r, e) {
    return r === "Ho" ? e.ordinalNumber(t.getHours(), { unit: "hour" }) : Pr.H(t, r);
  },
  // Hour [0-11]
  K: function(t, r, e) {
    const i = t.getHours() % 12;
    return r === "Ko" ? e.ordinalNumber(i, { unit: "hour" }) : $e(i, r.length);
  },
  // Hour [1-24]
  k: function(t, r, e) {
    let i = t.getHours();
    return i === 0 && (i = 24), r === "ko" ? e.ordinalNumber(i, { unit: "hour" }) : $e(i, r.length);
  },
  // Minute
  m: function(t, r, e) {
    return r === "mo" ? e.ordinalNumber(t.getMinutes(), { unit: "minute" }) : Pr.m(t, r);
  },
  // Second
  s: function(t, r, e) {
    return r === "so" ? e.ordinalNumber(t.getSeconds(), { unit: "second" }) : Pr.s(t, r);
  },
  // Fraction of second
  S: function(t, r) {
    return Pr.S(t, r);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(t, r, e) {
    const i = t.getTimezoneOffset();
    if (i === 0)
      return "Z";
    switch (r) {
      case "X":
        return Ic(i);
      case "XXXX":
      case "XX":
        return ki(i);
      case "XXXXX":
      case "XXX":
      default:
        return ki(i, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(t, r, e) {
    const i = t.getTimezoneOffset();
    switch (r) {
      case "x":
        return Ic(i);
      case "xxxx":
      case "xx":
        return ki(i);
      case "xxxxx":
      case "xxx":
      default:
        return ki(i, ":");
    }
  },
  // Timezone (GMT)
  O: function(t, r, e) {
    const i = t.getTimezoneOffset();
    switch (r) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + jc(i, ":");
      case "OOOO":
      default:
        return "GMT" + ki(i, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(t, r, e) {
    const i = t.getTimezoneOffset();
    switch (r) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + jc(i, ":");
      case "zzzz":
      default:
        return "GMT" + ki(i, ":");
    }
  },
  // Seconds timestamp
  t: function(t, r, e) {
    const i = Math.trunc(t.getTime() / 1e3);
    return $e(i, r.length);
  },
  // Milliseconds timestamp
  T: function(t, r, e) {
    const i = t.getTime();
    return $e(i, r.length);
  }
};
function jc(t, r = "") {
  const e = t > 0 ? "-" : "+", i = Math.abs(t), n = Math.trunc(i / 60), s = i % 60;
  return s === 0 ? e + String(n) : e + String(n) + r + $e(s, 2);
}
function Ic(t, r) {
  return t % 60 === 0 ? (t > 0 ? "-" : "+") + $e(Math.abs(t) / 60, 2) : ki(t, r);
}
function ki(t, r = "") {
  const e = t > 0 ? "-" : "+", i = Math.abs(t), n = $e(Math.trunc(i / 60), 2), s = $e(i % 60, 2);
  return e + n + r + s;
}
const Fc = (t, r) => {
  switch (t) {
    case "P":
      return r.date({ width: "short" });
    case "PP":
      return r.date({ width: "medium" });
    case "PPP":
      return r.date({ width: "long" });
    case "PPPP":
    default:
      return r.date({ width: "full" });
  }
}, md = (t, r) => {
  switch (t) {
    case "p":
      return r.time({ width: "short" });
    case "pp":
      return r.time({ width: "medium" });
    case "ppp":
      return r.time({ width: "long" });
    case "pppp":
    default:
      return r.time({ width: "full" });
  }
}, Eb = (t, r) => {
  const e = t.match(/(P+)(p+)?/) || [], i = e[1], n = e[2];
  if (!n)
    return Fc(t, r);
  let s;
  switch (i) {
    case "P":
      s = r.dateTime({ width: "short" });
      break;
    case "PP":
      s = r.dateTime({ width: "medium" });
      break;
    case "PPP":
      s = r.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      s = r.dateTime({ width: "full" });
      break;
  }
  return s.replace("{{date}}", Fc(i, r)).replace("{{time}}", md(n, r));
}, zs = {
  p: md,
  P: Eb
}, Pb = /^D+$/, Db = /^Y+$/, Lb = ["D", "DD", "YY", "YYYY"];
function yd(t) {
  return Pb.test(t);
}
function bd(t) {
  return Db.test(t);
}
function bo(t, r, e) {
  const i = Rb(t, r, e);
  if (console.warn(i), Lb.includes(t))
    throw new RangeError(i);
}
function Rb(t, r, e) {
  const i = t[0] === "Y" ? "years" : "days of the month";
  return `Use \`${t.toLowerCase()}\` instead of \`${t}\` (in \`${r}\`) for formatting ${i} to the input \`${e}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}
const Nb = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, jb = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, Ib = /^'([^]*?)'?$/, Fb = /''/g, Bb = /[a-zA-Z]/;
function hr(t, r, e) {
  var q, T, B, O, b, v, E, M;
  const i = or(), n = (e == null ? void 0 : e.locale) ?? i.locale ?? Sn, s = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((T = (q = e == null ? void 0 : e.locale) == null ? void 0 : q.options) == null ? void 0 : T.firstWeekContainsDate) ?? i.firstWeekContainsDate ?? ((O = (B = i.locale) == null ? void 0 : B.options) == null ? void 0 : O.firstWeekContainsDate) ?? 1, l = (e == null ? void 0 : e.weekStartsOn) ?? ((v = (b = e == null ? void 0 : e.locale) == null ? void 0 : b.options) == null ? void 0 : v.weekStartsOn) ?? i.weekStartsOn ?? ((M = (E = i.locale) == null ? void 0 : E.options) == null ? void 0 : M.weekStartsOn) ?? 0, m = Ce(t);
  if (!Zr(m))
    throw new RangeError("Invalid time value");
  let A = r.match(jb).map((g) => {
    const C = g[0];
    if (C === "p" || C === "P") {
      const j = zs[C];
      return j(g, n.formatLong);
    }
    return g;
  }).join("").match(Nb).map((g) => {
    if (g === "''")
      return { isToken: !1, value: "'" };
    const C = g[0];
    if (C === "'")
      return { isToken: !1, value: Wb(g) };
    if (yo[C])
      return { isToken: !0, value: g };
    if (C.match(Bb))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + C + "`"
      );
    return { isToken: !1, value: g };
  });
  n.localize.preprocessor && (A = n.localize.preprocessor(m, A));
  const Y = {
    firstWeekContainsDate: s,
    weekStartsOn: l,
    locale: n
  };
  return A.map((g) => {
    if (!g.isToken)
      return g.value;
    const C = g.value;
    (!(e != null && e.useAdditionalWeekYearTokens) && bd(C) || !(e != null && e.useAdditionalDayOfYearTokens) && yd(C)) && bo(C, r, String(t));
    const j = yo[C[0]];
    return j(m, C, n.localize, Y);
  }).join("");
}
function Wb(t) {
  const r = t.match(Ib);
  return r ? r[1].replace(Fb, "'") : t;
}
function vd(t, r, e) {
  const i = or(), n = (e == null ? void 0 : e.locale) ?? i.locale ?? Sn, s = 2520, l = Wr(t, r);
  if (isNaN(l))
    throw new RangeError("Invalid time value");
  const m = Object.assign({}, e, {
    addSuffix: e == null ? void 0 : e.addSuffix,
    comparison: l
  });
  let A, Y;
  l > 0 ? (A = Ce(r), Y = Ce(t)) : (A = Ce(t), Y = Ce(r));
  const q = $i(Y, A), T = (dr(Y) - dr(A)) / 1e3, B = Math.round((q - T) / 60);
  let O;
  if (B < 2)
    return e != null && e.includeSeconds ? q < 5 ? n.formatDistance("lessThanXSeconds", 5, m) : q < 10 ? n.formatDistance("lessThanXSeconds", 10, m) : q < 20 ? n.formatDistance("lessThanXSeconds", 20, m) : q < 40 ? n.formatDistance("halfAMinute", 0, m) : q < 60 ? n.formatDistance("lessThanXMinutes", 1, m) : n.formatDistance("xMinutes", 1, m) : B === 0 ? n.formatDistance("lessThanXMinutes", 1, m) : n.formatDistance("xMinutes", B, m);
  if (B < 45)
    return n.formatDistance("xMinutes", B, m);
  if (B < 90)
    return n.formatDistance("aboutXHours", 1, m);
  if (B < Ns) {
    const b = Math.round(B / 60);
    return n.formatDistance("aboutXHours", b, m);
  } else {
    if (B < s)
      return n.formatDistance("xDays", 1, m);
    if (B < Ji) {
      const b = Math.round(B / Ns);
      return n.formatDistance("xDays", b, m);
    } else if (B < Ji * 2)
      return O = Math.round(B / Ji), n.formatDistance("aboutXMonths", O, m);
  }
  if (O = na(Y, A), O < 12) {
    const b = Math.round(B / Ji);
    return n.formatDistance("xMonths", b, m);
  } else {
    const b = O % 12, v = Math.trunc(O / 12);
    return b < 3 ? n.formatDistance("aboutXYears", v, m) : b < 9 ? n.formatDistance("overXYears", v, m) : n.formatDistance("almostXYears", v + 1, m);
  }
}
function xd(t, r, e) {
  const i = or(), n = (e == null ? void 0 : e.locale) ?? i.locale ?? Sn, s = Wr(t, r);
  if (isNaN(s))
    throw new RangeError("Invalid time value");
  const l = Object.assign({}, e, {
    addSuffix: e == null ? void 0 : e.addSuffix,
    comparison: s
  });
  let m, A;
  s > 0 ? (m = Ce(r), A = Ce(t)) : (m = Ce(t), A = Ce(r));
  const Y = gi((e == null ? void 0 : e.roundingMethod) ?? "round"), q = A.getTime() - m.getTime(), T = q / Kr, B = dr(A) - dr(m), O = (q - B) / Kr, b = e == null ? void 0 : e.unit;
  let v;
  if (b ? v = b : T < 1 ? v = "second" : T < 60 ? v = "minute" : T < Ns ? v = "hour" : O < Ji ? v = "day" : O < Rc ? v = "month" : v = "year", v === "second") {
    const E = Y(q / 1e3);
    return n.formatDistance("xSeconds", E, l);
  } else if (v === "minute") {
    const E = Y(T);
    return n.formatDistance("xMinutes", E, l);
  } else if (v === "hour") {
    const E = Y(T / 60);
    return n.formatDistance("xHours", E, l);
  } else if (v === "day") {
    const E = Y(O / Ns);
    return n.formatDistance("xDays", E, l);
  } else if (v === "month") {
    const E = Y(O / Ji);
    return E === 12 && b !== "month" ? n.formatDistance("xYears", 1, l) : n.formatDistance("xMonths", E, l);
  } else {
    const E = Y(O / Rc);
    return n.formatDistance("xYears", E, l);
  }
}
function Hb(t, r) {
  return vd(t, ur(t), r);
}
function zb(t, r) {
  return xd(t, ur(t), r);
}
const Yb = [
  "years",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds"
];
function Ub(t, r) {
  const e = or(), i = (r == null ? void 0 : r.locale) ?? e.locale ?? Sn, n = (r == null ? void 0 : r.format) ?? Yb, s = (r == null ? void 0 : r.zero) ?? !1, l = (r == null ? void 0 : r.delimiter) ?? " ";
  return i.formatDistance ? n.reduce((A, Y) => {
    const q = `x${Y.replace(/(^.)/, (B) => B.toUpperCase())}`, T = t[Y];
    return T !== void 0 && (s || t[Y]) ? A.concat(i.formatDistance(q, T)) : A;
  }, []).join(l) : "";
}
function Gb(t, r) {
  const e = Ce(t);
  if (isNaN(e.getTime()))
    throw new RangeError("Invalid time value");
  const i = (r == null ? void 0 : r.format) ?? "extended", n = (r == null ? void 0 : r.representation) ?? "complete";
  let s = "", l = "";
  const m = i === "extended" ? "-" : "", A = i === "extended" ? ":" : "";
  if (n !== "time") {
    const Y = $e(e.getDate(), 2), q = $e(e.getMonth() + 1, 2);
    s = `${$e(e.getFullYear(), 4)}${m}${q}${m}${Y}`;
  }
  if (n !== "date") {
    const Y = e.getTimezoneOffset();
    if (Y !== 0) {
      const v = Math.abs(Y), E = $e(Math.trunc(v / 60), 2), M = $e(v % 60, 2);
      l = `${Y < 0 ? "+" : "-"}${E}:${M}`;
    } else
      l = "Z";
    const q = $e(e.getHours(), 2), T = $e(e.getMinutes(), 2), B = $e(e.getSeconds(), 2), O = s === "" ? "" : "T", b = [q, T, B].join(A);
    s = `${s}${O}${b}${l}`;
  }
  return s;
}
function qb(t, r) {
  const e = Ce(t);
  if (!Zr(e))
    throw new RangeError("Invalid time value");
  const i = (r == null ? void 0 : r.format) ?? "extended", n = (r == null ? void 0 : r.representation) ?? "complete";
  let s = "";
  const l = i === "extended" ? "-" : "", m = i === "extended" ? ":" : "";
  if (n !== "time") {
    const A = $e(e.getDate(), 2), Y = $e(e.getMonth() + 1, 2);
    s = `${$e(e.getFullYear(), 4)}${l}${Y}${l}${A}`;
  }
  if (n !== "date") {
    const A = $e(e.getHours(), 2), Y = $e(e.getMinutes(), 2), q = $e(e.getSeconds(), 2);
    s = `${s}${s === "" ? "" : " "}${A}${m}${Y}${m}${q}`;
  }
  return s;
}
function Xb(t) {
  const {
    years: r = 0,
    months: e = 0,
    days: i = 0,
    hours: n = 0,
    minutes: s = 0,
    seconds: l = 0
  } = t;
  return `P${r}Y${e}M${i}DT${n}H${s}M${l}S`;
}
function Qb(t, r) {
  const e = Ce(t);
  if (!Zr(e))
    throw new RangeError("Invalid time value");
  const i = (r == null ? void 0 : r.fractionDigits) ?? 0, n = $e(e.getDate(), 2), s = $e(e.getMonth() + 1, 2), l = e.getFullYear(), m = $e(e.getHours(), 2), A = $e(e.getMinutes(), 2), Y = $e(e.getSeconds(), 2);
  let q = "";
  if (i > 0) {
    const O = e.getMilliseconds(), b = Math.trunc(
      O * Math.pow(10, i - 3)
    );
    q = "." + $e(b, i);
  }
  let T = "";
  const B = e.getTimezoneOffset();
  if (B !== 0) {
    const O = Math.abs(B), b = $e(Math.trunc(O / 60), 2), v = $e(O % 60, 2);
    T = `${B < 0 ? "+" : "-"}${b}:${v}`;
  } else
    T = "Z";
  return `${l}-${s}-${n}T${m}:${A}:${Y}${q}${T}`;
}
const Vb = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], Kb = [
  "Jan",
  "Feb",
  "Mar",
  "Apr",
  "May",
  "Jun",
  "Jul",
  "Aug",
  "Sep",
  "Oct",
  "Nov",
  "Dec"
];
function Zb(t) {
  const r = Ce(t);
  if (!Zr(r))
    throw new RangeError("Invalid time value");
  const e = Vb[r.getUTCDay()], i = $e(r.getUTCDate(), 2), n = Kb[r.getUTCMonth()], s = r.getUTCFullYear(), l = $e(r.getUTCHours(), 2), m = $e(r.getUTCMinutes(), 2), A = $e(r.getUTCSeconds(), 2);
  return `${e}, ${i} ${n} ${s} ${l}:${m}:${A} GMT`;
}
function Jb(t, r, e) {
  var T, B, O, b;
  const i = Ce(t), n = Ce(r), s = or(), l = (e == null ? void 0 : e.locale) ?? s.locale ?? Sn, m = (e == null ? void 0 : e.weekStartsOn) ?? ((B = (T = e == null ? void 0 : e.locale) == null ? void 0 : T.options) == null ? void 0 : B.weekStartsOn) ?? s.weekStartsOn ?? ((b = (O = s.locale) == null ? void 0 : O.options) == null ? void 0 : b.weekStartsOn) ?? 0, A = Br(i, n);
  if (isNaN(A))
    throw new RangeError("Invalid time value");
  let Y;
  A < -6 ? Y = "other" : A < -1 ? Y = "lastWeek" : A < 0 ? Y = "yesterday" : A < 1 ? Y = "today" : A < 2 ? Y = "tomorrow" : A < 7 ? Y = "nextWeek" : Y = "other";
  const q = l.formatRelative(Y, i, n, {
    locale: l,
    weekStartsOn: m
  });
  return hr(i, q, { locale: l, weekStartsOn: m });
}
function _b(t) {
  return Ce(t * 1e3);
}
function wd(t) {
  return Ce(t).getDate();
}
function oa(t) {
  return Ce(t).getDay();
}
function kd(t) {
  const r = Ce(t), e = r.getFullYear(), i = r.getMonth(), n = lt(t, 0);
  return n.setFullYear(e, i + 1, 0), n.setHours(0, 0, 0, 0), n.getDate();
}
function Cd(t) {
  const e = Ce(t).getFullYear();
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function $b(t) {
  const r = Ce(t);
  return String(new Date(r)) === "Invalid Date" ? NaN : Cd(r) ? 366 : 365;
}
function ev(t) {
  const e = Ce(t).getFullYear();
  return Math.floor(e / 10) * 10;
}
function Sd() {
  return Object.assign({}, or());
}
function tv(t) {
  return Ce(t).getHours();
}
function Md(t) {
  let e = Ce(t).getDay();
  return e === 0 && (e = 7), e;
}
function rv(t) {
  const r = ui(t), i = +ui(ra(r, 60)) - +r;
  return Math.round(i / ls);
}
function iv(t) {
  return Ce(t).getMilliseconds();
}
function nv(t) {
  return Ce(t).getMinutes();
}
function sv(t) {
  return Ce(t).getMonth();
}
function av(t, r) {
  const [e, i] = [
    +Ce(t.start),
    +Ce(t.end)
  ].sort((T, B) => T - B), [n, s] = [
    +Ce(r.start),
    +Ce(r.end)
  ].sort((T, B) => T - B);
  if (!(e < s && n < i))
    return 0;
  const m = n < e ? e : n, A = m - dr(m), Y = s > i ? i : s, q = Y - dr(Y);
  return Math.ceil((q - A) / Qh);
}
function ov(t) {
  return Ce(t).getSeconds();
}
function lv(t) {
  return Ce(t).getTime();
}
function cv(t) {
  return Math.trunc(+Ce(t) / 1e3);
}
function hv(t, r) {
  var A, Y, q, T;
  const e = or(), i = (r == null ? void 0 : r.weekStartsOn) ?? ((Y = (A = r == null ? void 0 : r.locale) == null ? void 0 : A.options) == null ? void 0 : Y.weekStartsOn) ?? e.weekStartsOn ?? ((T = (q = e.locale) == null ? void 0 : q.options) == null ? void 0 : T.weekStartsOn) ?? 0, n = wd(t);
  if (isNaN(n))
    return NaN;
  const s = oa(sa(t));
  let l = i - s;
  l <= 0 && (l += 7);
  const m = n - l;
  return Math.ceil(m / 7) + 1;
}
function Td(t) {
  const r = Ce(t), e = r.getMonth();
  return r.setFullYear(r.getFullYear(), e + 1, 0), r.setHours(0, 0, 0, 0), r;
}
function dv(t, r) {
  return Is(
    Td(t),
    sa(t),
    r
  ) + 1;
}
function uv(t) {
  return Ce(t).getFullYear();
}
function fv(t) {
  return Math.trunc(t * Ii);
}
function pv(t) {
  return Math.trunc(t * Vh);
}
function gv(t) {
  return Math.trunc(t * ta);
}
function mv(t, r, e) {
  const i = Ce(t);
  if (isNaN(+i))
    throw new TypeError("Start date is invalid");
  const n = Ce(r);
  if (isNaN(+n))
    throw new TypeError("End date is invalid");
  if (e != null && e.assertPositive && +i > +n)
    throw new TypeError("End date must be after start date");
  return { start: i, end: n };
}
function yv(t) {
  const r = Ce(t.start), e = Ce(t.end), i = {}, n = dd(e, r);
  n && (i.years = n);
  const s = Zi(r, { years: i.years }), l = na(e, s);
  l && (i.months = l);
  const m = Zi(s, { months: i.months }), A = Uo(e, m);
  A && (i.days = A);
  const Y = Zi(m, { days: i.days }), q = Fs(e, Y);
  q && (i.hours = q);
  const T = Zi(Y, { hours: i.hours }), B = Bs(e, T);
  B && (i.minutes = B);
  const O = Zi(T, { minutes: i.minutes }), b = $i(e, O);
  return b && (i.seconds = b), i;
}
function bv(t, r, e) {
  let i;
  return vv(r) ? i = r : e = r, new Intl.DateTimeFormat(e == null ? void 0 : e.locale, i).format(
    Ce(t)
  );
}
function vv(t) {
  return t !== void 0 && !("locale" in t);
}
function xv(t, r, e) {
  let i = 0, n;
  const s = Ce(t), l = Ce(r);
  if (e != null && e.unit)
    n = e == null ? void 0 : e.unit, n === "second" ? i = $i(s, l) : n === "minute" ? i = Bs(s, l) : n === "hour" ? i = Fs(s, l) : n === "day" ? i = Br(s, l) : n === "week" ? i = Is(s, l) : n === "month" ? i = js(s, l) : n === "quarter" ? i = Os(s, l) : n === "year" && (i = In(s, l));
  else {
    const A = $i(s, l);
    Math.abs(A) < Bo ? (i = $i(s, l), n = "second") : Math.abs(A) < ta ? (i = Bs(s, l), n = "minute") : Math.abs(A) < Wo && Math.abs(Br(s, l)) < 1 ? (i = Fs(s, l), n = "hour") : Math.abs(A) < vy && (i = Br(s, l)) && Math.abs(i) < 7 ? n = "day" : Math.abs(A) < $h ? (i = Is(s, l), n = "week") : Math.abs(A) < xy ? (i = js(s, l), n = "month") : Math.abs(A) < _h && Os(s, l) < 4 ? (i = Os(s, l), n = "quarter") : (i = In(s, l), n = "year");
  }
  return new Intl.RelativeTimeFormat(e == null ? void 0 : e.locale, {
    localeMatcher: e == null ? void 0 : e.localeMatcher,
    numeric: (e == null ? void 0 : e.numeric) || "auto",
    style: e == null ? void 0 : e.style
  }).format(i, n);
}
function wv(t, r) {
  const e = Ce(t), i = Ce(r);
  return e.getTime() > i.getTime();
}
function kv(t, r) {
  const e = Ce(t), i = Ce(r);
  return +e < +i;
}
function Cv(t, r) {
  const e = Ce(t), i = Ce(r);
  return +e == +i;
}
function Sv(t, r, e) {
  const i = new Date(t, r, e);
  return i.getFullYear() === t && i.getMonth() === r && i.getDate() === e;
}
function Mv(t) {
  return Ce(t).getDate() === 1;
}
function Tv(t) {
  return Ce(t).getDay() === 5;
}
function Ov(t) {
  return +Ce(t) > Date.now();
}
function Od(t, r) {
  const e = r instanceof Date ? lt(r, 0) : new r(0);
  return e.setFullYear(
    t.getFullYear(),
    t.getMonth(),
    t.getDate()
  ), e.setHours(
    t.getHours(),
    t.getMinutes(),
    t.getSeconds(),
    t.getMilliseconds()
  ), e;
}
const Av = 10;
class Ad {
  constructor() {
    Ge(this, "subPriority", 0);
  }
  validate(r, e) {
    return !0;
  }
}
class Ev extends Ad {
  constructor(r, e, i, n, s) {
    super(), this.value = r, this.validateValue = e, this.setValue = i, this.priority = n, s && (this.subPriority = s);
  }
  validate(r, e) {
    return this.validateValue(r, this.value, e);
  }
  set(r, e, i) {
    return this.setValue(r, e, this.value, i);
  }
}
class Pv extends Ad {
  constructor() {
    super(...arguments);
    Ge(this, "priority", Av);
    Ge(this, "subPriority", -1);
  }
  set(e, i) {
    return i.timestampIsSet ? e : lt(e, Od(e, Date));
  }
}
class St {
  run(r, e, i, n) {
    const s = this.parse(r, e, i, n);
    return s ? {
      setter: new Ev(
        s.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: s.rest
    } : null;
  }
  validate(r, e, i) {
    return !0;
  }
}
class Dv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 140);
    Ge(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(e, i, n) {
    switch (i) {
      case "G":
      case "GG":
      case "GGG":
        return n.era(e, { width: "abbreviated" }) || n.era(e, { width: "narrow" });
      case "GGGGG":
        return n.era(e, { width: "narrow" });
      case "GGGG":
      default:
        return n.era(e, { width: "wide" }) || n.era(e, { width: "abbreviated" }) || n.era(e, { width: "narrow" });
    }
  }
  set(e, i, n) {
    return i.era = n, e.setFullYear(n, 0, 1), e.setHours(0, 0, 0, 0), e;
  }
}
const Yt = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
}, jr = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function Ut(t, r) {
  return t && {
    value: r(t.value),
    rest: t.rest
  };
}
function Ft(t, r) {
  const e = r.match(t);
  return e ? {
    value: parseInt(e[0], 10),
    rest: r.slice(e[0].length)
  } : null;
}
function Ir(t, r) {
  const e = r.match(t);
  if (!e)
    return null;
  if (e[0] === "Z")
    return {
      value: 0,
      rest: r.slice(1)
    };
  const i = e[1] === "+" ? 1 : -1, n = e[2] ? parseInt(e[2], 10) : 0, s = e[3] ? parseInt(e[3], 10) : 0, l = e[5] ? parseInt(e[5], 10) : 0;
  return {
    value: i * (n * Ii + s * Kr + l * Fo),
    rest: r.slice(e[0].length)
  };
}
function Ed(t) {
  return Ft(Yt.anyDigitsSigned, t);
}
function Ht(t, r) {
  switch (t) {
    case 1:
      return Ft(Yt.singleDigit, r);
    case 2:
      return Ft(Yt.twoDigits, r);
    case 3:
      return Ft(Yt.threeDigits, r);
    case 4:
      return Ft(Yt.fourDigits, r);
    default:
      return Ft(new RegExp("^\\d{1," + t + "}"), r);
  }
}
function Ys(t, r) {
  switch (t) {
    case 1:
      return Ft(Yt.singleDigitSigned, r);
    case 2:
      return Ft(Yt.twoDigitsSigned, r);
    case 3:
      return Ft(Yt.threeDigitsSigned, r);
    case 4:
      return Ft(Yt.fourDigitsSigned, r);
    default:
      return Ft(new RegExp("^-?\\d{1," + t + "}"), r);
  }
}
function Zo(t) {
  switch (t) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function Pd(t, r) {
  const e = r > 0, i = e ? r : 1 - r;
  let n;
  if (i <= 50)
    n = t || 100;
  else {
    const s = i + 50, l = Math.trunc(s / 100) * 100, m = t >= s % 100;
    n = t + l - (m ? 100 : 0);
  }
  return e ? n : 1 - n;
}
function Dd(t) {
  return t % 400 === 0 || t % 4 === 0 && t % 100 !== 0;
}
class Lv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 130);
    Ge(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(e, i, n) {
    const s = (l) => ({
      year: l,
      isTwoDigitYear: i === "yy"
    });
    switch (i) {
      case "y":
        return Ut(Ht(4, e), s);
      case "yo":
        return Ut(
          n.ordinalNumber(e, {
            unit: "year"
          }),
          s
        );
      default:
        return Ut(Ht(i.length, e), s);
    }
  }
  validate(e, i) {
    return i.isTwoDigitYear || i.year > 0;
  }
  set(e, i, n) {
    const s = e.getFullYear();
    if (n.isTwoDigitYear) {
      const m = Pd(
        n.year,
        s
      );
      return e.setFullYear(m, 0, 1), e.setHours(0, 0, 0, 0), e;
    }
    const l = !("era" in i) || i.era === 1 ? n.year : 1 - n.year;
    return e.setFullYear(l, 0, 1), e.setHours(0, 0, 0, 0), e;
  }
}
class Rv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 130);
    Ge(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(e, i, n) {
    const s = (l) => ({
      year: l,
      isTwoDigitYear: i === "YY"
    });
    switch (i) {
      case "Y":
        return Ut(Ht(4, e), s);
      case "Yo":
        return Ut(
          n.ordinalNumber(e, {
            unit: "year"
          }),
          s
        );
      default:
        return Ut(Ht(i.length, e), s);
    }
  }
  validate(e, i) {
    return i.isTwoDigitYear || i.year > 0;
  }
  set(e, i, n, s) {
    const l = aa(e, s);
    if (n.isTwoDigitYear) {
      const A = Pd(
        n.year,
        l
      );
      return e.setFullYear(
        A,
        0,
        s.firstWeekContainsDate
      ), e.setHours(0, 0, 0, 0), ir(e, s);
    }
    const m = !("era" in i) || i.era === 1 ? n.year : 1 - n.year;
    return e.setFullYear(m, 0, s.firstWeekContainsDate), e.setHours(0, 0, 0, 0), ir(e, s);
  }
}
class Nv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 130);
    Ge(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, i) {
    return Ys(i === "R" ? 4 : i.length, e);
  }
  set(e, i, n) {
    const s = lt(e, 0);
    return s.setFullYear(n, 0, 4), s.setHours(0, 0, 0, 0), Ar(s);
  }
}
class jv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 130);
    Ge(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(e, i) {
    return Ys(i === "u" ? 4 : i.length, e);
  }
  set(e, i, n) {
    return e.setFullYear(n, 0, 1), e.setHours(0, 0, 0, 0), e;
  }
}
class Iv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 120);
    Ge(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, i, n) {
    switch (i) {
      case "Q":
      case "QQ":
        return Ht(i.length, e);
      case "Qo":
        return n.ordinalNumber(e, { unit: "quarter" });
      case "QQQ":
        return n.quarter(e, {
          width: "abbreviated",
          context: "formatting"
        }) || n.quarter(e, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return n.quarter(e, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return n.quarter(e, {
          width: "wide",
          context: "formatting"
        }) || n.quarter(e, {
          width: "abbreviated",
          context: "formatting"
        }) || n.quarter(e, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(e, i) {
    return i >= 1 && i <= 4;
  }
  set(e, i, n) {
    return e.setMonth((n - 1) * 3, 1), e.setHours(0, 0, 0, 0), e;
  }
}
class Fv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 120);
    Ge(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, i, n) {
    switch (i) {
      case "q":
      case "qq":
        return Ht(i.length, e);
      case "qo":
        return n.ordinalNumber(e, { unit: "quarter" });
      case "qqq":
        return n.quarter(e, {
          width: "abbreviated",
          context: "standalone"
        }) || n.quarter(e, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return n.quarter(e, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return n.quarter(e, {
          width: "wide",
          context: "standalone"
        }) || n.quarter(e, {
          width: "abbreviated",
          context: "standalone"
        }) || n.quarter(e, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(e, i) {
    return i >= 1 && i <= 4;
  }
  set(e, i, n) {
    return e.setMonth((n - 1) * 3, 1), e.setHours(0, 0, 0, 0), e;
  }
}
class Bv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    Ge(this, "priority", 110);
  }
  parse(e, i, n) {
    const s = (l) => l - 1;
    switch (i) {
      case "M":
        return Ut(
          Ft(Yt.month, e),
          s
        );
      case "MM":
        return Ut(Ht(2, e), s);
      case "Mo":
        return Ut(
          n.ordinalNumber(e, {
            unit: "month"
          }),
          s
        );
      case "MMM":
        return n.month(e, {
          width: "abbreviated",
          context: "formatting"
        }) || n.month(e, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return n.month(e, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return n.month(e, { width: "wide", context: "formatting" }) || n.month(e, {
          width: "abbreviated",
          context: "formatting"
        }) || n.month(e, { width: "narrow", context: "formatting" });
    }
  }
  validate(e, i) {
    return i >= 0 && i <= 11;
  }
  set(e, i, n) {
    return e.setMonth(n, 1), e.setHours(0, 0, 0, 0), e;
  }
}
class Wv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 110);
    Ge(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, i, n) {
    const s = (l) => l - 1;
    switch (i) {
      case "L":
        return Ut(
          Ft(Yt.month, e),
          s
        );
      case "LL":
        return Ut(Ht(2, e), s);
      case "Lo":
        return Ut(
          n.ordinalNumber(e, {
            unit: "month"
          }),
          s
        );
      case "LLL":
        return n.month(e, {
          width: "abbreviated",
          context: "standalone"
        }) || n.month(e, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return n.month(e, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return n.month(e, { width: "wide", context: "standalone" }) || n.month(e, {
          width: "abbreviated",
          context: "standalone"
        }) || n.month(e, { width: "narrow", context: "standalone" });
    }
  }
  validate(e, i) {
    return i >= 0 && i <= 11;
  }
  set(e, i, n) {
    return e.setMonth(n, 1), e.setHours(0, 0, 0, 0), e;
  }
}
function Ld(t, r, e) {
  const i = Ce(t), n = Ko(i, e) - r;
  return i.setDate(i.getDate() - n * 7), i;
}
class Hv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 100);
    Ge(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(e, i, n) {
    switch (i) {
      case "w":
        return Ft(Yt.week, e);
      case "wo":
        return n.ordinalNumber(e, { unit: "week" });
      default:
        return Ht(i.length, e);
    }
  }
  validate(e, i) {
    return i >= 1 && i <= 53;
  }
  set(e, i, n, s) {
    return ir(Ld(e, n, s), s);
  }
}
function Rd(t, r) {
  const e = Ce(t), i = Vo(e) - r;
  return e.setDate(e.getDate() - i * 7), e;
}
class zv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 100);
    Ge(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, i, n) {
    switch (i) {
      case "I":
        return Ft(Yt.week, e);
      case "Io":
        return n.ordinalNumber(e, { unit: "week" });
      default:
        return Ht(i.length, e);
    }
  }
  validate(e, i) {
    return i >= 1 && i <= 53;
  }
  set(e, i, n) {
    return Ar(Rd(e, n));
  }
}
const Yv = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Uv = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
class Gv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 90);
    Ge(this, "subPriority", 1);
    Ge(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, i, n) {
    switch (i) {
      case "d":
        return Ft(Yt.date, e);
      case "do":
        return n.ordinalNumber(e, { unit: "date" });
      default:
        return Ht(i.length, e);
    }
  }
  validate(e, i) {
    const n = e.getFullYear(), s = Dd(n), l = e.getMonth();
    return s ? i >= 1 && i <= Uv[l] : i >= 1 && i <= Yv[l];
  }
  set(e, i, n) {
    return e.setDate(n), e.setHours(0, 0, 0, 0), e;
  }
}
class qv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 90);
    Ge(this, "subpriority", 1);
    Ge(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, i, n) {
    switch (i) {
      case "D":
      case "DD":
        return Ft(Yt.dayOfYear, e);
      case "Do":
        return n.ordinalNumber(e, { unit: "date" });
      default:
        return Ht(i.length, e);
    }
  }
  validate(e, i) {
    const n = e.getFullYear();
    return Dd(n) ? i >= 1 && i <= 366 : i >= 1 && i <= 365;
  }
  set(e, i, n) {
    return e.setMonth(0, n), e.setHours(0, 0, 0, 0), e;
  }
}
function la(t, r, e) {
  var T, B, O, b;
  const i = or(), n = (e == null ? void 0 : e.weekStartsOn) ?? ((B = (T = e == null ? void 0 : e.locale) == null ? void 0 : T.options) == null ? void 0 : B.weekStartsOn) ?? i.weekStartsOn ?? ((b = (O = i.locale) == null ? void 0 : O.options) == null ? void 0 : b.weekStartsOn) ?? 0, s = Ce(t), l = s.getDay(), A = (r % 7 + 7) % 7, Y = 7 - n, q = r < 0 || r > 6 ? r - (l + Y) % 7 : (A + Y) % 7 - (l + Y) % 7;
  return Hr(s, q);
}
class Xv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 90);
    Ge(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(e, i, n) {
    switch (i) {
      case "E":
      case "EE":
      case "EEE":
        return n.day(e, {
          width: "abbreviated",
          context: "formatting"
        }) || n.day(e, { width: "short", context: "formatting" }) || n.day(e, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return n.day(e, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return n.day(e, { width: "short", context: "formatting" }) || n.day(e, { width: "narrow", context: "formatting" });
      case "EEEE":
      default:
        return n.day(e, { width: "wide", context: "formatting" }) || n.day(e, {
          width: "abbreviated",
          context: "formatting"
        }) || n.day(e, { width: "short", context: "formatting" }) || n.day(e, { width: "narrow", context: "formatting" });
    }
  }
  validate(e, i) {
    return i >= 0 && i <= 6;
  }
  set(e, i, n, s) {
    return e = la(e, n, s), e.setHours(0, 0, 0, 0), e;
  }
}
class Qv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 90);
    Ge(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, i, n, s) {
    const l = (m) => {
      const A = Math.floor((m - 1) / 7) * 7;
      return (m + s.weekStartsOn + 6) % 7 + A;
    };
    switch (i) {
      case "e":
      case "ee":
        return Ut(Ht(i.length, e), l);
      case "eo":
        return Ut(
          n.ordinalNumber(e, {
            unit: "day"
          }),
          l
        );
      case "eee":
        return n.day(e, {
          width: "abbreviated",
          context: "formatting"
        }) || n.day(e, { width: "short", context: "formatting" }) || n.day(e, { width: "narrow", context: "formatting" });
      case "eeeee":
        return n.day(e, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return n.day(e, { width: "short", context: "formatting" }) || n.day(e, { width: "narrow", context: "formatting" });
      case "eeee":
      default:
        return n.day(e, { width: "wide", context: "formatting" }) || n.day(e, {
          width: "abbreviated",
          context: "formatting"
        }) || n.day(e, { width: "short", context: "formatting" }) || n.day(e, { width: "narrow", context: "formatting" });
    }
  }
  validate(e, i) {
    return i >= 0 && i <= 6;
  }
  set(e, i, n, s) {
    return e = la(e, n, s), e.setHours(0, 0, 0, 0), e;
  }
}
class Vv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 90);
    Ge(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(e, i, n, s) {
    const l = (m) => {
      const A = Math.floor((m - 1) / 7) * 7;
      return (m + s.weekStartsOn + 6) % 7 + A;
    };
    switch (i) {
      case "c":
      case "cc":
        return Ut(Ht(i.length, e), l);
      case "co":
        return Ut(
          n.ordinalNumber(e, {
            unit: "day"
          }),
          l
        );
      case "ccc":
        return n.day(e, {
          width: "abbreviated",
          context: "standalone"
        }) || n.day(e, { width: "short", context: "standalone" }) || n.day(e, { width: "narrow", context: "standalone" });
      case "ccccc":
        return n.day(e, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return n.day(e, { width: "short", context: "standalone" }) || n.day(e, { width: "narrow", context: "standalone" });
      case "cccc":
      default:
        return n.day(e, { width: "wide", context: "standalone" }) || n.day(e, {
          width: "abbreviated",
          context: "standalone"
        }) || n.day(e, { width: "short", context: "standalone" }) || n.day(e, { width: "narrow", context: "standalone" });
    }
  }
  validate(e, i) {
    return i >= 0 && i <= 6;
  }
  set(e, i, n, s) {
    return e = la(e, n, s), e.setHours(0, 0, 0, 0), e;
  }
}
function Nd(t, r) {
  const e = Ce(t), i = Md(e), n = r - i;
  return Hr(e, n);
}
class Kv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 90);
    Ge(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(e, i, n) {
    const s = (l) => l === 0 ? 7 : l;
    switch (i) {
      case "i":
      case "ii":
        return Ht(i.length, e);
      case "io":
        return n.ordinalNumber(e, { unit: "day" });
      case "iii":
        return Ut(
          n.day(e, {
            width: "abbreviated",
            context: "formatting"
          }) || n.day(e, {
            width: "short",
            context: "formatting"
          }) || n.day(e, {
            width: "narrow",
            context: "formatting"
          }),
          s
        );
      case "iiiii":
        return Ut(
          n.day(e, {
            width: "narrow",
            context: "formatting"
          }),
          s
        );
      case "iiiiii":
        return Ut(
          n.day(e, {
            width: "short",
            context: "formatting"
          }) || n.day(e, {
            width: "narrow",
            context: "formatting"
          }),
          s
        );
      case "iiii":
      default:
        return Ut(
          n.day(e, {
            width: "wide",
            context: "formatting"
          }) || n.day(e, {
            width: "abbreviated",
            context: "formatting"
          }) || n.day(e, {
            width: "short",
            context: "formatting"
          }) || n.day(e, {
            width: "narrow",
            context: "formatting"
          }),
          s
        );
    }
  }
  validate(e, i) {
    return i >= 1 && i <= 7;
  }
  set(e, i, n) {
    return e = Nd(e, n), e.setHours(0, 0, 0, 0), e;
  }
}
class Zv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 80);
    Ge(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(e, i, n) {
    switch (i) {
      case "a":
      case "aa":
      case "aaa":
        return n.dayPeriod(e, {
          width: "abbreviated",
          context: "formatting"
        }) || n.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return n.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return n.dayPeriod(e, {
          width: "wide",
          context: "formatting"
        }) || n.dayPeriod(e, {
          width: "abbreviated",
          context: "formatting"
        }) || n.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(e, i, n) {
    return e.setHours(Zo(n), 0, 0, 0), e;
  }
}
class Jv extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 80);
    Ge(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(e, i, n) {
    switch (i) {
      case "b":
      case "bb":
      case "bbb":
        return n.dayPeriod(e, {
          width: "abbreviated",
          context: "formatting"
        }) || n.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return n.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return n.dayPeriod(e, {
          width: "wide",
          context: "formatting"
        }) || n.dayPeriod(e, {
          width: "abbreviated",
          context: "formatting"
        }) || n.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(e, i, n) {
    return e.setHours(Zo(n), 0, 0, 0), e;
  }
}
class _v extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 80);
    Ge(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(e, i, n) {
    switch (i) {
      case "B":
      case "BB":
      case "BBB":
        return n.dayPeriod(e, {
          width: "abbreviated",
          context: "formatting"
        }) || n.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return n.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return n.dayPeriod(e, {
          width: "wide",
          context: "formatting"
        }) || n.dayPeriod(e, {
          width: "abbreviated",
          context: "formatting"
        }) || n.dayPeriod(e, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(e, i, n) {
    return e.setHours(Zo(n), 0, 0, 0), e;
  }
}
class $v extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 70);
    Ge(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(e, i, n) {
    switch (i) {
      case "h":
        return Ft(Yt.hour12h, e);
      case "ho":
        return n.ordinalNumber(e, { unit: "hour" });
      default:
        return Ht(i.length, e);
    }
  }
  validate(e, i) {
    return i >= 1 && i <= 12;
  }
  set(e, i, n) {
    const s = e.getHours() >= 12;
    return s && n < 12 ? e.setHours(n + 12, 0, 0, 0) : !s && n === 12 ? e.setHours(0, 0, 0, 0) : e.setHours(n, 0, 0, 0), e;
  }
}
class ex extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 70);
    Ge(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(e, i, n) {
    switch (i) {
      case "H":
        return Ft(Yt.hour23h, e);
      case "Ho":
        return n.ordinalNumber(e, { unit: "hour" });
      default:
        return Ht(i.length, e);
    }
  }
  validate(e, i) {
    return i >= 0 && i <= 23;
  }
  set(e, i, n) {
    return e.setHours(n, 0, 0, 0), e;
  }
}
class tx extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 70);
    Ge(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(e, i, n) {
    switch (i) {
      case "K":
        return Ft(Yt.hour11h, e);
      case "Ko":
        return n.ordinalNumber(e, { unit: "hour" });
      default:
        return Ht(i.length, e);
    }
  }
  validate(e, i) {
    return i >= 0 && i <= 11;
  }
  set(e, i, n) {
    return e.getHours() >= 12 && n < 12 ? e.setHours(n + 12, 0, 0, 0) : e.setHours(n, 0, 0, 0), e;
  }
}
class rx extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 70);
    Ge(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(e, i, n) {
    switch (i) {
      case "k":
        return Ft(Yt.hour24h, e);
      case "ko":
        return n.ordinalNumber(e, { unit: "hour" });
      default:
        return Ht(i.length, e);
    }
  }
  validate(e, i) {
    return i >= 1 && i <= 24;
  }
  set(e, i, n) {
    const s = n <= 24 ? n % 24 : n;
    return e.setHours(s, 0, 0, 0), e;
  }
}
class ix extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 60);
    Ge(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(e, i, n) {
    switch (i) {
      case "m":
        return Ft(Yt.minute, e);
      case "mo":
        return n.ordinalNumber(e, { unit: "minute" });
      default:
        return Ht(i.length, e);
    }
  }
  validate(e, i) {
    return i >= 0 && i <= 59;
  }
  set(e, i, n) {
    return e.setMinutes(n, 0, 0), e;
  }
}
class nx extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 50);
    Ge(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(e, i, n) {
    switch (i) {
      case "s":
        return Ft(Yt.second, e);
      case "so":
        return n.ordinalNumber(e, { unit: "second" });
      default:
        return Ht(i.length, e);
    }
  }
  validate(e, i) {
    return i >= 0 && i <= 59;
  }
  set(e, i, n) {
    return e.setSeconds(n, 0), e;
  }
}
class sx extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 30);
    Ge(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(e, i) {
    const n = (s) => Math.trunc(s * Math.pow(10, -i.length + 3));
    return Ut(Ht(i.length, e), n);
  }
  set(e, i, n) {
    return e.setMilliseconds(n), e;
  }
}
class ax extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 10);
    Ge(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(e, i) {
    switch (i) {
      case "X":
        return Ir(
          jr.basicOptionalMinutes,
          e
        );
      case "XX":
        return Ir(jr.basic, e);
      case "XXXX":
        return Ir(
          jr.basicOptionalSeconds,
          e
        );
      case "XXXXX":
        return Ir(
          jr.extendedOptionalSeconds,
          e
        );
      case "XXX":
      default:
        return Ir(jr.extended, e);
    }
  }
  set(e, i, n) {
    return i.timestampIsSet ? e : lt(
      e,
      e.getTime() - dr(e) - n
    );
  }
}
class ox extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 10);
    Ge(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(e, i) {
    switch (i) {
      case "x":
        return Ir(
          jr.basicOptionalMinutes,
          e
        );
      case "xx":
        return Ir(jr.basic, e);
      case "xxxx":
        return Ir(
          jr.basicOptionalSeconds,
          e
        );
      case "xxxxx":
        return Ir(
          jr.extendedOptionalSeconds,
          e
        );
      case "xxx":
      default:
        return Ir(jr.extended, e);
    }
  }
  set(e, i, n) {
    return i.timestampIsSet ? e : lt(
      e,
      e.getTime() - dr(e) - n
    );
  }
}
class lx extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 40);
    Ge(this, "incompatibleTokens", "*");
  }
  parse(e) {
    return Ed(e);
  }
  set(e, i, n) {
    return [lt(e, n * 1e3), { timestampIsSet: !0 }];
  }
}
class cx extends St {
  constructor() {
    super(...arguments);
    Ge(this, "priority", 20);
    Ge(this, "incompatibleTokens", "*");
  }
  parse(e) {
    return Ed(e);
  }
  set(e, i, n) {
    return [lt(e, n), { timestampIsSet: !0 }];
  }
}
const jd = {
  G: new Dv(),
  y: new Lv(),
  Y: new Rv(),
  R: new Nv(),
  u: new jv(),
  Q: new Iv(),
  q: new Fv(),
  M: new Bv(),
  L: new Wv(),
  w: new Hv(),
  I: new zv(),
  d: new Gv(),
  D: new qv(),
  E: new Xv(),
  e: new Qv(),
  c: new Vv(),
  i: new Kv(),
  a: new Zv(),
  b: new Jv(),
  B: new _v(),
  h: new $v(),
  H: new ex(),
  K: new tx(),
  k: new rx(),
  m: new ix(),
  s: new nx(),
  S: new sx(),
  X: new ax(),
  x: new ox(),
  t: new lx(),
  T: new cx()
}, hx = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, dx = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, ux = /^'([^]*?)'?$/, fx = /''/g, px = /\S/, gx = /[a-zA-Z]/;
function Id(t, r, e, i) {
  var v, E, M, g, C, j, D, u;
  const n = Sd(), s = (i == null ? void 0 : i.locale) ?? n.locale ?? Sn, l = (i == null ? void 0 : i.firstWeekContainsDate) ?? ((E = (v = i == null ? void 0 : i.locale) == null ? void 0 : v.options) == null ? void 0 : E.firstWeekContainsDate) ?? n.firstWeekContainsDate ?? ((g = (M = n.locale) == null ? void 0 : M.options) == null ? void 0 : g.firstWeekContainsDate) ?? 1, m = (i == null ? void 0 : i.weekStartsOn) ?? ((j = (C = i == null ? void 0 : i.locale) == null ? void 0 : C.options) == null ? void 0 : j.weekStartsOn) ?? n.weekStartsOn ?? ((u = (D = n.locale) == null ? void 0 : D.options) == null ? void 0 : u.weekStartsOn) ?? 0;
  if (r === "")
    return t === "" ? Ce(e) : lt(e, NaN);
  const A = {
    firstWeekContainsDate: l,
    weekStartsOn: m,
    locale: s
  }, Y = [new Pv()], q = r.match(dx).map((R) => {
    const K = R[0];
    if (K in zs) {
      const I = zs[K];
      return I(R, s.formatLong);
    }
    return R;
  }).join("").match(hx), T = [];
  for (let R of q) {
    !(i != null && i.useAdditionalWeekYearTokens) && bd(R) && bo(R, r, t), !(i != null && i.useAdditionalDayOfYearTokens) && yd(R) && bo(R, r, t);
    const K = R[0], I = jd[K];
    if (I) {
      const { incompatibleTokens: z } = I;
      if (Array.isArray(z)) {
        const h = T.find(
          (F) => z.includes(F.token) || F.token === K
        );
        if (h)
          throw new RangeError(
            `The format string mustn't contain \`${h.fullToken}\` and \`${R}\` at the same time`
          );
      } else if (I.incompatibleTokens === "*" && T.length > 0)
        throw new RangeError(
          `The format string mustn't contain \`${R}\` and any other token at the same time`
        );
      T.push({ token: K, fullToken: R });
      const k = I.run(
        t,
        R,
        s.match,
        A
      );
      if (!k)
        return lt(e, NaN);
      Y.push(k.setter), t = k.rest;
    } else {
      if (K.match(gx))
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + K + "`"
        );
      if (R === "''" ? R = "'" : K === "'" && (R = mx(R)), t.indexOf(R) === 0)
        t = t.slice(R.length);
      else
        return lt(e, NaN);
    }
  }
  if (t.length > 0 && px.test(t))
    return lt(e, NaN);
  const B = Y.map((R) => R.priority).sort((R, K) => K - R).filter((R, K, I) => I.indexOf(R) === K).map(
    (R) => Y.filter((K) => K.priority === R).sort((K, I) => I.subPriority - K.subPriority)
  ).map((R) => R[0]);
  let O = Ce(e);
  if (isNaN(O.getTime()))
    return lt(e, NaN);
  const b = {};
  for (const R of B) {
    if (!R.validate(O, A))
      return lt(e, NaN);
    const K = R.set(O, b, A);
    Array.isArray(K) ? (O = K[0], Object.assign(b, K[1])) : O = K;
  }
  return lt(e, O);
}
function mx(t) {
  return t.match(ux)[1].replace(fx, "'");
}
function yx(t, r, e) {
  return Zr(Id(t, r, /* @__PURE__ */ new Date(), e));
}
function bx(t) {
  return Ce(t).getDay() === 1;
}
function vx(t) {
  return +Ce(t) < Date.now();
}
function vo(t) {
  const r = Ce(t);
  return r.setMinutes(0, 0, 0), r;
}
function Fd(t, r) {
  const e = vo(t), i = vo(r);
  return +e == +i;
}
function Jo(t, r, e) {
  const i = ir(t, e), n = ir(r, e);
  return +i == +n;
}
function Bd(t, r) {
  return Jo(t, r, { weekStartsOn: 1 });
}
function xx(t, r) {
  const e = ui(t), i = ui(r);
  return +e == +i;
}
function Wd(t, r) {
  const e = Ws(t), i = Ws(r);
  return +e == +i;
}
function Hd(t, r) {
  const e = Ce(t), i = Ce(r);
  return e.getFullYear() === i.getFullYear() && e.getMonth() === i.getMonth();
}
function zd(t, r) {
  const e = Ci(t), i = Ci(r);
  return +e == +i;
}
function xo(t) {
  const r = Ce(t);
  return r.setMilliseconds(0), r;
}
function Yd(t, r) {
  const e = xo(t), i = xo(r);
  return +e == +i;
}
function Ud(t, r) {
  const e = Ce(t), i = Ce(r);
  return e.getFullYear() === i.getFullYear();
}
function wx(t) {
  return Fd(t, ur(t));
}
function kx(t) {
  return Bd(t, ur(t));
}
function Cx(t) {
  return Wd(t, ur(t));
}
function Sx(t) {
  return Hd(t, ur(t));
}
function Mx(t) {
  return zd(t, ur(t));
}
function Tx(t) {
  return Yd(t, ur(t));
}
function Ox(t, r) {
  return Jo(t, ur(t), r);
}
function Ax(t) {
  return Ud(t, ur(t));
}
function Ex(t) {
  return Ce(t).getDay() === 4;
}
function Px(t) {
  return cs(t, ur(t));
}
function Dx(t) {
  return cs(t, Hr(ur(t), 1));
}
function Lx(t) {
  return Ce(t).getDay() === 2;
}
function Rx(t) {
  return Ce(t).getDay() === 3;
}
function Nx(t, r) {
  const e = +Ce(t), [i, n] = [
    +Ce(r.start),
    +Ce(r.end)
  ].sort((s, l) => s - l);
  return e >= i && e <= n;
}
function ca(t, r) {
  return Hr(t, -r);
}
function jx(t) {
  return cs(t, ca(ur(t), 1));
}
function Ix(t) {
  const r = Ce(t), e = r.getFullYear(), i = 9 + Math.floor(e / 10) * 10;
  return r.setFullYear(i + 1, 0, 0), r.setHours(0, 0, 0, 0), r;
}
function Gd(t, r) {
  var m, A, Y, q;
  const e = or(), i = (r == null ? void 0 : r.weekStartsOn) ?? ((A = (m = r == null ? void 0 : r.locale) == null ? void 0 : m.options) == null ? void 0 : A.weekStartsOn) ?? e.weekStartsOn ?? ((q = (Y = e.locale) == null ? void 0 : Y.options) == null ? void 0 : q.weekStartsOn) ?? 0, n = Ce(t), s = n.getDay(), l = (s < i ? -7 : 0) + 6 - (s - i);
  return n.setHours(0, 0, 0, 0), n.setDate(n.getDate() + l), n;
}
function Fx(t) {
  return Gd(t, { weekStartsOn: 1 });
}
function Bx(t) {
  const r = di(t), e = lt(t, 0);
  e.setFullYear(r + 1, 0, 4), e.setHours(0, 0, 0, 0);
  const i = Ar(e);
  return i.setDate(i.getDate() - 1), i;
}
function Wx(t) {
  const r = Ce(t), e = r.getMonth(), i = e - e % 3 + 3;
  return r.setMonth(i, 0), r.setHours(0, 0, 0, 0), r;
}
function Hx(t) {
  const r = Ce(t), e = r.getFullYear();
  return r.setFullYear(e + 1, 0, 0), r.setHours(0, 0, 0, 0), r;
}
const zx = /(\w)\1*|''|'(''|[^'])+('|$)|./g, Yx = /^'([^]*?)'?$/, Ux = /''/g, Gx = /[a-zA-Z]/;
function qx(t, r) {
  const e = Ce(t);
  if (!Zr(e))
    throw new RangeError("Invalid time value");
  const i = r.match(zx);
  return i ? i.map((s) => {
    if (s === "''")
      return "'";
    const l = s[0];
    if (l === "'")
      return Xx(s);
    const m = Pr[l];
    if (m)
      return m(e, s);
    if (l.match(Gx))
      throw new RangeError(
        "Format string contains an unescaped latin alphabet character `" + l + "`"
      );
    return s;
  }).join("") : "";
}
function Xx(t) {
  const r = t.match(Yx);
  return r ? r[1].replace(Ux, "'") : t;
}
function Qx({
  years: t,
  months: r,
  weeks: e,
  days: i,
  hours: n,
  minutes: s,
  seconds: l
}) {
  let m = 0;
  t && (m += t * Rs), r && (m += r * (Rs / 12)), e && (m += e * 7), i && (m += i);
  let A = m * 24 * 60 * 60;
  return n && (A += n * 60 * 60), s && (A += s * 60), l && (A += l), Math.trunc(A * 1e3);
}
function Vx(t) {
  const r = t / Ii;
  return Math.trunc(r);
}
function Kx(t) {
  const r = t / Kr;
  return Math.trunc(r);
}
function Zx(t) {
  const r = t / Fo;
  return Math.trunc(r);
}
function Jx(t) {
  const r = t / Vh;
  return Math.trunc(r);
}
function _x(t) {
  return Math.trunc(t * Kr);
}
function $x(t) {
  return Math.trunc(t * Bo);
}
function e1(t) {
  const r = t / Kh;
  return Math.trunc(r);
}
function t1(t) {
  const r = t / Zh;
  return Math.trunc(r);
}
function mi(t, r) {
  let e = r - oa(t);
  return e <= 0 && (e += 7), Hr(t, e);
}
function r1(t) {
  return mi(t, 5);
}
function i1(t) {
  return mi(t, 1);
}
function n1(t) {
  return mi(t, 6);
}
function s1(t) {
  return mi(t, 0);
}
function a1(t) {
  return mi(t, 4);
}
function o1(t) {
  return mi(t, 2);
}
function l1(t) {
  return mi(t, 3);
}
function c1(t, r) {
  const e = (r == null ? void 0 : r.additionalDigits) ?? 2, i = f1(t);
  let n;
  if (i.date) {
    const A = p1(i.date, e);
    n = g1(A.restDateString, A.year);
  }
  if (!n || isNaN(n.getTime()))
    return /* @__PURE__ */ new Date(NaN);
  const s = n.getTime();
  let l = 0, m;
  if (i.time && (l = m1(i.time), isNaN(l)))
    return /* @__PURE__ */ new Date(NaN);
  if (i.timezone) {
    if (m = y1(i.timezone), isNaN(m))
      return /* @__PURE__ */ new Date(NaN);
  } else {
    const A = new Date(s + l), Y = /* @__PURE__ */ new Date(0);
    return Y.setFullYear(
      A.getUTCFullYear(),
      A.getUTCMonth(),
      A.getUTCDate()
    ), Y.setHours(
      A.getUTCHours(),
      A.getUTCMinutes(),
      A.getUTCSeconds(),
      A.getUTCMilliseconds()
    ), Y;
  }
  return new Date(s + l + m);
}
const ks = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
}, h1 = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, d1 = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, u1 = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function f1(t) {
  const r = {}, e = t.split(ks.dateTimeDelimiter);
  let i;
  if (e.length > 2)
    return r;
  if (/:/.test(e[0]) ? i = e[0] : (r.date = e[0], i = e[1], ks.timeZoneDelimiter.test(r.date) && (r.date = t.split(ks.timeZoneDelimiter)[0], i = t.substr(
    r.date.length,
    t.length
  ))), i) {
    const n = ks.timezone.exec(i);
    n ? (r.time = i.replace(n[1], ""), r.timezone = n[1]) : r.time = i;
  }
  return r;
}
function p1(t, r) {
  const e = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + r) + "})|(\\d{2}|[+-]\\d{" + (2 + r) + "})$)"
  ), i = t.match(e);
  if (!i)
    return { year: NaN, restDateString: "" };
  const n = i[1] ? parseInt(i[1]) : null, s = i[2] ? parseInt(i[2]) : null;
  return {
    year: s === null ? n : s * 100,
    restDateString: t.slice((i[1] || i[2]).length)
  };
}
function g1(t, r) {
  if (r === null)
    return /* @__PURE__ */ new Date(NaN);
  const e = t.match(h1);
  if (!e)
    return /* @__PURE__ */ new Date(NaN);
  const i = !!e[4], n = Rn(e[1]), s = Rn(e[2]) - 1, l = Rn(e[3]), m = Rn(e[4]), A = Rn(e[5]) - 1;
  if (i)
    return k1(r, m, A) ? b1(r, m, A) : /* @__PURE__ */ new Date(NaN);
  {
    const Y = /* @__PURE__ */ new Date(0);
    return !x1(r, s, l) || !w1(r, n) ? /* @__PURE__ */ new Date(NaN) : (Y.setUTCFullYear(r, s, Math.max(n, l)), Y);
  }
}
function Rn(t) {
  return t ? parseInt(t) : 1;
}
function m1(t) {
  const r = t.match(d1);
  if (!r)
    return NaN;
  const e = Qa(r[1]), i = Qa(r[2]), n = Qa(r[3]);
  return C1(e, i, n) ? e * Ii + i * Kr + n * 1e3 : NaN;
}
function Qa(t) {
  return t && parseFloat(t.replace(",", ".")) || 0;
}
function y1(t) {
  if (t === "Z")
    return 0;
  const r = t.match(u1);
  if (!r)
    return 0;
  const e = r[1] === "+" ? -1 : 1, i = parseInt(r[2]), n = r[3] && parseInt(r[3]) || 0;
  return S1(i, n) ? e * (i * Ii + n * Kr) : NaN;
}
function b1(t, r, e) {
  const i = /* @__PURE__ */ new Date(0);
  i.setUTCFullYear(t, 0, 4);
  const n = i.getUTCDay() || 7, s = (r - 1) * 7 + e + 1 - n;
  return i.setUTCDate(i.getUTCDate() + s), i;
}
const v1 = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function qd(t) {
  return t % 400 === 0 || t % 4 === 0 && t % 100 !== 0;
}
function x1(t, r, e) {
  return r >= 0 && r <= 11 && e >= 1 && e <= (v1[r] || (qd(t) ? 29 : 28));
}
function w1(t, r) {
  return r >= 1 && r <= (qd(t) ? 366 : 365);
}
function k1(t, r, e) {
  return r >= 1 && r <= 53 && e >= 0 && e <= 6;
}
function C1(t, r, e) {
  return t === 24 ? r === 0 && e === 0 : e >= 0 && e < 60 && r >= 0 && r < 60 && t >= 0 && t < 25;
}
function S1(t, r) {
  return r >= 0 && r <= 59;
}
function M1(t) {
  const r = t.match(
    /(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|(.)(\d{2}):?(\d{2})?)?/
  );
  return r ? new Date(
    Date.UTC(
      +r[1],
      +r[2] - 1,
      +r[3],
      +r[4] - (+r[9] || 0) * (r[8] == "-" ? -1 : 1),
      +r[5] - (+r[10] || 0) * (r[8] == "-" ? -1 : 1),
      +r[6],
      +((r[7] || "0") + "00").substring(0, 3)
    )
  ) : /* @__PURE__ */ new Date(NaN);
}
function yi(t, r) {
  let e = oa(t) - r;
  return e <= 0 && (e += 7), ca(t, e);
}
function T1(t) {
  return yi(t, 5);
}
function O1(t) {
  return yi(t, 1);
}
function A1(t) {
  return yi(t, 6);
}
function E1(t) {
  return yi(t, 0);
}
function P1(t) {
  return yi(t, 4);
}
function D1(t) {
  return yi(t, 2);
}
function L1(t) {
  return yi(t, 3);
}
function R1(t) {
  return Math.trunc(t * Kh);
}
function N1(t) {
  const r = t / Jh;
  return Math.trunc(r);
}
function j1(t, r) {
  const e = (r == null ? void 0 : r.nearestTo) ?? 1;
  if (e < 1 || e > 12)
    return lt(t, NaN);
  const i = Ce(t), n = i.getMinutes() / 60, s = i.getSeconds() / 60 / 60, l = i.getMilliseconds() / 1e3 / 60 / 60, m = i.getHours() + n + s + l, A = (r == null ? void 0 : r.roundingMethod) ?? "round", q = gi(A)(m / e) * e, T = lt(t, i);
  return T.setHours(q, 0, 0, 0), T;
}
function I1(t, r) {
  const e = (r == null ? void 0 : r.nearestTo) ?? 1;
  if (e < 1 || e > 30)
    return lt(t, NaN);
  const i = Ce(t), n = i.getSeconds() / 60, s = i.getMilliseconds() / 1e3 / 60, l = i.getMinutes() + n + s, m = (r == null ? void 0 : r.roundingMethod) ?? "round", Y = gi(m)(l / e) * e, q = lt(t, i);
  return q.setMinutes(Y, 0, 0), q;
}
function F1(t) {
  const r = t / ta;
  return Math.trunc(r);
}
function B1(t) {
  return t * Fo;
}
function W1(t) {
  const r = t / Bo;
  return Math.trunc(r);
}
function _o(t, r) {
  const e = Ce(t), i = e.getFullYear(), n = e.getDate(), s = lt(t, 0);
  s.setFullYear(i, r, 15), s.setHours(0, 0, 0, 0);
  const l = kd(s);
  return e.setMonth(r, Math.min(n, l)), e;
}
function H1(t, r) {
  let e = Ce(t);
  return isNaN(+e) ? lt(t, NaN) : (r.year != null && e.setFullYear(r.year), r.month != null && (e = _o(e, r.month)), r.date != null && e.setDate(r.date), r.hours != null && e.setHours(r.hours), r.minutes != null && e.setMinutes(r.minutes), r.seconds != null && e.setSeconds(r.seconds), r.milliseconds != null && e.setMilliseconds(r.milliseconds), e);
}
function z1(t, r) {
  const e = Ce(t);
  return e.setDate(r), e;
}
function Y1(t, r) {
  const e = Ce(t);
  return e.setMonth(0), e.setDate(r), e;
}
function U1(t) {
  const r = {}, e = or();
  for (const i in e)
    Object.prototype.hasOwnProperty.call(e, i) && (r[i] = e[i]);
  for (const i in t)
    Object.prototype.hasOwnProperty.call(t, i) && (t[i] === void 0 ? delete r[i] : r[i] = t[i]);
  wy(r);
}
function G1(t, r) {
  const e = Ce(t);
  return e.setHours(r), e;
}
function q1(t, r) {
  const e = Ce(t);
  return e.setMilliseconds(r), e;
}
function X1(t, r) {
  const e = Ce(t);
  return e.setMinutes(r), e;
}
function Q1(t, r) {
  const e = Ce(t), i = Math.trunc(e.getMonth() / 3) + 1, n = r - i;
  return _o(e, e.getMonth() + n * 3);
}
function V1(t, r) {
  const e = Ce(t);
  return e.setSeconds(r), e;
}
function K1(t, r, e) {
  var A, Y, q, T;
  const i = or(), n = (e == null ? void 0 : e.firstWeekContainsDate) ?? ((Y = (A = e == null ? void 0 : e.locale) == null ? void 0 : A.options) == null ? void 0 : Y.firstWeekContainsDate) ?? i.firstWeekContainsDate ?? ((T = (q = i.locale) == null ? void 0 : q.options) == null ? void 0 : T.firstWeekContainsDate) ?? 1;
  let s = Ce(t);
  const l = Br(s, Hs(s, e)), m = lt(t, 0);
  return m.setFullYear(r, 0, n), m.setHours(0, 0, 0, 0), s = Hs(m, e), s.setDate(s.getDate() + l), s;
}
function Z1(t, r) {
  const e = Ce(t);
  return isNaN(+e) ? lt(t, NaN) : (e.setFullYear(r), e);
}
function J1(t) {
  const r = Ce(t), e = r.getFullYear(), i = Math.floor(e / 10) * 10;
  return r.setFullYear(i, 0, 1), r.setHours(0, 0, 0, 0), r;
}
function _1() {
  return bn(Date.now());
}
function $1() {
  const t = /* @__PURE__ */ new Date(), r = t.getFullYear(), e = t.getMonth(), i = t.getDate(), n = /* @__PURE__ */ new Date(0);
  return n.setFullYear(r, e, i + 1), n.setHours(0, 0, 0, 0), n;
}
function ew() {
  const t = /* @__PURE__ */ new Date(), r = t.getFullYear(), e = t.getMonth(), i = t.getDate(), n = /* @__PURE__ */ new Date(0);
  return n.setFullYear(r, e, i - 1), n.setHours(0, 0, 0, 0), n;
}
function Xd(t, r) {
  return as(t, -r);
}
function tw(t, r) {
  const {
    years: e = 0,
    months: i = 0,
    weeks: n = 0,
    days: s = 0,
    hours: l = 0,
    minutes: m = 0,
    seconds: A = 0
  } = r, Y = Xd(t, i + e * 12), q = ca(Y, s + n * 7), T = m + l * 60, O = (A + T * 60) * 1e3;
  return lt(t, q.getTime() - O);
}
function rw(t, r) {
  return qh(t, -r);
}
function iw(t, r) {
  return Ho(t, -r);
}
function nw(t, r) {
  return os(t, -r);
}
function sw(t, r) {
  return zo(t, -r);
}
function aw(t, r) {
  return Yo(t, -r);
}
function ow(t, r) {
  return id(t, -r);
}
function lw(t, r) {
  return ra(t, -r);
}
function cw(t, r) {
  return nd(t, -r);
}
function hw(t) {
  return Math.trunc(t * Xh);
}
function dw(t) {
  return Math.trunc(t * Rs);
}
function uw(t) {
  return Math.trunc(t * Zh);
}
function fw(t) {
  return Math.trunc(t * Jh);
}
const pw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: Zi,
  addBusinessDays: qh,
  addDays: Hr,
  addHours: Ho,
  addISOWeekYears: rd,
  addMilliseconds: os,
  addMinutes: zo,
  addMonths: as,
  addQuarters: Yo,
  addSeconds: id,
  addWeeks: ra,
  addYears: nd,
  areIntervalsOverlapping: ky,
  clamp: Cy,
  closestIndexTo: Sy,
  closestTo: My,
  compareAsc: Wr,
  compareDesc: Ty,
  constructFrom: lt,
  constructNow: ur,
  daysToWeeks: Oy,
  differenceInBusinessDays: Ay,
  differenceInCalendarDays: Br,
  differenceInCalendarISOWeekYears: ld,
  differenceInCalendarISOWeeks: Ey,
  differenceInCalendarMonths: js,
  differenceInCalendarQuarters: Os,
  differenceInCalendarWeeks: Is,
  differenceInCalendarYears: In,
  differenceInDays: Uo,
  differenceInHours: Fs,
  differenceInISOWeekYears: Py,
  differenceInMilliseconds: ia,
  differenceInMinutes: Bs,
  differenceInMonths: na,
  differenceInQuarters: Dy,
  differenceInSeconds: $i,
  differenceInWeeks: Ly,
  differenceInYears: dd,
  eachDayOfInterval: ud,
  eachHourOfInterval: Ry,
  eachMinuteOfInterval: Ny,
  eachMonthOfInterval: jy,
  eachQuarterOfInterval: Iy,
  eachWeekOfInterval: Fy,
  eachWeekendOfInterval: Xo,
  eachWeekendOfMonth: By,
  eachWeekendOfYear: Wy,
  eachYearOfInterval: Hy,
  endOfDay: Go,
  endOfDecade: zy,
  endOfHour: Yy,
  endOfISOWeek: Uy,
  endOfISOWeekYear: Gy,
  endOfMinute: qy,
  endOfMonth: qo,
  endOfQuarter: Xy,
  endOfSecond: Qy,
  endOfToday: Vy,
  endOfTomorrow: Ky,
  endOfWeek: pd,
  endOfYear: fd,
  endOfYesterday: Zy,
  format: hr,
  formatDate: hr,
  formatDistance: vd,
  formatDistanceStrict: xd,
  formatDistanceToNow: Hb,
  formatDistanceToNowStrict: zb,
  formatDuration: Ub,
  formatISO: Gb,
  formatISO9075: qb,
  formatISODuration: Xb,
  formatRFC3339: Qb,
  formatRFC7231: Zb,
  formatRelative: Jb,
  formatters: yo,
  fromUnixTime: _b,
  getDate: wd,
  getDay: oa,
  getDayOfYear: gd,
  getDaysInMonth: kd,
  getDaysInYear: $b,
  getDecade: ev,
  getDefaultOptions: Sd,
  getHours: tv,
  getISODay: Md,
  getISOWeek: Vo,
  getISOWeekYear: di,
  getISOWeeksInYear: rv,
  getMilliseconds: iv,
  getMinutes: nv,
  getMonth: sv,
  getOverlappingDaysInIntervals: av,
  getQuarter: mo,
  getSeconds: ov,
  getTime: lv,
  getUnixTime: cv,
  getWeek: Ko,
  getWeekOfMonth: hv,
  getWeekYear: aa,
  getWeeksInMonth: dv,
  getYear: uv,
  hoursToMilliseconds: fv,
  hoursToMinutes: pv,
  hoursToSeconds: gv,
  interval: mv,
  intervalToDuration: yv,
  intlFormat: bv,
  intlFormatDistance: xv,
  isAfter: wv,
  isBefore: kv,
  isDate: od,
  isEqual: Cv,
  isExists: Sv,
  isFirstDayOfMonth: Mv,
  isFriday: Tv,
  isFuture: Ov,
  isLastDayOfMonth: hd,
  isLeapYear: Cd,
  isMatch: yx,
  isMonday: bx,
  isPast: vx,
  isSameDay: cs,
  isSameHour: Fd,
  isSameISOWeek: Bd,
  isSameISOWeekYear: xx,
  isSameMinute: Wd,
  isSameMonth: Hd,
  isSameQuarter: zd,
  isSameSecond: Yd,
  isSameWeek: Jo,
  isSameYear: Ud,
  isSaturday: Uh,
  isSunday: Gh,
  isThisHour: wx,
  isThisISOWeek: kx,
  isThisMinute: Cx,
  isThisMonth: Sx,
  isThisQuarter: Mx,
  isThisSecond: Tx,
  isThisWeek: Ox,
  isThisYear: Ax,
  isThursday: Ex,
  isToday: Px,
  isTomorrow: Dx,
  isTuesday: Lx,
  isValid: Zr,
  isWednesday: Rx,
  isWeekend: _i,
  isWithinInterval: Nx,
  isYesterday: jx,
  lastDayOfDecade: Ix,
  lastDayOfISOWeek: Fx,
  lastDayOfISOWeekYear: Bx,
  lastDayOfMonth: Td,
  lastDayOfQuarter: Wx,
  lastDayOfWeek: Gd,
  lastDayOfYear: Hx,
  lightFormat: qx,
  lightFormatters: Pr,
  longFormatters: zs,
  max: sd,
  milliseconds: Qx,
  millisecondsToHours: Vx,
  millisecondsToMinutes: Kx,
  millisecondsToSeconds: Zx,
  min: ad,
  minutesToHours: Jx,
  minutesToMilliseconds: _x,
  minutesToSeconds: $x,
  monthsToQuarters: e1,
  monthsToYears: t1,
  nextDay: mi,
  nextFriday: r1,
  nextMonday: i1,
  nextSaturday: n1,
  nextSunday: s1,
  nextThursday: a1,
  nextTuesday: o1,
  nextWednesday: l1,
  parse: Id,
  parseISO: c1,
  parseJSON: M1,
  parsers: jd,
  previousDay: yi,
  previousFriday: T1,
  previousMonday: O1,
  previousSaturday: A1,
  previousSunday: E1,
  previousThursday: P1,
  previousTuesday: D1,
  previousWednesday: L1,
  quartersToMonths: R1,
  quartersToYears: N1,
  roundToNearestHours: j1,
  roundToNearestMinutes: I1,
  secondsToHours: F1,
  secondsToMilliseconds: B1,
  secondsToMinutes: W1,
  set: H1,
  setDate: z1,
  setDay: la,
  setDayOfYear: Y1,
  setDefaultOptions: U1,
  setHours: G1,
  setISODay: Nd,
  setISOWeek: Rd,
  setISOWeekYear: td,
  setMilliseconds: q1,
  setMinutes: X1,
  setMonth: _o,
  setQuarter: Q1,
  setSeconds: V1,
  setWeek: Ld,
  setWeekYear: K1,
  setYear: Z1,
  startOfDay: bn,
  startOfDecade: J1,
  startOfHour: vo,
  startOfISOWeek: Ar,
  startOfISOWeekYear: ui,
  startOfMinute: Ws,
  startOfMonth: sa,
  startOfQuarter: Ci,
  startOfSecond: xo,
  startOfToday: _1,
  startOfTomorrow: $1,
  startOfWeek: ir,
  startOfWeekYear: Hs,
  startOfYear: Qo,
  startOfYesterday: ew,
  sub: tw,
  subBusinessDays: rw,
  subDays: ca,
  subHours: iw,
  subISOWeekYears: cd,
  subMilliseconds: nw,
  subMinutes: sw,
  subMonths: Xd,
  subQuarters: aw,
  subSeconds: ow,
  subWeeks: lw,
  subYears: cw,
  toDate: Ce,
  transpose: Od,
  weeksToDays: hw,
  yearsToDays: dw,
  yearsToMonths: uw,
  yearsToQuarters: fw
}, Symbol.toStringTag, { value: "Module" })), gw = (t) => hr(new Date(t), "MMM dd, yyyy"), jn = (t) => hr(new Date(1, t), "MMM"), mw = (t) => hr(new Date(t), "MMM dd, yyyy"), yw = ({
  contestDate: t,
  contestName: r,
  contestRating: e,
  problemsSolved: i,
  totalProblems: n,
  ratingDirection: s,
  ranking: l
}) => /* @__PURE__ */ se.jsxs("div", { className: "flex gap-4", children: [
  /* @__PURE__ */ se.jsxs("div", { children: [
    /* @__PURE__ */ se.jsx("p", { className: "text-xs text-dark-label-3 font-medium", children: "Contest Rating" }),
    /* @__PURE__ */ se.jsxs("p", { className: "flex items-center gap-1 text-dark-label-1 text-xl md:text-2xl", children: [
      Math.round(e).toLocaleString("en-US"),
      /* @__PURE__ */ se.jsx(um, { className: "text-xl md:text-2xl", direction: s })
    ] })
  ] }),
  /* @__PURE__ */ se.jsxs("div", { children: [
    /* @__PURE__ */ se.jsx("p", { className: "text-xs text-dark-label-3 font-medium", children: gw(t * 1e3) }),
    /* @__PURE__ */ se.jsx("p", { className: "text-xs leading-[22px] text-dark-label-1", children: r })
  ] }),
  /* @__PURE__ */ se.jsxs("div", { children: [
    /* @__PURE__ */ se.jsx("p", { className: "text-xs text-dark-label-3 font-medium", children: "Rank" }),
    /* @__PURE__ */ se.jsx("p", { className: "text-xs leading-[22px] text-dark-label-1", children: l })
  ] }),
  /* @__PURE__ */ se.jsxs("div", { children: [
    /* @__PURE__ */ se.jsx("p", { className: "text-xs text-dark-label-3 font-medium", children: "Solved" }),
    /* @__PURE__ */ se.jsxs("p", { className: "text-xs leading-[22px] text-dark-label-1", children: [
      i,
      "/",
      n
    ] })
  ] })
] }), bw = ({
  userContestRankingHistory: t,
  startYear: r,
  currentYear: e
}) => {
  const [i, n] = At(
    t.length - 1
  ), [s, l] = At(!1), m = Ri(() => (t || []).filter((Y) => Y.attended).map((Y) => Math.round(Y.rating)), [t]);
  return {
    options: Ri(() => ({
      title: {
        text: ""
      },
      chart: {
        backgroundColor: "rgb(40 40 40 / 1)",
        height: "100vh",
        marginLeft: 10,
        renderTo: "container"
      },
      accessibility: {
        enabled: !1
      },
      credits: {
        enabled: !1
      },
      legend: {
        enabled: !1
      },
      series: [
        {
          name: "",
          showInLegend: "",
          legendIndex: 0,
          marker: {
            enabled: !1
          },
          data: m,
          color: "rgb(255, 161, 22)"
        }
      ],
      xAxis: {
        title: {
          text: ""
        },
        tickInterval: 0,
        showFirstLabel: !0,
        showLastLabel: !0,
        lineColor: "none",
        tickColor: "none",
        minorGridLineColor: "none",
        labels: {
          formatter: function() {
            return this.isFirst ? r : this.isLast ? e : "";
          },
          color: "white"
        }
      },
      yAxis: {
        tickInterval: 0,
        tickPixelInterval: 0,
        labels: {
          formatter: function() {
            return this.value + " %";
          }
        },
        title: "",
        accessibility: {
          enabled: !1
        },
        showFirstLabel: !1,
        showLastLabel: !0,
        gridLineColor: "none"
      },
      plotOptions: {
        series: {
          point: {
            events: {
              mouseOver: (q) => {
                n(q.target.index), l(!0);
              },
              mouseOut: () => {
                l(!1);
              }
            }
          }
        }
      },
      tooltip: {
        enabled: !1
      }
    }), [t, r, e]),
    currentHoveredIndex: i,
    isHovered: s
  };
}, vw = ({
  userContestRankingHistory: t,
  startYear: r,
  currentYear: e,
  userContestDetails: i
}) => {
  const { isHovered: n, currentHoveredIndex: s, options: l } = bw({
    userContestRankingHistory: t,
    startYear: r,
    currentYear: e
  }), {
    contest: m,
    problemsSolved: A,
    totalProblems: Y,
    trendDirection: q,
    rating: T,
    ranking: B
  } = t[s] || {};
  return /* @__PURE__ */ se.jsxs(se.Fragment, { children: [
    /* @__PURE__ */ se.jsx(Et, { when: !n, children: /* @__PURE__ */ se.jsx(vm, { userContestDetails: i }) }),
    /* @__PURE__ */ se.jsx(Et, { when: n, children: /* @__PURE__ */ se.jsx(
      yw,
      {
        contestDate: (m == null ? void 0 : m.startTime) || 0,
        contestName: (m == null ? void 0 : m.title) || "",
        contestRating: T,
        problemsSolved: A,
        totalProblems: Y,
        ratingDirection: q,
        ranking: B
      }
    ) }),
    /* @__PURE__ */ se.jsx(uh, { highcharts: hh, options: l })
  ] });
}, xw = () => /* @__PURE__ */ se.jsxs("div", { className: "w-full flex flex-col gap-6 rounded shadow animate-pulse border-[#ffffff14]", children: [
  /* @__PURE__ */ se.jsxs("div", { className: "flex justify-between w-full", children: [
    /* @__PURE__ */ se.jsxs("div", { className: "flex flex-col gap-2", children: [
      /* @__PURE__ */ se.jsx("div", { className: "w-16 h-4 rounded-full bg-[#ffffff14]" }),
      /* @__PURE__ */ se.jsx("div", { className: "w-16 h-4 rounded-full bg-[#ffffff14]" })
    ] }),
    /* @__PURE__ */ se.jsxs("div", { className: "flex flex-col gap-2", children: [
      /* @__PURE__ */ se.jsx("div", { className: "w-16 h-4 rounded-full bg-[#ffffff14]" }),
      /* @__PURE__ */ se.jsx("div", { className: "w-16 h-4 rounded-full bg-[#ffffff14]" })
    ] }),
    /* @__PURE__ */ se.jsxs("div", { className: "flex flex-col gap-2", children: [
      /* @__PURE__ */ se.jsx("div", { className: "w-16 h-4 rounded-full bg-[#ffffff14]" }),
      /* @__PURE__ */ se.jsx("div", { className: "w-16 h-4 rounded-full bg-[#ffffff14]" })
    ] }),
    /* @__PURE__ */ se.jsxs("div", { className: "flex flex-col gap-2", children: [
      /* @__PURE__ */ se.jsx("div", { className: "w-16 h-4 rounded-full bg-[#ffffff14]" }),
      /* @__PURE__ */ se.jsx("div", { className: "w-16 h-4 rounded-full bg-[#ffffff14]" })
    ] })
  ] }),
  /* @__PURE__ */ se.jsx("div", { className: "w-full h-40 bg-[#ffffff14] rounded" })
] }), ww = async (t) => {
  const { data: r } = await ss.get(
    `/${t}/rating`
  );
  return r.userContestRankingHistory = r.userContestRankingHistory.filter(
    (e) => e.attended
  ), r;
}, kw = async (t) => {
  const { data: r } = await ss.get(
    `/${t}/histogram`
  );
  return r;
}, Cw = async (t) => {
  const { data: r } = await ss.get(
    `/${t}/solved`
  );
  return r;
}, Sw = async (t, r) => {
  const { data: e } = await ss.get(
    `/${t}/calendar`,
    {
      params: {
        year: r
      }
    }
  );
  return e;
}, Mw = async (t) => {
  const { data: r } = await ss.get(
    `/${t}/badges`
  );
  return r;
}, Qd = (t) => rs({
  queryKey: ["contestRatingGraph", t],
  queryFn: () => ww(t),
  enabled: !!t
}), Tw = (t) => {
  const {
    data: r,
    isLoading: e,
    isError: i
  } = Qd(t), { rating: n, topPercentage: s } = (r == null ? void 0 : r.userContestRanking) || {
    rating: 0,
    topPercentage: 0
  }, { data: l, isLoading: m, isError: A } = rs({
    queryKey: ["histogramData"],
    queryFn: async () => {
      const { data: T } = await kw(t);
      return T;
    },
    enabled: !!r
  }), { contestRatingHistogram: Y } = l || {};
  return {
    histogramData: Ri(() => Y == null ? void 0 : Y.map(({ userCount: T, ratingStart: B, ratingEnd: O }) => {
      const b = { y: T };
      return n >= B && n < O && (b.color = "rgb(255, 161, 22)"), b;
    }), [Y, n]),
    isLoading: e || m,
    isError: i || A,
    topPercentage: s,
    contestRatingData: Y
  };
}, Ow = (t) => rs({
  queryKey: ["problemsSolvedStats", t],
  queryFn: () => Cw(t),
  enabled: !!t
}), As = {
  0: 31,
  1: 28,
  2: 31,
  3: 30,
  4: 31,
  5: 30,
  6: 31,
  7: 31,
  8: 30,
  9: 31,
  10: 30,
  11: 31
}, Aw = {
  name: "Current"
  // value: new Date().getFullYear().toString(),
}, Ew = (t, r) => rs({
  queryKey: ["submissionsCalendar", t, r],
  queryFn: () => Sw(t, r),
  enabled: !!t
}), Pw = (t) => t < 1 ? 0 : t < 3 ? 1 : t < 5 ? 2 : t < 8 ? 3 : 4, Dw = (t, r) => {
  const e = (/* @__PURE__ */ new Date()).getFullYear(), i = (/* @__PURE__ */ new Date()).getMonth(), n = (/* @__PURE__ */ new Date()).getDate(), [s, l] = At(0);
  return {
    submissionCalendarData: Ri(() => {
      const A = JSON.parse(t || "{}");
      let Y = 0;
      const q = Object.keys(A).map((O) => (Y += A[O], {
        date: hr(new Date(Number(O) * 1e3), "yyyy-MM-dd"),
        count: A[O],
        level: Pw(A[O]),
        key: Number(O),
        day: new Date(Number(O) * 1e3).getDate(),
        month: new Date(Number(O) * 1e3).getMonth(),
        year: new Date(Number(O) * 1e3).getFullYear(),
        monthname: hr(new Date(Number(O) * 1e3), "MMM")
      }));
      if (q.length === 0) {
        let O = i, b = e - 1, v = (/* @__PURE__ */ new Date()).getDate();
        const E = n !== As[O] ? 13 : 12;
        for (let M = 1; M <= E; M++) {
          const g = b === e && O === i ? n : As[O];
          q.push({
            date: hr(new Date(b, O, v), "yyyy-MM-dd"),
            count: 0,
            level: 0,
            key: new Date(b, O, v).getTime(),
            day: v,
            month: O,
            year: b,
            monthname: jn(O)
          }), q.push({
            date: hr(new Date(b, O, g), "yyyy-MM-dd"),
            count: 0,
            level: 0,
            key: new Date(b, O, g).getTime(),
            day: g,
            month: O,
            year: b,
            monthname: jn(O)
          }), v = 1, O = (O + 1) % 12, O === 0 && b++;
        }
      }
      l(Y);
      const T = {}, B = q.reduce((O, b) => {
        const { day: v, month: E, year: M } = b;
        return O[M] || (O[M] = {}), O[M][E] || (O[M][E] = []), T[M] = T[M] || {}, T[M][E] = T[M][E] || [
          32,
          0
        ], T[M][E][0] = Math.min(
          T[M][E][0],
          v
        ), T[M][E][1] = Math.max(
          T[M][E][1],
          v
        ), O[M][E].push(b), O;
      }, {});
      return Object.keys(B).forEach((O) => {
        const b = Number(O), v = b === e ? i : 11, E = r.name === "Current" && b !== e ? i : 0;
        for (let M = E; M <= v; M++) {
          const g = As[M];
          T[b][M] || (T[b][M] = [32, 0], B[b][M] = []);
          const C = T[b][M][0], j = T[b][M][1];
          let D = 1, u = g;
          b !== e && M == i && r.name === "Current" && (D = (/* @__PURE__ */ new Date()).getDate()), b === e && M === i && r.name === "Current" && (u = n), C !== D && B[b][M].unshift({
            date: hr(
              new Date(b, M, D),
              "yyyy-MM-dd"
            ),
            count: 0,
            level: 0,
            key: 0,
            day: 1,
            month: M,
            year: b,
            monthname: jn(M)
          }), (j !== u && b !== e || M !== i) && B[b][M].push({
            date: hr(
              new Date(b, M, u),
              "yyyy-MM-dd"
            ),
            count: 0,
            level: 0,
            key: 0,
            day: u,
            month: M,
            year: b,
            monthname: jn(M)
          });
        }
      }), B;
    }, [t, l, r]),
    submissionsCount: s,
    currentMonth: i,
    currentYear: e
  };
}, Lw = (t) => {
  const r = (/* @__PURE__ */ new Date()).getFullYear();
  return Ri(() => {
    const i = (t || []).sort((n, s) => s - n).map((n) => n === r ? { name: "Current", value: n.toString() } : {
      name: n.toString(),
      value: n.toString()
    });
    return (i.length === 0 || i[0].name !== "Current") && i.unshift({ name: "Current" }), i;
  }, [t]);
}, Rw = (t) => Ri(() => (t || []).reduce((r, e) => {
  const i = new Date(Number(e.timestamp) * 1e3).getMonth();
  return r[i] = e.badge, r;
}, {}), [t]), Nw = (t) => rs({
  queryKey: ["badges", t],
  queryFn: () => Mw(t),
  enabled: !!t
}), n2 = ({
  username: t
}) => {
  var s, l, m;
  const { isLoading: r, isError: e, data: i } = Qd(t);
  if (e)
    return /* @__PURE__ */ se.jsx("div", { children: "Error" });
  const n = new Date(
    (((m = (l = (s = i == null ? void 0 : i.userContestRankingHistory) == null ? void 0 : s[0]) == null ? void 0 : l.contest) == null ? void 0 : m.startTime) || (/* @__PURE__ */ new Date()).getTime()) * 1e3
  ).getFullYear();
  return /* @__PURE__ */ se.jsxs("div", { className: "w-full h-full bg-dark-layer-1 p-4 shadow-dark-down-01 rounded-lg mt-2 min-w-[250px]", children: [
    /* @__PURE__ */ se.jsx(Et, { when: !r && !e && !!i && i.userContestRankingHistory.length > 0, children: /* @__PURE__ */ se.jsx(
      vw,
      {
        userContestRankingHistory: (i == null ? void 0 : i.userContestRankingHistory) || [],
        userContestDetails: i == null ? void 0 : i.userContestRanking,
        startYear: n,
        currentYear: (/* @__PURE__ */ new Date()).getFullYear()
      }
    ) }),
    /* @__PURE__ */ se.jsx(Et, { when: !r && !e && !!i && i.userContestRankingHistory.length === 0, children: /* @__PURE__ */ se.jsx("div", { className: " bg-dark-layer-1 text-dark-label-1 flex items-center h-full justify-center", children: "User has not participated in any contest" }) }),
    /* @__PURE__ */ se.jsx(Et, { when: r, children: /* @__PURE__ */ se.jsx(xw, {}) })
  ] });
}, jw = ({
  data: t
}) => {
  const [r, e] = At(0), [i, n] = At(!1);
  return {
    options: {
      chart: {
        renderTo: "container",
        type: "column",
        backgroundColor: "rgb(40, 40, 40, 1)",
        height: 200
      },
      xAxis: {
        categories: [],
        labels: {
          enabled: !1
        },
        lineColor: "none"
      },
      yAxis: {
        min: 10,
        title: {
          enabled: !1
        },
        gridLineColor: "none",
        labels: {
          enabled: !1
        }
      },
      tooltip: {
        headerFormat: "",
        pointFormat: "",
        enabled: !1
      },
      title: {
        text: ""
      },
      subtitle: {
        text: ""
      },
      legend: {
        enabled: !1
      },
      minPointLength: 1,
      plotOptions: {
        series: {
          pointPadding: 0.07,
          groupPadding: 0.04
        },
        threshold: 1
      },
      series: [
        {
          data: t,
          color: "hsla(0,0%,100%,.1)",
          borderColor: "rgb(38, 38, 38)",
          borderRadius: 3,
          minHeight: 11,
          depth: 300,
          states: {
            hover: {
              color: "rgb(255, 161, 22)",
              animation: {
                duration: 2500
              }
            }
          },
          point: {
            events: {
              mouseOver: function(l) {
                l && l.target && (e(l.target.index), n(!0));
              },
              mouseOut: function(l) {
                l && l.target && n(!1);
              }
            }
          },
          threshold: 1
        }
      ],
      credits: {
        enabled: !1
      }
    },
    currentIndex: r,
    isHovered: i
  };
}, Iw = ({
  data: t,
  topPercentage: r,
  ratingInfoData: e
}) => {
  const { options: i, currentIndex: n, isHovered: s } = jw({
    data: t
  }), l = 9950, m = (Y) => `${Y.toFixed(2)}%`, A = e[n];
  return /* @__PURE__ */ se.jsxs("div", { children: [
    /* @__PURE__ */ se.jsx(Et, { when: !s, children: /* @__PURE__ */ se.jsx("div", { children: /* @__PURE__ */ se.jsxs("div", { children: [
      /* @__PURE__ */ se.jsx("p", { className: "text-xs text-dark-label-3 font-medium", children: "Top" }),
      /* @__PURE__ */ se.jsx("p", { className: "text-dark-label-1 text-2xl", children: m(r) })
    ] }) }) }),
    /* @__PURE__ */ se.jsx(Et, { when: s, children: /* @__PURE__ */ se.jsxs("div", { className: "flex gap-2 items-start", children: [
      /* @__PURE__ */ se.jsxs("div", { children: [
        /* @__PURE__ */ se.jsx("p", { className: "text-xs text-dark-label-3 font-medium", children: "Top" }),
        /* @__PURE__ */ se.jsx("p", { className: "text-dark-label-1 text-2xl", children: m(A.topPercentage) })
      ] }),
      /* @__PURE__ */ se.jsxs("div", { children: [
        /* @__PURE__ */ se.jsxs("p", { className: "text-xs text-dark-label-3 font-medium", children: [
          A.ratingStart,
          A.ratingEnd < l ? ` - ${A.ratingEnd}` : "+"
        ] }),
        /* @__PURE__ */ se.jsxs("p", { className: "text-dark-label-1", children: [
          A.userCount,
          " users"
        ] })
      ] })
    ] }) }),
    /* @__PURE__ */ se.jsx(uh, { highcharts: hh, options: i })
  ] });
}, s2 = ({
  username: t
}) => {
  const {
    contestRatingData: r,
    isLoading: e,
    isError: i,
    histogramData: n,
    topPercentage: s
  } = Tw(t);
  return i ? /* @__PURE__ */ se.jsx(se.Fragment, { children: "Error" }) : /* @__PURE__ */ se.jsxs("div", { className: "w-full h-full bg-dark-layer-1 p-4 shadow-dark-down-01 rounded-lg mt-2", children: [
    /* @__PURE__ */ se.jsxs(
      Et,
      {
        when: !i && !e && !!r && !!n,
        children: [
          /* @__PURE__ */ se.jsx(Et, { when: s > 0, children: /* @__PURE__ */ se.jsx(
            Iw,
            {
              data: n,
              topPercentage: s,
              ratingInfoData: r || []
            }
          ) }),
          /* @__PURE__ */ se.jsx(
            Et,
            {
              when: (r == null ? void 0 : r.length) === 0 || s === 0,
              children: /* @__PURE__ */ se.jsx("div", { className: " bg-dark-layer-1 text-dark-label-1 flex items-center h-full justify-center", children: "User has not participated in any contest" })
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ se.jsx(Et, { when: e || !r, children: /* @__PURE__ */ se.jsx(ym, {}) })
  ] });
}, Va = ({
  level: t,
  problemsSolved: r,
  totalProblems: e,
  beats: i
}) => {
  const n = Math.round(
    r / e * 100
  );
  return /* @__PURE__ */ se.jsxs("div", { className: "w-full flex flex-col gap-2", children: [
    /* @__PURE__ */ se.jsxs("div", { className: "flex items-start justify-between", children: [
      /* @__PURE__ */ se.jsxs("div", { className: "flex gap-4 items-end", children: [
        /* @__PURE__ */ se.jsx("p", { className: "text-xs text-dark-label-3 font-medium", children: t }),
        /* @__PURE__ */ se.jsxs("p", { className: "text-base leading-[22px] text-dark-label-1", children: [
          r,
          /* @__PURE__ */ se.jsxs("span", { className: "text-xs text-dark-label-3", children: [
            "/",
            e
          ] })
        ] })
      ] }),
      /* @__PURE__ */ se.jsxs("p", { className: "text-xs leading-[22px] text-dark-label-3", children: [
        "Beats ",
        /* @__PURE__ */ se.jsxs("span", { className: "text-dark-label-2", children: [
          i.toFixed(1),
          "%"
        ] })
      ] })
    ] }),
    /* @__PURE__ */ se.jsx(pm, { width: n, level: t })
  ] });
}, a2 = ({
  username: t
}) => {
  const { data: r, isLoading: e, isError: i } = Ow(t);
  return i ? /* @__PURE__ */ se.jsx(se.Fragment, { children: "Error" }) : /* @__PURE__ */ se.jsxs("div", { className: "w-full bg-dark-layer-1 p-4 shadow-dark-down-01 rounded-lg", children: [
    /* @__PURE__ */ se.jsxs(Et, { when: !!r && !e && !i, children: [
      /* @__PURE__ */ se.jsx("div", { className: "px-[13px] text-xs font-medium text-dark-label-3", children: "Solved Problems" }),
      /* @__PURE__ */ se.jsxs("div", { className: "flex gap-4", children: [
        /* @__PURE__ */ se.jsx("div", { className: "mt-6 mr-4 p-2", children: /* @__PURE__ */ se.jsx(
          fm,
          {
            indicatorColor: "rgba(255, 161, 22, 1)",
            solvedProblems: (r == null ? void 0 : r.All.solvedCount) || 0,
            totalProblems: (r == null ? void 0 : r.All.totalCount) || 0,
            trackWidth: 4,
            indicatorWidth: 5,
            label: "Solved",
            labelColor: "#fff",
            trackColor: "hsla(0,0%,100%,.1)",
            size: 100,
            changeProgressContent: () => {
            }
          }
        ) }),
        /* @__PURE__ */ se.jsxs("div", { className: "w-full space-y-4", children: [
          /* @__PURE__ */ se.jsx(
            Va,
            {
              level: "Easy",
              problemsSolved: (r == null ? void 0 : r.Easy.solvedCount) || 0,
              totalProblems: (r == null ? void 0 : r.Easy.totalCount) || 0,
              beats: (r == null ? void 0 : r.Easy.percentage) || 0
            }
          ),
          /* @__PURE__ */ se.jsx(
            Va,
            {
              level: "Medium",
              problemsSolved: (r == null ? void 0 : r.Medium.solvedCount) || 0,
              totalProblems: (r == null ? void 0 : r.Medium.totalCount) || 0,
              beats: (r == null ? void 0 : r.Medium.percentage) || 0
            }
          ),
          /* @__PURE__ */ se.jsx(
            Va,
            {
              level: "Hard",
              problemsSolved: (r == null ? void 0 : r.Hard.solvedCount) || 0,
              totalProblems: (r == null ? void 0 : r.Hard.totalCount) || 0,
              beats: (r == null ? void 0 : r.Hard.percentage) || 0
            }
          )
        ] })
      ] })
    ] }),
    /* @__PURE__ */ se.jsx(Et, { when: e || !r, children: /* @__PURE__ */ se.jsx(bm, {}) })
  ] });
};
var $o = {}, Vd = { exports: {} };
/**
 * chroma.js - JavaScript library for color conversions
 *
 * Copyright (c) 2011-2019, Gregor Aisch
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. The name Gregor Aisch may not be used to endorse or promote products
 * derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL GREGOR AISCH OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * -------------------------------------------------------
 *
 * chroma.js includes colors from colorbrewer2.org, which are released under
 * the following license:
 *
 * Copyright (c) 2002 Cynthia Brewer, Mark Harrower,
 * and The Pennsylvania State University.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 * ------------------------------------------------------
 *
 * Named colors are taken from X11 Color Names.
 * http://www.w3.org/TR/css3-color/#svg-color
 *
 * @preserve
 */
(function(t, r) {
  (function(e, i) {
    t.exports = i();
  })(Mo, function() {
    for (var e = function(y, N, _) {
      return N === void 0 && (N = 0), _ === void 0 && (_ = 1), y < N ? N : y > _ ? _ : y;
    }, i = e, n = function(y) {
      y._clipped = !1, y._unclipped = y.slice(0);
      for (var N = 0; N <= 3; N++)
        N < 3 ? ((y[N] < 0 || y[N] > 255) && (y._clipped = !0), y[N] = i(y[N], 0, 255)) : N === 3 && (y[N] = i(y[N], 0, 1));
      return y;
    }, s = {}, l = 0, m = ["Boolean", "Number", "String", "Function", "Array", "Date", "RegExp", "Undefined", "Null"]; l < m.length; l += 1) {
      var A = m[l];
      s["[object " + A + "]"] = A.toLowerCase();
    }
    var Y = function(y) {
      return s[Object.prototype.toString.call(y)] || "object";
    }, q = Y, T = function(y, N) {
      return N === void 0 && (N = null), y.length >= 3 ? Array.prototype.slice.call(y) : q(y[0]) == "object" && N ? N.split("").filter(function(_) {
        return y[0][_] !== void 0;
      }).map(function(_) {
        return y[0][_];
      }) : y[0];
    }, B = Y, O = function(y) {
      if (y.length < 2)
        return null;
      var N = y.length - 1;
      return B(y[N]) == "string" ? y[N].toLowerCase() : null;
    }, b = Math.PI, v = {
      clip_rgb: n,
      limit: e,
      type: Y,
      unpack: T,
      last: O,
      PI: b,
      TWOPI: b * 2,
      PITHIRD: b / 3,
      DEG2RAD: b / 180,
      RAD2DEG: 180 / b
    }, E = {
      format: {},
      autodetect: []
    }, M = v.last, g = v.clip_rgb, C = v.type, j = E, D = function() {
      for (var N = [], _ = arguments.length; _--; )
        N[_] = arguments[_];
      var ce = this;
      if (C(N[0]) === "object" && N[0].constructor && N[0].constructor === this.constructor)
        return N[0];
      var ye = M(N), xe = !1;
      if (!ye) {
        xe = !0, j.sorted || (j.autodetect = j.autodetect.sort(function(je, Ue) {
          return Ue.p - je.p;
        }), j.sorted = !0);
        for (var pe = 0, Se = j.autodetect; pe < Se.length; pe += 1) {
          var Te = Se[pe];
          if (ye = Te.test.apply(Te, N), ye)
            break;
        }
      }
      if (j.format[ye]) {
        var De = j.format[ye].apply(null, xe ? N : N.slice(0, -1));
        ce._rgb = g(De);
      } else
        throw new Error("unknown format: " + N);
      ce._rgb.length === 3 && ce._rgb.push(1);
    };
    D.prototype.toString = function() {
      return C(this.hex) == "function" ? this.hex() : "[" + this._rgb.join(",") + "]";
    };
    var u = D, R = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(R.Color, [null].concat(y)))();
    };
    R.Color = u, R.version = "2.4.2";
    var K = R, I = v.unpack, z = Math.max, k = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = I(y, "rgb"), ce = _[0], ye = _[1], xe = _[2];
      ce = ce / 255, ye = ye / 255, xe = xe / 255;
      var pe = 1 - z(ce, z(ye, xe)), Se = pe < 1 ? 1 / (1 - pe) : 0, Te = (1 - ce - pe) * Se, De = (1 - ye - pe) * Se, je = (1 - xe - pe) * Se;
      return [Te, De, je, pe];
    }, h = k, F = v.unpack, o = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      y = F(y, "cmyk");
      var _ = y[0], ce = y[1], ye = y[2], xe = y[3], pe = y.length > 4 ? y[4] : 1;
      return xe === 1 ? [0, 0, 0, pe] : [
        _ >= 1 ? 0 : 255 * (1 - _) * (1 - xe),
        // r
        ce >= 1 ? 0 : 255 * (1 - ce) * (1 - xe),
        // g
        ye >= 1 ? 0 : 255 * (1 - ye) * (1 - xe),
        // b
        pe
      ];
    }, a = o, c = K, d = u, S = E, P = v.unpack, G = v.type, x = h;
    d.prototype.cmyk = function() {
      return x(this._rgb);
    }, c.cmyk = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(d, [null].concat(y, ["cmyk"])))();
    }, S.format.cmyk = a, S.autodetect.push({
      p: 2,
      test: function() {
        for (var y = [], N = arguments.length; N--; )
          y[N] = arguments[N];
        if (y = P(y, "cmyk"), G(y) === "array" && y.length === 4)
          return "cmyk";
      }
    });
    var Q = v.unpack, J = v.last, ie = function(y) {
      return Math.round(y * 100) / 100;
    }, te = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = Q(y, "hsla"), ce = J(y) || "lsa";
      return _[0] = ie(_[0] || 0), _[1] = ie(_[1] * 100) + "%", _[2] = ie(_[2] * 100) + "%", ce === "hsla" || _.length > 3 && _[3] < 1 ? (_[3] = _.length > 3 ? _[3] : 1, ce = "hsla") : _.length = 3, ce + "(" + _.join(",") + ")";
    }, $ = te, oe = v.unpack, p = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      y = oe(y, "rgba");
      var _ = y[0], ce = y[1], ye = y[2];
      _ /= 255, ce /= 255, ye /= 255;
      var xe = Math.min(_, ce, ye), pe = Math.max(_, ce, ye), Se = (pe + xe) / 2, Te, De;
      return pe === xe ? (Te = 0, De = Number.NaN) : Te = Se < 0.5 ? (pe - xe) / (pe + xe) : (pe - xe) / (2 - pe - xe), _ == pe ? De = (ce - ye) / (pe - xe) : ce == pe ? De = 2 + (ye - _) / (pe - xe) : ye == pe && (De = 4 + (_ - ce) / (pe - xe)), De *= 60, De < 0 && (De += 360), y.length > 3 && y[3] !== void 0 ? [De, Te, Se, y[3]] : [De, Te, Se];
    }, W = p, X = v.unpack, f = v.last, L = $, w = W, H = Math.round, U = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = X(y, "rgba"), ce = f(y) || "rgb";
      return ce.substr(0, 3) == "hsl" ? L(w(_), ce) : (_[0] = H(_[0]), _[1] = H(_[1]), _[2] = H(_[2]), (ce === "rgba" || _.length > 3 && _[3] < 1) && (_[3] = _.length > 3 ? _[3] : 1, ce = "rgba"), ce + "(" + _.slice(0, ce === "rgb" ? 3 : 4).join(",") + ")");
    }, ee = U, ae = v.unpack, ne = Math.round, he = function() {
      for (var y, N = [], _ = arguments.length; _--; )
        N[_] = arguments[_];
      N = ae(N, "hsl");
      var ce = N[0], ye = N[1], xe = N[2], pe, Se, Te;
      if (ye === 0)
        pe = Se = Te = xe * 255;
      else {
        var De = [0, 0, 0], je = [0, 0, 0], Ue = xe < 0.5 ? xe * (1 + ye) : xe + ye - xe * ye, Ie = 2 * xe - Ue, Ke = ce / 360;
        De[0] = Ke + 1 / 3, De[1] = Ke, De[2] = Ke - 1 / 3;
        for (var Qe = 0; Qe < 3; Qe++)
          De[Qe] < 0 && (De[Qe] += 1), De[Qe] > 1 && (De[Qe] -= 1), 6 * De[Qe] < 1 ? je[Qe] = Ie + (Ue - Ie) * 6 * De[Qe] : 2 * De[Qe] < 1 ? je[Qe] = Ue : 3 * De[Qe] < 2 ? je[Qe] = Ie + (Ue - Ie) * (2 / 3 - De[Qe]) * 6 : je[Qe] = Ie;
        y = [ne(je[0] * 255), ne(je[1] * 255), ne(je[2] * 255)], pe = y[0], Se = y[1], Te = y[2];
      }
      return N.length > 3 ? [pe, Se, Te, N[3]] : [pe, Se, Te, 1];
    }, me = he, ve = me, Me = E, Z = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/, V = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/, re = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/, le = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/, be = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/, de = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/, ge = Math.round, fe = function(y) {
      y = y.toLowerCase().trim();
      var N;
      if (Me.format.named)
        try {
          return Me.format.named(y);
        } catch {
        }
      if (N = y.match(Z)) {
        for (var _ = N.slice(1, 4), ce = 0; ce < 3; ce++)
          _[ce] = +_[ce];
        return _[3] = 1, _;
      }
      if (N = y.match(V)) {
        for (var ye = N.slice(1, 5), xe = 0; xe < 4; xe++)
          ye[xe] = +ye[xe];
        return ye;
      }
      if (N = y.match(re)) {
        for (var pe = N.slice(1, 4), Se = 0; Se < 3; Se++)
          pe[Se] = ge(pe[Se] * 2.55);
        return pe[3] = 1, pe;
      }
      if (N = y.match(le)) {
        for (var Te = N.slice(1, 5), De = 0; De < 3; De++)
          Te[De] = ge(Te[De] * 2.55);
        return Te[3] = +Te[3], Te;
      }
      if (N = y.match(be)) {
        var je = N.slice(1, 4);
        je[1] *= 0.01, je[2] *= 0.01;
        var Ue = ve(je);
        return Ue[3] = 1, Ue;
      }
      if (N = y.match(de)) {
        var Ie = N.slice(1, 4);
        Ie[1] *= 0.01, Ie[2] *= 0.01;
        var Ke = ve(Ie);
        return Ke[3] = +N[4], Ke;
      }
    };
    fe.test = function(y) {
      return Z.test(y) || V.test(y) || re.test(y) || le.test(y) || be.test(y) || de.test(y);
    };
    var ke = fe, Pe = K, Ae = u, Le = E, Ee = v.type, Ye = ee, We = ke;
    Ae.prototype.css = function(y) {
      return Ye(this._rgb, y);
    }, Pe.css = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(Ae, [null].concat(y, ["css"])))();
    }, Le.format.css = We, Le.autodetect.push({
      p: 5,
      test: function(y) {
        for (var N = [], _ = arguments.length - 1; _-- > 0; )
          N[_] = arguments[_ + 1];
        if (!N.length && Ee(y) === "string" && We.test(y))
          return "css";
      }
    });
    var Ne = u, Xe = K, et = E, Ze = v.unpack;
    et.format.gl = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = Ze(y, "rgba");
      return _[0] *= 255, _[1] *= 255, _[2] *= 255, _;
    }, Xe.gl = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(Ne, [null].concat(y, ["gl"])))();
    }, Ne.prototype.gl = function() {
      var y = this._rgb;
      return [y[0] / 255, y[1] / 255, y[2] / 255, y[3]];
    };
    var ut = v.unpack, it = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = ut(y, "rgb"), ce = _[0], ye = _[1], xe = _[2], pe = Math.min(ce, ye, xe), Se = Math.max(ce, ye, xe), Te = Se - pe, De = Te * 100 / 255, je = pe / (255 - Te) * 100, Ue;
      return Te === 0 ? Ue = Number.NaN : (ce === Se && (Ue = (ye - xe) / Te), ye === Se && (Ue = 2 + (xe - ce) / Te), xe === Se && (Ue = 4 + (ce - ye) / Te), Ue *= 60, Ue < 0 && (Ue += 360)), [Ue, De, je];
    }, kt = it, ze = v.unpack, nt = Math.floor, jt = function() {
      for (var y, N, _, ce, ye, xe, pe = [], Se = arguments.length; Se--; )
        pe[Se] = arguments[Se];
      pe = ze(pe, "hcg");
      var Te = pe[0], De = pe[1], je = pe[2], Ue, Ie, Ke;
      je = je * 255;
      var Qe = De * 255;
      if (De === 0)
        Ue = Ie = Ke = je;
      else {
        Te === 360 && (Te = 0), Te > 360 && (Te -= 360), Te < 0 && (Te += 360), Te /= 60;
        var ht = nt(Te), gt = Te - ht, vt = je * (1 - De), Ct = vt + Qe * (1 - gt), er = vt + Qe * gt, Zt = vt + Qe;
        switch (ht) {
          case 0:
            y = [Zt, er, vt], Ue = y[0], Ie = y[1], Ke = y[2];
            break;
          case 1:
            N = [Ct, Zt, vt], Ue = N[0], Ie = N[1], Ke = N[2];
            break;
          case 2:
            _ = [vt, Zt, er], Ue = _[0], Ie = _[1], Ke = _[2];
            break;
          case 3:
            ce = [vt, Ct, Zt], Ue = ce[0], Ie = ce[1], Ke = ce[2];
            break;
          case 4:
            ye = [er, vt, Zt], Ue = ye[0], Ie = ye[1], Ke = ye[2];
            break;
          case 5:
            xe = [Zt, vt, Ct], Ue = xe[0], Ie = xe[1], Ke = xe[2];
            break;
        }
      }
      return [Ue, Ie, Ke, pe.length > 3 ? pe[3] : 1];
    }, Vt = jt, Be = v.unpack, Ve = v.type, Je = K, Dt = u, It = E, _t = kt;
    Dt.prototype.hcg = function() {
      return _t(this._rgb);
    }, Je.hcg = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(Dt, [null].concat(y, ["hcg"])))();
    }, It.format.hcg = Vt, It.autodetect.push({
      p: 1,
      test: function() {
        for (var y = [], N = arguments.length; N--; )
          y[N] = arguments[N];
        if (y = Be(y, "hcg"), Ve(y) === "array" && y.length === 3)
          return "hcg";
      }
    });
    var $t = v.unpack, Bt = v.last, ue = Math.round, Oe = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = $t(y, "rgba"), ce = _[0], ye = _[1], xe = _[2], pe = _[3], Se = Bt(y) || "auto";
      pe === void 0 && (pe = 1), Se === "auto" && (Se = pe < 1 ? "rgba" : "rgb"), ce = ue(ce), ye = ue(ye), xe = ue(xe);
      var Te = ce << 16 | ye << 8 | xe, De = "000000" + Te.toString(16);
      De = De.substr(De.length - 6);
      var je = "0" + ue(pe * 255).toString(16);
      switch (je = je.substr(je.length - 2), Se.toLowerCase()) {
        case "rgba":
          return "#" + De + je;
        case "argb":
          return "#" + je + De;
        default:
          return "#" + De;
      }
    }, He = Oe, tt = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/, ct = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/, mt = function(y) {
      if (y.match(tt)) {
        (y.length === 4 || y.length === 7) && (y = y.substr(1)), y.length === 3 && (y = y.split(""), y = y[0] + y[0] + y[1] + y[1] + y[2] + y[2]);
        var N = parseInt(y, 16), _ = N >> 16, ce = N >> 8 & 255, ye = N & 255;
        return [_, ce, ye, 1];
      }
      if (y.match(ct)) {
        (y.length === 5 || y.length === 9) && (y = y.substr(1)), y.length === 4 && (y = y.split(""), y = y[0] + y[0] + y[1] + y[1] + y[2] + y[2] + y[3] + y[3]);
        var xe = parseInt(y, 16), pe = xe >> 24 & 255, Se = xe >> 16 & 255, Te = xe >> 8 & 255, De = Math.round((xe & 255) / 255 * 100) / 100;
        return [pe, Se, Te, De];
      }
      throw new Error("unknown hex color: " + y);
    }, ot = mt, at = K, st = u, ft = v.type, Pt = E, Gt = He;
    st.prototype.hex = function(y) {
      return Gt(this._rgb, y);
    }, at.hex = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(st, [null].concat(y, ["hex"])))();
    }, Pt.format.hex = ot, Pt.autodetect.push({
      p: 4,
      test: function(y) {
        for (var N = [], _ = arguments.length - 1; _-- > 0; )
          N[_] = arguments[_ + 1];
        if (!N.length && ft(y) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(y.length) >= 0)
          return "hex";
      }
    });
    var Er = v.unpack, Ur = v.TWOPI, kr = Math.min, uu = Math.sqrt, fu = Math.acos, pu = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = Er(y, "rgb"), ce = _[0], ye = _[1], xe = _[2];
      ce /= 255, ye /= 255, xe /= 255;
      var pe, Se = kr(ce, ye, xe), Te = (ce + ye + xe) / 3, De = Te > 0 ? 1 - Se / Te : 0;
      return De === 0 ? pe = NaN : (pe = (ce - ye + (ce - xe)) / 2, pe /= uu((ce - ye) * (ce - ye) + (ce - xe) * (ye - xe)), pe = fu(pe), xe > ye && (pe = Ur - pe), pe /= Ur), [pe * 360, De, Te];
    }, gu = pu, mu = v.unpack, fa = v.limit, Fi = v.TWOPI, pa = v.PITHIRD, Bi = Math.cos, yu = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      y = mu(y, "hsi");
      var _ = y[0], ce = y[1], ye = y[2], xe, pe, Se;
      return isNaN(_) && (_ = 0), isNaN(ce) && (ce = 0), _ > 360 && (_ -= 360), _ < 0 && (_ += 360), _ /= 360, _ < 1 / 3 ? (Se = (1 - ce) / 3, xe = (1 + ce * Bi(Fi * _) / Bi(pa - Fi * _)) / 3, pe = 1 - (Se + xe)) : _ < 2 / 3 ? (_ -= 1 / 3, xe = (1 - ce) / 3, pe = (1 + ce * Bi(Fi * _) / Bi(pa - Fi * _)) / 3, Se = 1 - (xe + pe)) : (_ -= 2 / 3, pe = (1 - ce) / 3, Se = (1 + ce * Bi(Fi * _) / Bi(pa - Fi * _)) / 3, xe = 1 - (pe + Se)), xe = fa(ye * xe * 3), pe = fa(ye * pe * 3), Se = fa(ye * Se * 3), [xe * 255, pe * 255, Se * 255, y.length > 3 ? y[3] : 1];
    }, bu = yu, vu = v.unpack, xu = v.type, wu = K, al = u, ol = E, ku = gu;
    al.prototype.hsi = function() {
      return ku(this._rgb);
    }, wu.hsi = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(al, [null].concat(y, ["hsi"])))();
    }, ol.format.hsi = bu, ol.autodetect.push({
      p: 2,
      test: function() {
        for (var y = [], N = arguments.length; N--; )
          y[N] = arguments[N];
        if (y = vu(y, "hsi"), xu(y) === "array" && y.length === 3)
          return "hsi";
      }
    });
    var Cu = v.unpack, Su = v.type, Mu = K, ll = u, cl = E, Tu = W;
    ll.prototype.hsl = function() {
      return Tu(this._rgb);
    }, Mu.hsl = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(ll, [null].concat(y, ["hsl"])))();
    }, cl.format.hsl = me, cl.autodetect.push({
      p: 2,
      test: function() {
        for (var y = [], N = arguments.length; N--; )
          y[N] = arguments[N];
        if (y = Cu(y, "hsl"), Su(y) === "array" && y.length === 3)
          return "hsl";
      }
    });
    var Ou = v.unpack, Au = Math.min, Eu = Math.max, Pu = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      y = Ou(y, "rgb");
      var _ = y[0], ce = y[1], ye = y[2], xe = Au(_, ce, ye), pe = Eu(_, ce, ye), Se = pe - xe, Te, De, je;
      return je = pe / 255, pe === 0 ? (Te = Number.NaN, De = 0) : (De = Se / pe, _ === pe && (Te = (ce - ye) / Se), ce === pe && (Te = 2 + (ye - _) / Se), ye === pe && (Te = 4 + (_ - ce) / Se), Te *= 60, Te < 0 && (Te += 360)), [Te, De, je];
    }, Du = Pu, Lu = v.unpack, Ru = Math.floor, Nu = function() {
      for (var y, N, _, ce, ye, xe, pe = [], Se = arguments.length; Se--; )
        pe[Se] = arguments[Se];
      pe = Lu(pe, "hsv");
      var Te = pe[0], De = pe[1], je = pe[2], Ue, Ie, Ke;
      if (je *= 255, De === 0)
        Ue = Ie = Ke = je;
      else {
        Te === 360 && (Te = 0), Te > 360 && (Te -= 360), Te < 0 && (Te += 360), Te /= 60;
        var Qe = Ru(Te), ht = Te - Qe, gt = je * (1 - De), vt = je * (1 - De * ht), Ct = je * (1 - De * (1 - ht));
        switch (Qe) {
          case 0:
            y = [je, Ct, gt], Ue = y[0], Ie = y[1], Ke = y[2];
            break;
          case 1:
            N = [vt, je, gt], Ue = N[0], Ie = N[1], Ke = N[2];
            break;
          case 2:
            _ = [gt, je, Ct], Ue = _[0], Ie = _[1], Ke = _[2];
            break;
          case 3:
            ce = [gt, vt, je], Ue = ce[0], Ie = ce[1], Ke = ce[2];
            break;
          case 4:
            ye = [Ct, gt, je], Ue = ye[0], Ie = ye[1], Ke = ye[2];
            break;
          case 5:
            xe = [je, gt, vt], Ue = xe[0], Ie = xe[1], Ke = xe[2];
            break;
        }
      }
      return [Ue, Ie, Ke, pe.length > 3 ? pe[3] : 1];
    }, ju = Nu, Iu = v.unpack, Fu = v.type, Bu = K, hl = u, dl = E, Wu = Du;
    hl.prototype.hsv = function() {
      return Wu(this._rgb);
    }, Bu.hsv = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(hl, [null].concat(y, ["hsv"])))();
    }, dl.format.hsv = ju, dl.autodetect.push({
      p: 2,
      test: function() {
        for (var y = [], N = arguments.length; N--; )
          y[N] = arguments[N];
        if (y = Iu(y, "hsv"), Fu(y) === "array" && y.length === 3)
          return "hsv";
      }
    });
    var fs = {
      // Corresponds roughly to RGB brighter/darker
      Kn: 18,
      // D65 standard referent
      Xn: 0.95047,
      Yn: 1,
      Zn: 1.08883,
      t0: 0.137931034,
      // 4 / 29
      t1: 0.206896552,
      // 6 / 29
      t2: 0.12841855,
      // 3 * t1 * t1
      t3: 8856452e-9
      // t1 * t1 * t1
    }, Wi = fs, Hu = v.unpack, ul = Math.pow, zu = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = Hu(y, "rgb"), ce = _[0], ye = _[1], xe = _[2], pe = Yu(ce, ye, xe), Se = pe[0], Te = pe[1], De = pe[2], je = 116 * Te - 16;
      return [je < 0 ? 0 : je, 500 * (Se - Te), 200 * (Te - De)];
    }, ga = function(y) {
      return (y /= 255) <= 0.04045 ? y / 12.92 : ul((y + 0.055) / 1.055, 2.4);
    }, ma = function(y) {
      return y > Wi.t3 ? ul(y, 1 / 3) : y / Wi.t2 + Wi.t0;
    }, Yu = function(y, N, _) {
      y = ga(y), N = ga(N), _ = ga(_);
      var ce = ma((0.4124564 * y + 0.3575761 * N + 0.1804375 * _) / Wi.Xn), ye = ma((0.2126729 * y + 0.7151522 * N + 0.072175 * _) / Wi.Yn), xe = ma((0.0193339 * y + 0.119192 * N + 0.9503041 * _) / Wi.Zn);
      return [ce, ye, xe];
    }, fl = zu, Hi = fs, Uu = v.unpack, Gu = Math.pow, qu = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      y = Uu(y, "lab");
      var _ = y[0], ce = y[1], ye = y[2], xe, pe, Se, Te, De, je;
      return pe = (_ + 16) / 116, xe = isNaN(ce) ? pe : pe + ce / 500, Se = isNaN(ye) ? pe : pe - ye / 200, pe = Hi.Yn * ba(pe), xe = Hi.Xn * ba(xe), Se = Hi.Zn * ba(Se), Te = ya(3.2404542 * xe - 1.5371385 * pe - 0.4985314 * Se), De = ya(-0.969266 * xe + 1.8760108 * pe + 0.041556 * Se), je = ya(0.0556434 * xe - 0.2040259 * pe + 1.0572252 * Se), [Te, De, je, y.length > 3 ? y[3] : 1];
    }, ya = function(y) {
      return 255 * (y <= 304e-5 ? 12.92 * y : 1.055 * Gu(y, 1 / 2.4) - 0.055);
    }, ba = function(y) {
      return y > Hi.t1 ? y * y * y : Hi.t2 * (y - Hi.t0);
    }, pl = qu, Xu = v.unpack, Qu = v.type, Vu = K, gl = u, ml = E, Ku = fl;
    gl.prototype.lab = function() {
      return Ku(this._rgb);
    }, Vu.lab = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(gl, [null].concat(y, ["lab"])))();
    }, ml.format.lab = pl, ml.autodetect.push({
      p: 2,
      test: function() {
        for (var y = [], N = arguments.length; N--; )
          y[N] = arguments[N];
        if (y = Xu(y, "lab"), Qu(y) === "array" && y.length === 3)
          return "lab";
      }
    });
    var Zu = v.unpack, Ju = v.RAD2DEG, _u = Math.sqrt, $u = Math.atan2, ef = Math.round, tf = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = Zu(y, "lab"), ce = _[0], ye = _[1], xe = _[2], pe = _u(ye * ye + xe * xe), Se = ($u(xe, ye) * Ju + 360) % 360;
      return ef(pe * 1e4) === 0 && (Se = Number.NaN), [ce, pe, Se];
    }, yl = tf, rf = v.unpack, nf = fl, sf = yl, af = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = rf(y, "rgb"), ce = _[0], ye = _[1], xe = _[2], pe = nf(ce, ye, xe), Se = pe[0], Te = pe[1], De = pe[2];
      return sf(Se, Te, De);
    }, of = af, lf = v.unpack, cf = v.DEG2RAD, hf = Math.sin, df = Math.cos, uf = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = lf(y, "lch"), ce = _[0], ye = _[1], xe = _[2];
      return isNaN(xe) && (xe = 0), xe = xe * cf, [ce, df(xe) * ye, hf(xe) * ye];
    }, bl = uf, ff = v.unpack, pf = bl, gf = pl, mf = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      y = ff(y, "lch");
      var _ = y[0], ce = y[1], ye = y[2], xe = pf(_, ce, ye), pe = xe[0], Se = xe[1], Te = xe[2], De = gf(pe, Se, Te), je = De[0], Ue = De[1], Ie = De[2];
      return [je, Ue, Ie, y.length > 3 ? y[3] : 1];
    }, vl = mf, yf = v.unpack, bf = vl, vf = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = yf(y, "hcl").reverse();
      return bf.apply(void 0, _);
    }, xf = vf, wf = v.unpack, kf = v.type, xl = K, ps = u, va = E, wl = of;
    ps.prototype.lch = function() {
      return wl(this._rgb);
    }, ps.prototype.hcl = function() {
      return wl(this._rgb).reverse();
    }, xl.lch = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(ps, [null].concat(y, ["lch"])))();
    }, xl.hcl = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(ps, [null].concat(y, ["hcl"])))();
    }, va.format.lch = vl, va.format.hcl = xf, ["lch", "hcl"].forEach(function(y) {
      return va.autodetect.push({
        p: 2,
        test: function() {
          for (var N = [], _ = arguments.length; _--; )
            N[_] = arguments[_];
          if (N = wf(N, y), kf(N) === "array" && N.length === 3)
            return y;
        }
      });
    });
    var Cf = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#00ffff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000000",
      blanchedalmond: "#ffebcd",
      blue: "#0000ff",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflower: "#6495ed",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#00ffff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#ff00ff",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      laserlemon: "#ffff54",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrod: "#fafad2",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#778899",
      lightslategrey: "#778899",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#00ff00",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#ff00ff",
      maroon: "#800000",
      maroon2: "#7f0000",
      maroon3: "#b03060",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      purple2: "#7f007f",
      purple3: "#a020f0",
      rebeccapurple: "#663399",
      red: "#ff0000",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#ffffff",
      whitesmoke: "#f5f5f5",
      yellow: "#ffff00",
      yellowgreen: "#9acd32"
    }, kl = Cf, Sf = u, Cl = E, Mf = v.type, Mn = kl, Tf = ot, Of = He;
    Sf.prototype.name = function() {
      for (var y = Of(this._rgb, "rgb"), N = 0, _ = Object.keys(Mn); N < _.length; N += 1) {
        var ce = _[N];
        if (Mn[ce] === y)
          return ce.toLowerCase();
      }
      return y;
    }, Cl.format.named = function(y) {
      if (y = y.toLowerCase(), Mn[y])
        return Tf(Mn[y]);
      throw new Error("unknown color name: " + y);
    }, Cl.autodetect.push({
      p: 5,
      test: function(y) {
        for (var N = [], _ = arguments.length - 1; _-- > 0; )
          N[_] = arguments[_ + 1];
        if (!N.length && Mf(y) === "string" && Mn[y.toLowerCase()])
          return "named";
      }
    });
    var Af = v.unpack, Ef = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = Af(y, "rgb"), ce = _[0], ye = _[1], xe = _[2];
      return (ce << 16) + (ye << 8) + xe;
    }, Pf = Ef, Df = v.type, Lf = function(y) {
      if (Df(y) == "number" && y >= 0 && y <= 16777215) {
        var N = y >> 16, _ = y >> 8 & 255, ce = y & 255;
        return [N, _, ce, 1];
      }
      throw new Error("unknown num color: " + y);
    }, Rf = Lf, Nf = K, Sl = u, Ml = E, jf = v.type, If = Pf;
    Sl.prototype.num = function() {
      return If(this._rgb);
    }, Nf.num = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(Sl, [null].concat(y, ["num"])))();
    }, Ml.format.num = Rf, Ml.autodetect.push({
      p: 5,
      test: function() {
        for (var y = [], N = arguments.length; N--; )
          y[N] = arguments[N];
        if (y.length === 1 && jf(y[0]) === "number" && y[0] >= 0 && y[0] <= 16777215)
          return "num";
      }
    });
    var Ff = K, xa = u, Tl = E, Ol = v.unpack, Al = v.type, El = Math.round;
    xa.prototype.rgb = function(y) {
      return y === void 0 && (y = !0), y === !1 ? this._rgb.slice(0, 3) : this._rgb.slice(0, 3).map(El);
    }, xa.prototype.rgba = function(y) {
      return y === void 0 && (y = !0), this._rgb.slice(0, 4).map(function(N, _) {
        return _ < 3 ? y === !1 ? N : El(N) : N;
      });
    }, Ff.rgb = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(xa, [null].concat(y, ["rgb"])))();
    }, Tl.format.rgb = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = Ol(y, "rgba");
      return _[3] === void 0 && (_[3] = 1), _;
    }, Tl.autodetect.push({
      p: 3,
      test: function() {
        for (var y = [], N = arguments.length; N--; )
          y[N] = arguments[N];
        if (y = Ol(y, "rgba"), Al(y) === "array" && (y.length === 3 || y.length === 4 && Al(y[3]) == "number" && y[3] >= 0 && y[3] <= 1))
          return "rgb";
      }
    });
    var gs = Math.log, Bf = function(y) {
      var N = y / 100, _, ce, ye;
      return N < 66 ? (_ = 255, ce = N < 6 ? 0 : -155.25485562709179 - 0.44596950469579133 * (ce = N - 2) + 104.49216199393888 * gs(ce), ye = N < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (ye = N - 10) + 115.67994401066147 * gs(ye)) : (_ = 351.97690566805693 + 0.114206453784165 * (_ = N - 55) - 40.25366309332127 * gs(_), ce = 325.4494125711974 + 0.07943456536662342 * (ce = N - 50) - 28.0852963507957 * gs(ce), ye = 255), [_, ce, ye, 1];
    }, Pl = Bf, Wf = Pl, Hf = v.unpack, zf = Math.round, Yf = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      for (var _ = Hf(y, "rgb"), ce = _[0], ye = _[2], xe = 1e3, pe = 4e4, Se = 0.4, Te; pe - xe > Se; ) {
        Te = (pe + xe) * 0.5;
        var De = Wf(Te);
        De[2] / De[0] >= ye / ce ? pe = Te : xe = Te;
      }
      return zf(Te);
    }, Uf = Yf, wa = K, ms = u, ka = E, Gf = Uf;
    ms.prototype.temp = ms.prototype.kelvin = ms.prototype.temperature = function() {
      return Gf(this._rgb);
    }, wa.temp = wa.kelvin = wa.temperature = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(ms, [null].concat(y, ["temp"])))();
    }, ka.format.temp = ka.format.kelvin = ka.format.temperature = Pl;
    var qf = v.unpack, Ca = Math.cbrt, Xf = Math.pow, Qf = Math.sign, Vf = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = qf(y, "rgb"), ce = _[0], ye = _[1], xe = _[2], pe = [Sa(ce / 255), Sa(ye / 255), Sa(xe / 255)], Se = pe[0], Te = pe[1], De = pe[2], je = Ca(0.4122214708 * Se + 0.5363325363 * Te + 0.0514459929 * De), Ue = Ca(0.2119034982 * Se + 0.6806995451 * Te + 0.1073969566 * De), Ie = Ca(0.0883024619 * Se + 0.2817188376 * Te + 0.6299787005 * De);
      return [
        0.2104542553 * je + 0.793617785 * Ue - 0.0040720468 * Ie,
        1.9779984951 * je - 2.428592205 * Ue + 0.4505937099 * Ie,
        0.0259040371 * je + 0.7827717662 * Ue - 0.808675766 * Ie
      ];
    }, Dl = Vf;
    function Sa(y) {
      var N = Math.abs(y);
      return N < 0.04045 ? y / 12.92 : (Qf(y) || 1) * Xf((N + 0.055) / 1.055, 2.4);
    }
    var Kf = v.unpack, ys = Math.pow, Zf = Math.sign, Jf = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      y = Kf(y, "lab");
      var _ = y[0], ce = y[1], ye = y[2], xe = ys(_ + 0.3963377774 * ce + 0.2158037573 * ye, 3), pe = ys(_ - 0.1055613458 * ce - 0.0638541728 * ye, 3), Se = ys(_ - 0.0894841775 * ce - 1.291485548 * ye, 3);
      return [
        255 * Ma(4.0767416621 * xe - 3.3077115913 * pe + 0.2309699292 * Se),
        255 * Ma(-1.2684380046 * xe + 2.6097574011 * pe - 0.3413193965 * Se),
        255 * Ma(-0.0041960863 * xe - 0.7034186147 * pe + 1.707614701 * Se),
        y.length > 3 ? y[3] : 1
      ];
    }, Ll = Jf;
    function Ma(y) {
      var N = Math.abs(y);
      return N > 31308e-7 ? (Zf(y) || 1) * (1.055 * ys(N, 1 / 2.4) - 0.055) : y * 12.92;
    }
    var _f = v.unpack, $f = v.type, ep = K, Rl = u, Nl = E, tp = Dl;
    Rl.prototype.oklab = function() {
      return tp(this._rgb);
    }, ep.oklab = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(Rl, [null].concat(y, ["oklab"])))();
    }, Nl.format.oklab = Ll, Nl.autodetect.push({
      p: 3,
      test: function() {
        for (var y = [], N = arguments.length; N--; )
          y[N] = arguments[N];
        if (y = _f(y, "oklab"), $f(y) === "array" && y.length === 3)
          return "oklab";
      }
    });
    var rp = v.unpack, ip = Dl, np = yl, sp = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      var _ = rp(y, "rgb"), ce = _[0], ye = _[1], xe = _[2], pe = ip(ce, ye, xe), Se = pe[0], Te = pe[1], De = pe[2];
      return np(Se, Te, De);
    }, ap = sp, op = v.unpack, lp = bl, cp = Ll, hp = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      y = op(y, "lch");
      var _ = y[0], ce = y[1], ye = y[2], xe = lp(_, ce, ye), pe = xe[0], Se = xe[1], Te = xe[2], De = cp(pe, Se, Te), je = De[0], Ue = De[1], Ie = De[2];
      return [je, Ue, Ie, y.length > 3 ? y[3] : 1];
    }, dp = hp, up = v.unpack, fp = v.type, pp = K, jl = u, Il = E, gp = ap;
    jl.prototype.oklch = function() {
      return gp(this._rgb);
    }, pp.oklch = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      return new (Function.prototype.bind.apply(jl, [null].concat(y, ["oklch"])))();
    }, Il.format.oklch = dp, Il.autodetect.push({
      p: 3,
      test: function() {
        for (var y = [], N = arguments.length; N--; )
          y[N] = arguments[N];
        if (y = up(y, "oklch"), fp(y) === "array" && y.length === 3)
          return "oklch";
      }
    });
    var Fl = u, mp = v.type;
    Fl.prototype.alpha = function(y, N) {
      return N === void 0 && (N = !1), y !== void 0 && mp(y) === "number" ? N ? (this._rgb[3] = y, this) : new Fl([this._rgb[0], this._rgb[1], this._rgb[2], y], "rgb") : this._rgb[3];
    };
    var yp = u;
    yp.prototype.clipped = function() {
      return this._rgb._clipped || !1;
    };
    var bi = u, bp = fs;
    bi.prototype.darken = function(y) {
      y === void 0 && (y = 1);
      var N = this, _ = N.lab();
      return _[0] -= bp.Kn * y, new bi(_, "lab").alpha(N.alpha(), !0);
    }, bi.prototype.brighten = function(y) {
      return y === void 0 && (y = 1), this.darken(-y);
    }, bi.prototype.darker = bi.prototype.darken, bi.prototype.brighter = bi.prototype.brighten;
    var vp = u;
    vp.prototype.get = function(y) {
      var N = y.split("."), _ = N[0], ce = N[1], ye = this[_]();
      if (ce) {
        var xe = _.indexOf(ce) - (_.substr(0, 2) === "ok" ? 2 : 0);
        if (xe > -1)
          return ye[xe];
        throw new Error("unknown channel " + ce + " in mode " + _);
      } else
        return ye;
    };
    var zi = u, xp = v.type, wp = Math.pow, kp = 1e-7, Cp = 20;
    zi.prototype.luminance = function(y) {
      if (y !== void 0 && xp(y) === "number") {
        if (y === 0)
          return new zi([0, 0, 0, this._rgb[3]], "rgb");
        if (y === 1)
          return new zi([255, 255, 255, this._rgb[3]], "rgb");
        var N = this.luminance(), _ = "rgb", ce = Cp, ye = function(pe, Se) {
          var Te = pe.interpolate(Se, 0.5, _), De = Te.luminance();
          return Math.abs(y - De) < kp || !ce-- ? Te : De > y ? ye(pe, Te) : ye(Te, Se);
        }, xe = (N > y ? ye(new zi([0, 0, 0]), this) : ye(this, new zi([255, 255, 255]))).rgb();
        return new zi(xe.concat([this._rgb[3]]));
      }
      return Sp.apply(void 0, this._rgb.slice(0, 3));
    };
    var Sp = function(y, N, _) {
      return y = Ta(y), N = Ta(N), _ = Ta(_), 0.2126 * y + 0.7152 * N + 0.0722 * _;
    }, Ta = function(y) {
      return y /= 255, y <= 0.03928 ? y / 12.92 : wp((y + 0.055) / 1.055, 2.4);
    }, fr = {}, Bl = u, Wl = v.type, bs = fr, Hl = function(y, N, _) {
      _ === void 0 && (_ = 0.5);
      for (var ce = [], ye = arguments.length - 3; ye-- > 0; )
        ce[ye] = arguments[ye + 3];
      var xe = ce[0] || "lrgb";
      if (!bs[xe] && !ce.length && (xe = Object.keys(bs)[0]), !bs[xe])
        throw new Error("interpolation mode " + xe + " is not defined");
      return Wl(y) !== "object" && (y = new Bl(y)), Wl(N) !== "object" && (N = new Bl(N)), bs[xe](y, N, _).alpha(y.alpha() + _ * (N.alpha() - y.alpha()));
    }, zl = u, Mp = Hl;
    zl.prototype.mix = zl.prototype.interpolate = function(y, N) {
      N === void 0 && (N = 0.5);
      for (var _ = [], ce = arguments.length - 2; ce-- > 0; )
        _[ce] = arguments[ce + 2];
      return Mp.apply(void 0, [this, y, N].concat(_));
    };
    var Yl = u;
    Yl.prototype.premultiply = function(y) {
      y === void 0 && (y = !1);
      var N = this._rgb, _ = N[3];
      return y ? (this._rgb = [N[0] * _, N[1] * _, N[2] * _, _], this) : new Yl([N[0] * _, N[1] * _, N[2] * _, _], "rgb");
    };
    var Oa = u, Tp = fs;
    Oa.prototype.saturate = function(y) {
      y === void 0 && (y = 1);
      var N = this, _ = N.lch();
      return _[1] += Tp.Kn * y, _[1] < 0 && (_[1] = 0), new Oa(_, "lch").alpha(N.alpha(), !0);
    }, Oa.prototype.desaturate = function(y) {
      return y === void 0 && (y = 1), this.saturate(-y);
    };
    var Ul = u, Gl = v.type;
    Ul.prototype.set = function(y, N, _) {
      _ === void 0 && (_ = !1);
      var ce = y.split("."), ye = ce[0], xe = ce[1], pe = this[ye]();
      if (xe) {
        var Se = ye.indexOf(xe) - (ye.substr(0, 2) === "ok" ? 2 : 0);
        if (Se > -1) {
          if (Gl(N) == "string")
            switch (N.charAt(0)) {
              case "+":
                pe[Se] += +N;
                break;
              case "-":
                pe[Se] += +N;
                break;
              case "*":
                pe[Se] *= +N.substr(1);
                break;
              case "/":
                pe[Se] /= +N.substr(1);
                break;
              default:
                pe[Se] = +N;
            }
          else if (Gl(N) === "number")
            pe[Se] = N;
          else
            throw new Error("unsupported value for Color.set");
          var Te = new Ul(pe, ye);
          return _ ? (this._rgb = Te._rgb, this) : Te;
        }
        throw new Error("unknown channel " + xe + " in mode " + ye);
      } else
        return pe;
    };
    var Op = u, Ap = function(y, N, _) {
      var ce = y._rgb, ye = N._rgb;
      return new Op(
        ce[0] + _ * (ye[0] - ce[0]),
        ce[1] + _ * (ye[1] - ce[1]),
        ce[2] + _ * (ye[2] - ce[2]),
        "rgb"
      );
    };
    fr.rgb = Ap;
    var Ep = u, Aa = Math.sqrt, Yi = Math.pow, Pp = function(y, N, _) {
      var ce = y._rgb, ye = ce[0], xe = ce[1], pe = ce[2], Se = N._rgb, Te = Se[0], De = Se[1], je = Se[2];
      return new Ep(
        Aa(Yi(ye, 2) * (1 - _) + Yi(Te, 2) * _),
        Aa(Yi(xe, 2) * (1 - _) + Yi(De, 2) * _),
        Aa(Yi(pe, 2) * (1 - _) + Yi(je, 2) * _),
        "rgb"
      );
    };
    fr.lrgb = Pp;
    var Dp = u, Lp = function(y, N, _) {
      var ce = y.lab(), ye = N.lab();
      return new Dp(
        ce[0] + _ * (ye[0] - ce[0]),
        ce[1] + _ * (ye[1] - ce[1]),
        ce[2] + _ * (ye[2] - ce[2]),
        "lab"
      );
    };
    fr.lab = Lp;
    var ql = u, Ui = function(y, N, _, ce) {
      var ye, xe, pe, Se;
      ce === "hsl" ? (pe = y.hsl(), Se = N.hsl()) : ce === "hsv" ? (pe = y.hsv(), Se = N.hsv()) : ce === "hcg" ? (pe = y.hcg(), Se = N.hcg()) : ce === "hsi" ? (pe = y.hsi(), Se = N.hsi()) : ce === "lch" || ce === "hcl" ? (ce = "hcl", pe = y.hcl(), Se = N.hcl()) : ce === "oklch" && (pe = y.oklch().reverse(), Se = N.oklch().reverse());
      var Te, De, je, Ue, Ie, Ke;
      (ce.substr(0, 1) === "h" || ce === "oklch") && (ye = pe, Te = ye[0], je = ye[1], Ie = ye[2], xe = Se, De = xe[0], Ue = xe[1], Ke = xe[2]);
      var Qe, ht, gt, vt;
      return !isNaN(Te) && !isNaN(De) ? (De > Te && De - Te > 180 ? vt = De - (Te + 360) : De < Te && Te - De > 180 ? vt = De + 360 - Te : vt = De - Te, ht = Te + _ * vt) : isNaN(Te) ? isNaN(De) ? ht = Number.NaN : (ht = De, (Ie == 1 || Ie == 0) && ce != "hsv" && (Qe = Ue)) : (ht = Te, (Ke == 1 || Ke == 0) && ce != "hsv" && (Qe = je)), Qe === void 0 && (Qe = je + _ * (Ue - je)), gt = Ie + _ * (Ke - Ie), ce === "oklch" ? new ql([gt, Qe, ht], ce) : new ql([ht, Qe, gt], ce);
    }, Rp = Ui, Xl = function(y, N, _) {
      return Rp(y, N, _, "lch");
    };
    fr.lch = Xl, fr.hcl = Xl;
    var Np = u, jp = function(y, N, _) {
      var ce = y.num(), ye = N.num();
      return new Np(ce + _ * (ye - ce), "num");
    };
    fr.num = jp;
    var Ip = Ui, Fp = function(y, N, _) {
      return Ip(y, N, _, "hcg");
    };
    fr.hcg = Fp;
    var Bp = Ui, Wp = function(y, N, _) {
      return Bp(y, N, _, "hsi");
    };
    fr.hsi = Wp;
    var Hp = Ui, zp = function(y, N, _) {
      return Hp(y, N, _, "hsl");
    };
    fr.hsl = zp;
    var Yp = Ui, Up = function(y, N, _) {
      return Yp(y, N, _, "hsv");
    };
    fr.hsv = Up;
    var Gp = u, qp = function(y, N, _) {
      var ce = y.oklab(), ye = N.oklab();
      return new Gp(
        ce[0] + _ * (ye[0] - ce[0]),
        ce[1] + _ * (ye[1] - ce[1]),
        ce[2] + _ * (ye[2] - ce[2]),
        "oklab"
      );
    };
    fr.oklab = qp;
    var Xp = Ui, Qp = function(y, N, _) {
      return Xp(y, N, _, "oklch");
    };
    fr.oklch = Qp;
    var Ea = u, Vp = v.clip_rgb, Pa = Math.pow, Da = Math.sqrt, La = Math.PI, Ql = Math.cos, Vl = Math.sin, Kp = Math.atan2, Zp = function(y, N, _) {
      N === void 0 && (N = "lrgb"), _ === void 0 && (_ = null);
      var ce = y.length;
      _ || (_ = Array.from(new Array(ce)).map(function() {
        return 1;
      }));
      var ye = ce / _.reduce(function(ht, gt) {
        return ht + gt;
      });
      if (_.forEach(function(ht, gt) {
        _[gt] *= ye;
      }), y = y.map(function(ht) {
        return new Ea(ht);
      }), N === "lrgb")
        return Jp(y, _);
      for (var xe = y.shift(), pe = xe.get(N), Se = [], Te = 0, De = 0, je = 0; je < pe.length; je++)
        if (pe[je] = (pe[je] || 0) * _[0], Se.push(isNaN(pe[je]) ? 0 : _[0]), N.charAt(je) === "h" && !isNaN(pe[je])) {
          var Ue = pe[je] / 180 * La;
          Te += Ql(Ue) * _[0], De += Vl(Ue) * _[0];
        }
      var Ie = xe.alpha() * _[0];
      y.forEach(function(ht, gt) {
        var vt = ht.get(N);
        Ie += ht.alpha() * _[gt + 1];
        for (var Ct = 0; Ct < pe.length; Ct++)
          if (!isNaN(vt[Ct]))
            if (Se[Ct] += _[gt + 1], N.charAt(Ct) === "h") {
              var er = vt[Ct] / 180 * La;
              Te += Ql(er) * _[gt + 1], De += Vl(er) * _[gt + 1];
            } else
              pe[Ct] += vt[Ct] * _[gt + 1];
      });
      for (var Ke = 0; Ke < pe.length; Ke++)
        if (N.charAt(Ke) === "h") {
          for (var Qe = Kp(De / Se[Ke], Te / Se[Ke]) / La * 180; Qe < 0; )
            Qe += 360;
          for (; Qe >= 360; )
            Qe -= 360;
          pe[Ke] = Qe;
        } else
          pe[Ke] = pe[Ke] / Se[Ke];
      return Ie /= ce, new Ea(pe, N).alpha(Ie > 0.99999 ? 1 : Ie, !0);
    }, Jp = function(y, N) {
      for (var _ = y.length, ce = [0, 0, 0, 0], ye = 0; ye < y.length; ye++) {
        var xe = y[ye], pe = N[ye] / _, Se = xe._rgb;
        ce[0] += Pa(Se[0], 2) * pe, ce[1] += Pa(Se[1], 2) * pe, ce[2] += Pa(Se[2], 2) * pe, ce[3] += Se[3] * pe;
      }
      return ce[0] = Da(ce[0]), ce[1] = Da(ce[1]), ce[2] = Da(ce[2]), ce[3] > 0.9999999 && (ce[3] = 1), new Ea(Vp(ce));
    }, Cr = K, Gi = v.type, _p = Math.pow, Ra = function(y) {
      var N = "rgb", _ = Cr("#ccc"), ce = 0, ye = [0, 1], xe = [], pe = [0, 0], Se = !1, Te = [], De = !1, je = 0, Ue = 1, Ie = !1, Ke = {}, Qe = !0, ht = 1, gt = function(Fe) {
        if (Fe = Fe || ["#fff", "#000"], Fe && Gi(Fe) === "string" && Cr.brewer && Cr.brewer[Fe.toLowerCase()] && (Fe = Cr.brewer[Fe.toLowerCase()]), Gi(Fe) === "array") {
          Fe.length === 1 && (Fe = [Fe[0], Fe[0]]), Fe = Fe.slice(0);
          for (var rt = 0; rt < Fe.length; rt++)
            Fe[rt] = Cr(Fe[rt]);
          xe.length = 0;
          for (var pt = 0; pt < Fe.length; pt++)
            xe.push(pt / (Fe.length - 1));
        }
        return lr(), Te = Fe;
      }, vt = function(Fe) {
        if (Se != null) {
          for (var rt = Se.length - 1, pt = 0; pt < rt && Fe >= Se[pt]; )
            pt++;
          return pt - 1;
        }
        return 0;
      }, Ct = function(Fe) {
        return Fe;
      }, er = function(Fe) {
        return Fe;
      }, Zt = function(Fe, rt) {
        var pt, dt;
        if (rt == null && (rt = !1), isNaN(Fe) || Fe === null)
          return _;
        if (rt)
          dt = Fe;
        else if (Se && Se.length > 2) {
          var tr = vt(Fe);
          dt = tr / (Se.length - 2);
        } else
          Ue !== je ? dt = (Fe - je) / (Ue - je) : dt = 1;
        dt = er(dt), rt || (dt = Ct(dt)), ht !== 1 && (dt = _p(dt, ht)), dt = pe[0] + dt * (1 - pe[0] - pe[1]), dt = Math.min(1, Math.max(0, dt));
        var Lt = Math.floor(dt * 1e4);
        if (Qe && Ke[Lt])
          pt = Ke[Lt];
        else {
          if (Gi(Te) === "array")
            for (var xt = 0; xt < xe.length; xt++) {
              var Mt = xe[xt];
              if (dt <= Mt) {
                pt = Te[xt];
                break;
              }
              if (dt >= Mt && xt === xe.length - 1) {
                pt = Te[xt];
                break;
              }
              if (dt > Mt && dt < xe[xt + 1]) {
                dt = (dt - Mt) / (xe[xt + 1] - Mt), pt = Cr.interpolate(Te[xt], Te[xt + 1], dt, N);
                break;
              }
            }
          else
            Gi(Te) === "function" && (pt = Te(dt));
          Qe && (Ke[Lt] = pt);
        }
        return pt;
      }, lr = function() {
        return Ke = {};
      };
      gt(y);
      var yt = function(Fe) {
        var rt = Cr(Zt(Fe));
        return De && rt[De] ? rt[De]() : rt;
      };
      return yt.classes = function(Fe) {
        if (Fe != null) {
          if (Gi(Fe) === "array")
            Se = Fe, ye = [Fe[0], Fe[Fe.length - 1]];
          else {
            var rt = Cr.analyze(ye);
            Fe === 0 ? Se = [rt.min, rt.max] : Se = Cr.limits(rt, "e", Fe);
          }
          return yt;
        }
        return Se;
      }, yt.domain = function(Fe) {
        if (!arguments.length)
          return ye;
        je = Fe[0], Ue = Fe[Fe.length - 1], xe = [];
        var rt = Te.length;
        if (Fe.length === rt && je !== Ue)
          for (var pt = 0, dt = Array.from(Fe); pt < dt.length; pt += 1) {
            var tr = dt[pt];
            xe.push((tr - je) / (Ue - je));
          }
        else {
          for (var Lt = 0; Lt < rt; Lt++)
            xe.push(Lt / (rt - 1));
          if (Fe.length > 2) {
            var xt = Fe.map(function(Tt, Ot) {
              return Ot / (Fe.length - 1);
            }), Mt = Fe.map(function(Tt) {
              return (Tt - je) / (Ue - je);
            });
            Mt.every(function(Tt, Ot) {
              return xt[Ot] === Tt;
            }) || (er = function(Tt) {
              if (Tt <= 0 || Tt >= 1)
                return Tt;
              for (var Ot = 0; Tt >= Mt[Ot + 1]; )
                Ot++;
              var Mr = (Tt - Mt[Ot]) / (Mt[Ot + 1] - Mt[Ot]), ti = xt[Ot] + Mr * (xt[Ot + 1] - xt[Ot]);
              return ti;
            });
          }
        }
        return ye = [je, Ue], yt;
      }, yt.mode = function(Fe) {
        return arguments.length ? (N = Fe, lr(), yt) : N;
      }, yt.range = function(Fe, rt) {
        return gt(Fe), yt;
      }, yt.out = function(Fe) {
        return De = Fe, yt;
      }, yt.spread = function(Fe) {
        return arguments.length ? (ce = Fe, yt) : ce;
      }, yt.correctLightness = function(Fe) {
        return Fe == null && (Fe = !0), Ie = Fe, lr(), Ie ? Ct = function(rt) {
          for (var pt = Zt(0, !0).lab()[0], dt = Zt(1, !0).lab()[0], tr = pt > dt, Lt = Zt(rt, !0).lab()[0], xt = pt + (dt - pt) * rt, Mt = Lt - xt, Tt = 0, Ot = 1, Mr = 20; Math.abs(Mt) > 0.01 && Mr-- > 0; )
            (function() {
              return tr && (Mt *= -1), Mt < 0 ? (Tt = rt, rt += (Ot - rt) * 0.5) : (Ot = rt, rt += (Tt - rt) * 0.5), Lt = Zt(rt, !0).lab()[0], Mt = Lt - xt;
            })();
          return rt;
        } : Ct = function(rt) {
          return rt;
        }, yt;
      }, yt.padding = function(Fe) {
        return Fe != null ? (Gi(Fe) === "number" && (Fe = [Fe, Fe]), pe = Fe, yt) : pe;
      }, yt.colors = function(Fe, rt) {
        arguments.length < 2 && (rt = "hex");
        var pt = [];
        if (arguments.length === 0)
          pt = Te.slice(0);
        else if (Fe === 1)
          pt = [yt(0.5)];
        else if (Fe > 1) {
          var dt = ye[0], tr = ye[1] - dt;
          pt = $p(0, Fe, !1).map(function(Ot) {
            return yt(dt + Ot / (Fe - 1) * tr);
          });
        } else {
          y = [];
          var Lt = [];
          if (Se && Se.length > 2)
            for (var xt = 1, Mt = Se.length, Tt = 1 <= Mt; Tt ? xt < Mt : xt > Mt; Tt ? xt++ : xt--)
              Lt.push((Se[xt - 1] + Se[xt]) * 0.5);
          else
            Lt = ye;
          pt = Lt.map(function(Ot) {
            return yt(Ot);
          });
        }
        return Cr[rt] && (pt = pt.map(function(Ot) {
          return Ot[rt]();
        })), pt;
      }, yt.cache = function(Fe) {
        return Fe != null ? (Qe = Fe, yt) : Qe;
      }, yt.gamma = function(Fe) {
        return Fe != null ? (ht = Fe, yt) : ht;
      }, yt.nodata = function(Fe) {
        return Fe != null ? (_ = Cr(Fe), yt) : _;
      }, yt;
    };
    function $p(y, N, _) {
      for (var ce = [], ye = y < N, xe = _ ? ye ? N + 1 : N - 1 : N, pe = y; ye ? pe < xe : pe > xe; ye ? pe++ : pe--)
        ce.push(pe);
      return ce;
    }
    var Tn = u, eg = Ra, tg = function(y) {
      for (var N = [1, 1], _ = 1; _ < y; _++) {
        for (var ce = [1], ye = 1; ye <= N.length; ye++)
          ce[ye] = (N[ye] || 0) + N[ye - 1];
        N = ce;
      }
      return N;
    }, rg = function(y) {
      var N, _, ce, ye, xe, pe, Se;
      if (y = y.map(function(Ie) {
        return new Tn(Ie);
      }), y.length === 2)
        N = y.map(function(Ie) {
          return Ie.lab();
        }), xe = N[0], pe = N[1], ye = function(Ie) {
          var Ke = [0, 1, 2].map(function(Qe) {
            return xe[Qe] + Ie * (pe[Qe] - xe[Qe]);
          });
          return new Tn(Ke, "lab");
        };
      else if (y.length === 3)
        _ = y.map(function(Ie) {
          return Ie.lab();
        }), xe = _[0], pe = _[1], Se = _[2], ye = function(Ie) {
          var Ke = [0, 1, 2].map(function(Qe) {
            return (1 - Ie) * (1 - Ie) * xe[Qe] + 2 * (1 - Ie) * Ie * pe[Qe] + Ie * Ie * Se[Qe];
          });
          return new Tn(Ke, "lab");
        };
      else if (y.length === 4) {
        var Te;
        ce = y.map(function(Ie) {
          return Ie.lab();
        }), xe = ce[0], pe = ce[1], Se = ce[2], Te = ce[3], ye = function(Ie) {
          var Ke = [0, 1, 2].map(function(Qe) {
            return (1 - Ie) * (1 - Ie) * (1 - Ie) * xe[Qe] + 3 * (1 - Ie) * (1 - Ie) * Ie * pe[Qe] + 3 * (1 - Ie) * Ie * Ie * Se[Qe] + Ie * Ie * Ie * Te[Qe];
          });
          return new Tn(Ke, "lab");
        };
      } else if (y.length >= 5) {
        var De, je, Ue;
        De = y.map(function(Ie) {
          return Ie.lab();
        }), Ue = y.length - 1, je = tg(Ue), ye = function(Ie) {
          var Ke = 1 - Ie, Qe = [0, 1, 2].map(function(ht) {
            return De.reduce(function(gt, vt, Ct) {
              return gt + je[Ct] * Math.pow(Ke, Ue - Ct) * Math.pow(Ie, Ct) * vt[ht];
            }, 0);
          });
          return new Tn(Qe, "lab");
        };
      } else
        throw new RangeError("No point in running bezier with only one color.");
      return ye;
    }, ig = function(y) {
      var N = rg(y);
      return N.scale = function() {
        return eg(N);
      }, N;
    }, Na = K, Sr = function(y, N, _) {
      if (!Sr[_])
        throw new Error("unknown blend mode " + _);
      return Sr[_](y, N);
    }, $r = function(y) {
      return function(N, _) {
        var ce = Na(_).rgb(), ye = Na(N).rgb();
        return Na.rgb(y(ce, ye));
      };
    }, ei = function(y) {
      return function(N, _) {
        var ce = [];
        return ce[0] = y(N[0], _[0]), ce[1] = y(N[1], _[1]), ce[2] = y(N[2], _[2]), ce;
      };
    }, ng = function(y) {
      return y;
    }, sg = function(y, N) {
      return y * N / 255;
    }, ag = function(y, N) {
      return y > N ? N : y;
    }, og = function(y, N) {
      return y > N ? y : N;
    }, lg = function(y, N) {
      return 255 * (1 - (1 - y / 255) * (1 - N / 255));
    }, cg = function(y, N) {
      return N < 128 ? 2 * y * N / 255 : 255 * (1 - 2 * (1 - y / 255) * (1 - N / 255));
    }, hg = function(y, N) {
      return 255 * (1 - (1 - N / 255) / (y / 255));
    }, dg = function(y, N) {
      return y === 255 ? 255 : (y = 255 * (N / 255) / (1 - y / 255), y > 255 ? 255 : y);
    };
    Sr.normal = $r(ei(ng)), Sr.multiply = $r(ei(sg)), Sr.screen = $r(ei(lg)), Sr.overlay = $r(ei(cg)), Sr.darken = $r(ei(ag)), Sr.lighten = $r(ei(og)), Sr.dodge = $r(ei(dg)), Sr.burn = $r(ei(hg));
    for (var ug = Sr, ja = v.type, fg = v.clip_rgb, pg = v.TWOPI, gg = Math.pow, mg = Math.sin, yg = Math.cos, Kl = K, bg = function(y, N, _, ce, ye) {
      y === void 0 && (y = 300), N === void 0 && (N = -1.5), _ === void 0 && (_ = 1), ce === void 0 && (ce = 1), ye === void 0 && (ye = [0, 1]);
      var xe = 0, pe;
      ja(ye) === "array" ? pe = ye[1] - ye[0] : (pe = 0, ye = [ye, ye]);
      var Se = function(Te) {
        var De = pg * ((y + 120) / 360 + N * Te), je = gg(ye[0] + pe * Te, ce), Ue = xe !== 0 ? _[0] + Te * xe : _, Ie = Ue * je * (1 - je) / 2, Ke = yg(De), Qe = mg(De), ht = je + Ie * (-0.14861 * Ke + 1.78277 * Qe), gt = je + Ie * (-0.29227 * Ke - 0.90649 * Qe), vt = je + Ie * (1.97294 * Ke);
        return Kl(fg([ht * 255, gt * 255, vt * 255, 1]));
      };
      return Se.start = function(Te) {
        return Te == null ? y : (y = Te, Se);
      }, Se.rotations = function(Te) {
        return Te == null ? N : (N = Te, Se);
      }, Se.gamma = function(Te) {
        return Te == null ? ce : (ce = Te, Se);
      }, Se.hue = function(Te) {
        return Te == null ? _ : (_ = Te, ja(_) === "array" ? (xe = _[1] - _[0], xe === 0 && (_ = _[1])) : xe = 0, Se);
      }, Se.lightness = function(Te) {
        return Te == null ? ye : (ja(Te) === "array" ? (ye = Te, pe = Te[1] - Te[0]) : (ye = [Te, Te], pe = 0), Se);
      }, Se.scale = function() {
        return Kl.scale(Se);
      }, Se.hue(_), Se;
    }, vg = u, xg = "0123456789abcdef", wg = Math.floor, kg = Math.random, Cg = function() {
      for (var y = "#", N = 0; N < 6; N++)
        y += xg.charAt(wg(kg() * 16));
      return new vg(y, "hex");
    }, Ia = Y, Zl = Math.log, Sg = Math.pow, Mg = Math.floor, Tg = Math.abs, Jl = function(y, N) {
      N === void 0 && (N = null);
      var _ = {
        min: Number.MAX_VALUE,
        max: Number.MAX_VALUE * -1,
        sum: 0,
        values: [],
        count: 0
      };
      return Ia(y) === "object" && (y = Object.values(y)), y.forEach(function(ce) {
        N && Ia(ce) === "object" && (ce = ce[N]), ce != null && !isNaN(ce) && (_.values.push(ce), _.sum += ce, ce < _.min && (_.min = ce), ce > _.max && (_.max = ce), _.count += 1);
      }), _.domain = [_.min, _.max], _.limits = function(ce, ye) {
        return _l(_, ce, ye);
      }, _;
    }, _l = function(y, N, _) {
      N === void 0 && (N = "equal"), _ === void 0 && (_ = 7), Ia(y) == "array" && (y = Jl(y));
      var ce = y.min, ye = y.max, xe = y.values.sort(function(Ba, Wa) {
        return Ba - Wa;
      });
      if (_ === 1)
        return [ce, ye];
      var pe = [];
      if (N.substr(0, 1) === "c" && (pe.push(ce), pe.push(ye)), N.substr(0, 1) === "e") {
        pe.push(ce);
        for (var Se = 1; Se < _; Se++)
          pe.push(ce + Se / _ * (ye - ce));
        pe.push(ye);
      } else if (N.substr(0, 1) === "l") {
        if (ce <= 0)
          throw new Error("Logarithmic scales are only possible for values > 0");
        var Te = Math.LOG10E * Zl(ce), De = Math.LOG10E * Zl(ye);
        pe.push(ce);
        for (var je = 1; je < _; je++)
          pe.push(Sg(10, Te + je / _ * (De - Te)));
        pe.push(ye);
      } else if (N.substr(0, 1) === "q") {
        pe.push(ce);
        for (var Ue = 1; Ue < _; Ue++) {
          var Ie = (xe.length - 1) * Ue / _, Ke = Mg(Ie);
          if (Ke === Ie)
            pe.push(xe[Ke]);
          else {
            var Qe = Ie - Ke;
            pe.push(xe[Ke] * (1 - Qe) + xe[Ke + 1] * Qe);
          }
        }
        pe.push(ye);
      } else if (N.substr(0, 1) === "k") {
        var ht, gt = xe.length, vt = new Array(gt), Ct = new Array(_), er = !0, Zt = 0, lr = null;
        lr = [], lr.push(ce);
        for (var yt = 1; yt < _; yt++)
          lr.push(ce + yt / _ * (ye - ce));
        for (lr.push(ye); er; ) {
          for (var Fe = 0; Fe < _; Fe++)
            Ct[Fe] = 0;
          for (var rt = 0; rt < gt; rt++)
            for (var pt = xe[rt], dt = Number.MAX_VALUE, tr = void 0, Lt = 0; Lt < _; Lt++) {
              var xt = Tg(lr[Lt] - pt);
              xt < dt && (dt = xt, tr = Lt), Ct[tr]++, vt[rt] = tr;
            }
          for (var Mt = new Array(_), Tt = 0; Tt < _; Tt++)
            Mt[Tt] = null;
          for (var Ot = 0; Ot < gt; Ot++)
            ht = vt[Ot], Mt[ht] === null ? Mt[ht] = xe[Ot] : Mt[ht] += xe[Ot];
          for (var Mr = 0; Mr < _; Mr++)
            Mt[Mr] *= 1 / Ct[Mr];
          er = !1;
          for (var ti = 0; ti < _; ti++)
            if (Mt[ti] !== lr[ti]) {
              er = !0;
              break;
            }
          lr = Mt, Zt++, Zt > 200 && (er = !1);
        }
        for (var ri = {}, qi = 0; qi < _; qi++)
          ri[qi] = [];
        for (var Xi = 0; Xi < gt; Xi++)
          ht = vt[Xi], ri[ht].push(xe[Xi]);
        for (var qr = [], vi = 0; vi < _; vi++)
          qr.push(ri[vi][0]), qr.push(ri[vi][ri[vi].length - 1]);
        qr = qr.sort(function(Ba, Wa) {
          return Ba - Wa;
        }), pe.push(qr[0]);
        for (var On = 1; On < qr.length; On += 2) {
          var xi = qr[On];
          !isNaN(xi) && pe.indexOf(xi) === -1 && pe.push(xi);
        }
      }
      return pe;
    }, $l = { analyze: Jl, limits: _l }, ec = u, Og = function(y, N) {
      y = new ec(y), N = new ec(N);
      var _ = y.luminance(), ce = N.luminance();
      return _ > ce ? (_ + 0.05) / (ce + 0.05) : (ce + 0.05) / (_ + 0.05);
    }, tc = u, Gr = Math.sqrt, qt = Math.pow, Ag = Math.min, Eg = Math.max, rc = Math.atan2, ic = Math.abs, vs = Math.cos, nc = Math.sin, Pg = Math.exp, sc = Math.PI, Dg = function(y, N, _, ce, ye) {
      _ === void 0 && (_ = 1), ce === void 0 && (ce = 1), ye === void 0 && (ye = 1);
      var xe = function(xi) {
        return 360 * xi / (2 * sc);
      }, pe = function(xi) {
        return 2 * sc * xi / 360;
      };
      y = new tc(y), N = new tc(N);
      var Se = Array.from(y.lab()), Te = Se[0], De = Se[1], je = Se[2], Ue = Array.from(N.lab()), Ie = Ue[0], Ke = Ue[1], Qe = Ue[2], ht = (Te + Ie) / 2, gt = Gr(qt(De, 2) + qt(je, 2)), vt = Gr(qt(Ke, 2) + qt(Qe, 2)), Ct = (gt + vt) / 2, er = 0.5 * (1 - Gr(qt(Ct, 7) / (qt(Ct, 7) + qt(25, 7)))), Zt = De * (1 + er), lr = Ke * (1 + er), yt = Gr(qt(Zt, 2) + qt(je, 2)), Fe = Gr(qt(lr, 2) + qt(Qe, 2)), rt = (yt + Fe) / 2, pt = xe(rc(je, Zt)), dt = xe(rc(Qe, lr)), tr = pt >= 0 ? pt : pt + 360, Lt = dt >= 0 ? dt : dt + 360, xt = ic(tr - Lt) > 180 ? (tr + Lt + 360) / 2 : (tr + Lt) / 2, Mt = 1 - 0.17 * vs(pe(xt - 30)) + 0.24 * vs(pe(2 * xt)) + 0.32 * vs(pe(3 * xt + 6)) - 0.2 * vs(pe(4 * xt - 63)), Tt = Lt - tr;
      Tt = ic(Tt) <= 180 ? Tt : Lt <= tr ? Tt + 360 : Tt - 360, Tt = 2 * Gr(yt * Fe) * nc(pe(Tt) / 2);
      var Ot = Ie - Te, Mr = Fe - yt, ti = 1 + 0.015 * qt(ht - 50, 2) / Gr(20 + qt(ht - 50, 2)), ri = 1 + 0.045 * rt, qi = 1 + 0.015 * rt * Mt, Xi = 30 * Pg(-qt((xt - 275) / 25, 2)), qr = 2 * Gr(qt(rt, 7) / (qt(rt, 7) + qt(25, 7))), vi = -qr * nc(2 * pe(Xi)), On = Gr(qt(Ot / (_ * ti), 2) + qt(Mr / (ce * ri), 2) + qt(Tt / (ye * qi), 2) + vi * (Mr / (ce * ri)) * (Tt / (ye * qi)));
      return Eg(0, Ag(100, On));
    }, ac = u, Lg = function(y, N, _) {
      _ === void 0 && (_ = "lab"), y = new ac(y), N = new ac(N);
      var ce = y.get(_), ye = N.get(_), xe = 0;
      for (var pe in ce) {
        var Se = (ce[pe] || 0) - (ye[pe] || 0);
        xe += Se * Se;
      }
      return Math.sqrt(xe);
    }, Rg = u, Ng = function() {
      for (var y = [], N = arguments.length; N--; )
        y[N] = arguments[N];
      try {
        return new (Function.prototype.bind.apply(Rg, [null].concat(y)))(), !0;
      } catch {
        return !1;
      }
    }, oc = K, lc = Ra, jg = {
      cool: function() {
        return lc([oc.hsl(180, 1, 0.9), oc.hsl(250, 0.7, 0.4)]);
      },
      hot: function() {
        return lc(["#000", "#f00", "#ff0", "#fff"]).mode("rgb");
      }
    }, xs = {
      // sequential
      OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
      PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
      BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
      Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
      BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
      YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
      YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
      Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
      RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
      Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
      YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
      Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
      GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
      Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
      YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
      PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
      Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
      PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
      Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
      // diverging
      Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
      RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
      RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
      PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
      PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
      RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
      BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
      RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
      PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
      // qualitative
      Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
      Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
      Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
      Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
      Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
      Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
      Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
      Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
    }, Fa = 0, cc = Object.keys(xs); Fa < cc.length; Fa += 1) {
      var hc = cc[Fa];
      xs[hc.toLowerCase()] = xs[hc];
    }
    var Ig = xs, Kt = K;
    Kt.average = Zp, Kt.bezier = ig, Kt.blend = ug, Kt.cubehelix = bg, Kt.mix = Kt.interpolate = Hl, Kt.random = Cg, Kt.scale = Ra, Kt.analyze = $l.analyze, Kt.contrast = Og, Kt.deltaE = Dg, Kt.distance = Lg, Kt.limits = $l.limits, Kt.valid = Ng, Kt.scales = jg, Kt.colors = kl, Kt.brewer = Ig;
    var Fg = Kt;
    return Fg;
  });
})(Vd);
var Fw = Vd.exports;
const Bw = /* @__PURE__ */ Qg(pw);
Object.defineProperty($o, "__esModule", { value: !0 });
var Ww = Fw, ar = Bw, vn = Qt;
function Kd(t) {
  return t && t.__esModule ? t : { default: t };
}
var Us = /* @__PURE__ */ Kd(Ww), zt = /* @__PURE__ */ Kd(vn);
function Gs() {
  return Gs = Object.assign ? Object.assign.bind() : function(t) {
    for (var r = 1; r < arguments.length; r++) {
      var e = arguments[r];
      for (var i in e)
        Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
    }
    return t;
  }, Gs.apply(this, arguments);
}
const Fn = "react-activity-calendar", Ka = 8, Zd = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], Hw = {
  months: Zd,
  weekdays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  totalCount: "{{count}} activities in {{year}}",
  legend: {
    less: "Less",
    more: "More"
  }
};
function zw() {
  const [t, r] = vn.useState("light"), e = (i) => r(i.matches ? "dark" : "light");
  return vn.useEffect(() => {
    const i = window.matchMedia("(prefers-color-scheme: dark)");
    return r(i.matches ? "dark" : "light"), i.addEventListener("change", e), () => {
      i.removeEventListener("change", e);
    };
  }, []), t;
}
const Yw = "(prefers-reduced-motion: reduce)";
function Uw() {
  const [t, r] = vn.useState(!0);
  return vn.useEffect(() => {
    const e = window.matchMedia(Yw);
    r(e.matches);
    const i = (n) => {
      r(n.matches);
    };
    return e.addEventListener("change", i), () => {
      e.removeEventListener("change", i);
    };
  }, []), t;
}
function Gw(t, r) {
  r === void 0 && (r = {});
  var e = r.insertAt;
  if (!(!t || typeof document > "u")) {
    var i = document.head || document.getElementsByTagName("head")[0], n = document.createElement("style");
    n.type = "text/css", e === "top" && i.firstChild ? i.insertBefore(n, i.firstChild) : i.appendChild(n), n.styleSheet ? n.styleSheet.cssText = t : n.appendChild(document.createTextNode(t));
  }
}
var qw = `.styles-module_container__GBNxC {
  width: max-content; /* Calendar should not grow */
  max-width: 100%; /* Do not remove - flexbox parents */
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.styles-module_container__GBNxC rect {
  stroke: rgba(0, 0, 0, 0.08);
  stroke-width: 1px;
  shape-rendering: geometricPrecision;
}

@media (prefers-color-scheme: dark) {
  .styles-module_container__GBNxC rect {
    stroke: rgba(255, 255, 255, 0.04);
  }
}

.styles-module_scrollContainer__-bJC8 {
  max-width: 100%;
  overflow-x: auto;
  overflow-y: hidden;
}

.styles-module_calendar__sT1ND {
  display: block; /* SVGs are inline-block by default */
  overflow: visible; /* Weekday labels are rendered left of the container */
}

.styles-module_calendar__sT1ND text {
  fill: currentColor;
}

.styles-module_footer__ZQ-Bl {
  display: flex;
  flex-wrap: wrap;
  gap: 4px 16px;
  white-space: nowrap;
}

.styles-module_legendColors__kFY2e {
  margin-left: auto;
  display: flex;
  align-items: center;
  gap: 3px;
}

@keyframes styles-module_loadingAnimation__V0w3h {
  0% {
    fill: var(--react-activity-calendar-loading);
  }
  50% {
    fill: var(--react-activity-calendar-loading-active);
  }
  100% {
    fill: var(--react-activity-calendar-loading);
  }
}
`, Vi = { container: "styles-module_container__GBNxC", scrollContainer: "styles-module_scrollContainer__-bJC8", calendar: "styles-module_calendar__sT1ND", footer: "styles-module_footer__ZQ-Bl", legendColors: "styles-module_legendColors__kFY2e", loadingAnimation: "styles-module_loadingAnimation__V0w3h" };
Gw(qw);
function Xw(t, r = 0) {
  if (t.length === 0)
    return [];
  const e = Qw(t), i = ar.parseISO(e[0].date), n = ar.getDay(i) === r ? i : ar.subWeeks(ar.nextDay(i, r), 1), s = [...Array(ar.differenceInCalendarDays(i, n)).fill(void 0), ...e], l = Math.ceil(s.length / 7);
  return Array(l).fill(void 0).map((m, A) => s.slice(A * 7, A * 7 + 7));
}
function Qw(t) {
  const r = {};
  for (const e of t)
    r[e.date] = e;
  return ar.eachDayOfInterval({
    start: ar.parseISO(t[0].date),
    end: ar.parseISO(t[t.length - 1].date)
  }).map((e) => {
    const i = ar.formatISO(e, {
      representation: "date"
    });
    return r[i] ? r[i] : {
      date: i,
      count: 0,
      level: 0
    };
  });
}
function Vw(t, r = Zd) {
  return t.reduce((e, i, n) => {
    const s = i.find((A) => A !== void 0);
    if (!s)
      throw new Error(`Unexpected error: Week ${n + 1} is empty: [${i}].`);
    const l = r[ar.getMonth(ar.parseISO(s.date))], m = e[e.length - 1];
    return n === 0 || m.label !== l ? [...e, {
      weekIndex: n,
      label: l
    }] : e;
  }, []).filter(({
    weekIndex: e
  }, i, n) => i === 0 ? n[1] && n[1].weekIndex - e >= 3 : i === n.length - 1 ? t.slice(e).length >= 3 : !0);
}
function wi(t, r) {
  return r ? `${Fn}__${t} ${r}` : `${Fn}__${t}`;
}
function Kw() {
  const t = (/* @__PURE__ */ new Date()).getFullYear();
  return ar.eachDayOfInterval({
    start: new Date(t, 0, 1),
    end: new Date(t, 11, 31)
  }).map((e) => ({
    date: ar.formatISO(e, {
      representation: "date"
    }),
    count: 0,
    level: 0
  }));
}
function Zw(t, r, e, i) {
  return t.reduce((n, s, l) => {
    if (l % 2 !== 0) {
      const m = (l + r) % 7, A = Math.ceil(Jw(e[m], i).width);
      return Math.max(n, A);
    }
    return n;
  }, 0);
}
function Jw(t, r) {
  if (typeof document > "u" || typeof window > "u")
    throw new Error("calcTextDimensions() requires browser APIs");
  if (r < 1)
    throw new RangeError("fontSize must be positive");
  if (t.length === 0)
    return {
      width: 0,
      height: 0
    };
  const e = "http://www.w3.org/2000/svg", i = document.createElementNS(e, "svg");
  i.style.position = "absolute", i.style.visibility = "hidden", i.style.fontFamily = window.getComputedStyle(document.body).fontFamily, i.style.fontSize = `${r}px`;
  const n = document.createElementNS(e, "text");
  n.textContent = t, i.appendChild(n), document.body.appendChild(i);
  const s = n.getBBox();
  return document.body.removeChild(i), {
    width: s.width,
    height: s.height
  };
}
function _w(t, r = 5) {
  const e = $w(r);
  return t ? (ek(t, r), t.light = t.light ?? e.light, t.dark = t.dark ?? e.dark, {
    light: Bc(t.light, r) ? t.light : qs(t.light, r),
    dark: Bc(t.dark, r) ? t.dark : qs(t.dark, r)
  }) : e;
}
function $w(t) {
  return {
    light: qs(["hsl(0, 0%, 92%)", "hsl(0, 0%, 26%)"], t),
    dark: qs(["hsl(0, 0%, 20%)", "hsl(0, 0%, 92%)"], t)
  };
}
function ek(t, r) {
  if (typeof t != "object" || t.light === void 0 && t.dark === void 0)
    throw new Error(`The theme object must contain at least one of the fields "light" and "dark" with exactly 2 or ${r} colors respectively.`);
  if (t.light) {
    const {
      length: e
    } = t.light;
    if (e !== 2 && e !== r)
      throw new Error(`theme.light must contain exactly 2 or ${r} colors, ${e} passed.`);
  }
  if (t.dark) {
    const {
      length: e
    } = t.dark;
    if (e !== 2 && e !== r)
      throw new Error(`theme.dark must contain exactly 2 or ${r} colors, ${e} passed.`);
  }
}
function Bc(t, r) {
  const e = t.find((i) => !Us.default.valid(i));
  if (e)
    throw new Error(`Invalid color "${e}" passed. All CSS color formats are accepted.`);
  return t.length === r;
}
function qs(t, r) {
  return Us.default.scale(t).mode("lch").colors(r);
}
const Jd = ({
  data: t,
  blockMargin: r = 4,
  blockRadius: e = 2,
  blockSize: i = 12,
  colorScheme: n = void 0,
  eventHandlers: s = {},
  fontSize: l = 14,
  hideColorLegend: m = !1,
  hideMonthLabels: A = !1,
  hideTotalCount: Y = !1,
  labels: q = void 0,
  maxLevel: T = 4,
  loading: B = !1,
  renderBlock: O = void 0,
  showWeekdayLabels: b = !1,
  style: v = {},
  theme: E = void 0,
  totalCount: M = void 0,
  weekStart: g = 0
  // Sunday
}) => {
  var G;
  T = Math.max(1, T);
  const C = _w(E, T + 1), j = zw(), D = C[n ?? j], u = !Uw();
  if (B && (t = Kw()), t.length === 0)
    return null;
  const R = ar.getYear(ar.parseISO((G = t[0]) == null ? void 0 : G.date)), K = Xw(t, g), I = Object.assign({}, Hw, q), z = A ? 0 : l + Ka, k = b ? Zw(K[0], g, I.weekdays, l) + Ka : void 0;
  function h() {
    return {
      width: K.length * (i + r) - r,
      height: z + (i + r) * 7 - r
    };
  }
  function F(x) {
    return Object.keys(s).reduce((Q, J) => ({
      ...Q,
      [J]: (ie) => {
        var te;
        return (te = s[J]) == null ? void 0 : te.call(s, ie)(x);
      }
    }), {});
  }
  function o() {
    return K.map((x, Q) => x.map((J, ie) => {
      if (!J)
        return null;
      if (J.level < 0 || J.level > T)
        throw new RangeError(`Provided activity level ${J.level} for ${J.date} is out of range. It must be between 0 and ${T}.`);
      const te = B && u ? {
        animation: `${Vi.loadingAnimation} 1.75s ease-in-out infinite`,
        animationDelay: `${Q * 20 + ie * 20}ms`
      } : void 0, $ = /* @__PURE__ */ zt.default.createElement("rect", Gs({}, F(J), {
        x: 0,
        y: z + (i + r) * ie,
        width: i,
        height: i,
        rx: e,
        ry: e,
        fill: D[J.level],
        "data-date": J.date,
        "data-level": J.level,
        style: te
      }));
      return /* @__PURE__ */ zt.default.createElement(vn.Fragment, {
        key: J.date
      }, O ? O($, J) : $);
    })).map((x, Q) => /* @__PURE__ */ zt.default.createElement("g", {
      key: Q,
      transform: `translate(${(i + r) * Q}, 0)`
    }, x));
  }
  function a() {
    var Q, J;
    if (Y && m)
      return null;
    const x = typeof M == "number" ? M : t.reduce((ie, te) => ie + te.count, 0);
    return /* @__PURE__ */ zt.default.createElement("footer", {
      className: wi("footer", Vi.footer),
      style: {
        marginLeft: k
      }
    }, B && /* @__PURE__ */ zt.default.createElement("div", null, " "), !B && !Y && /* @__PURE__ */ zt.default.createElement("div", {
      className: wi("count")
    }, I.totalCount ? I.totalCount.replace("{{count}}", String(x)).replace("{{year}}", String(R)) : `${x} activities in ${R}`), !B && !m && /* @__PURE__ */ zt.default.createElement("div", {
      className: wi("legend-colors", Vi.legendColors)
    }, /* @__PURE__ */ zt.default.createElement("span", {
      style: {
        marginRight: "0.4em"
      }
    }, ((Q = I == null ? void 0 : I.legend) == null ? void 0 : Q.less) ?? "Less"), Array(T + 1).fill(void 0).map((ie, te) => /* @__PURE__ */ zt.default.createElement("svg", {
      width: i,
      height: i,
      key: te
    }, /* @__PURE__ */ zt.default.createElement("rect", {
      width: i,
      height: i,
      fill: D[te],
      rx: e,
      ry: e
    }))), /* @__PURE__ */ zt.default.createElement("span", {
      style: {
        marginLeft: "0.4em"
      }
    }, ((J = I == null ? void 0 : I.legend) == null ? void 0 : J.more) ?? "More")));
  }
  function c() {
    return !b && A ? null : /* @__PURE__ */ zt.default.createElement(zt.default.Fragment, null, b && /* @__PURE__ */ zt.default.createElement("g", {
      className: wi("legend-weekday")
    }, K[0].map((x, Q) => {
      if (Q % 2 === 0)
        return null;
      const J = (Q + g) % 7;
      return /* @__PURE__ */ zt.default.createElement("text", {
        x: -Ka,
        y: z + (i + r) * Q + i / 2,
        dominantBaseline: "middle",
        textAnchor: "end",
        key: Q
      }, I.weekdays[J]);
    })), !A && /* @__PURE__ */ zt.default.createElement("g", {
      className: wi("legend-month")
    }, Vw(K, I.months).map(({
      label: x,
      weekIndex: Q
    }) => /* @__PURE__ */ zt.default.createElement("text", {
      x: (i + r) * Q,
      dominantBaseline: "hanging",
      key: Q
    }, x))));
  }
  const {
    width: d,
    height: S
  } = h(), P = {
    fontSize: l,
    ...u && {
      [`--${Fn}-loading`]: D[0],
      [`--${Fn}-loading-active`]: n === "light" ? Us.default(D[0]).darken(0.3).hex() : Us.default(D[0]).brighten(0.25).hex()
    }
  };
  return /* @__PURE__ */ zt.default.createElement("article", {
    className: `${Fn} ${Vi.container}`,
    style: {
      ...v,
      ...P
    }
  }, /* @__PURE__ */ zt.default.createElement("div", {
    className: wi("scroll-container", Vi.scrollContainer)
  }, /* @__PURE__ */ zt.default.createElement("svg", {
    width: d,
    height: S,
    viewBox: `0 0 ${d} ${S}`,
    className: wi("calendar", Vi.calendar),
    style: {
      marginLeft: k
    }
  }, !B && c(), o())), a());
}, tk = (t) => /* @__PURE__ */ zt.default.createElement(Jd, Gs({
  data: []
}, t));
$o.Skeleton = tk;
var _d = $o.default = Jd;
const rk = () => {
  const t = Ri(() => {
    const r = (/* @__PURE__ */ new Date()).getFullYear();
    return Object.entries(As).map(({ 0: e, 1: i }) => [
      {
        date: hr(new Date(r, Number(e), 1), "yyyy-MM-dd"),
        count: 0,
        level: 0
      },
      {
        date: hr(new Date(r, Number(e), i), "yyyy-MM-dd"),
        count: 0,
        level: 0
      }
    ]);
  }, []);
  return /* @__PURE__ */ se.jsxs("div", { className: "w-full flex flex-col gap-2rounded shadow animate-pulse border-[#ffffff14]", children: [
    /* @__PURE__ */ se.jsxs("div", { className: "flex justify-between w-full", children: [
      /* @__PURE__ */ se.jsx("div", { className: "h-3.5 rounded-full bg-[#ffffff14] w-32" }),
      /* @__PURE__ */ se.jsxs("div", { className: "flex gap-2 w-1/2 justify-end", children: [
        /* @__PURE__ */ se.jsx("div", { className: "w-24 h-3 bg-[#ffffff14] rounded-full" }),
        /* @__PURE__ */ se.jsx("div", { className: "w-24 h-3 bg-[#ffffff14] rounded-full" }),
        /* @__PURE__ */ se.jsx("div", { className: "w-16 h-3 bg-[#ffffff14] rounded-full" })
      ] })
    ] }),
    /* @__PURE__ */ se.jsx("div", { className: "flex gap-2", children: t.map((r) => /* @__PURE__ */ se.jsx(
      _d,
      {
        data: r,
        theme: {
          dark: ["#ffffff14", "#004d1b", "#008024", "#01b328", "#aff0b4"]
        },
        colorScheme: "dark",
        blockSize: 8,
        blockMargin: 4,
        hideMonthLabels: !1,
        weekStart: 0
      },
      r[0].date
    )) })
  ] });
}, xn = Math.min, Li = Math.max, Xs = Math.round, Cs = Math.floor, fi = (t) => ({
  x: t,
  y: t
}), ik = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, nk = {
  start: "end",
  end: "start"
};
function wo(t, r, e) {
  return Li(t, xn(r, e));
}
function hs(t, r) {
  return typeof t == "function" ? t(r) : t;
}
function Ni(t) {
  return t.split("-")[0];
}
function ds(t) {
  return t.split("-")[1];
}
function $d(t) {
  return t === "x" ? "y" : "x";
}
function el(t) {
  return t === "y" ? "height" : "width";
}
function ha(t) {
  return ["top", "bottom"].includes(Ni(t)) ? "y" : "x";
}
function tl(t) {
  return $d(ha(t));
}
function sk(t, r, e) {
  e === void 0 && (e = !1);
  const i = ds(t), n = tl(t), s = el(n);
  let l = n === "x" ? i === (e ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return r.reference[s] > r.floating[s] && (l = Qs(l)), [l, Qs(l)];
}
function ak(t) {
  const r = Qs(t);
  return [ko(t), r, ko(r)];
}
function ko(t) {
  return t.replace(/start|end/g, (r) => nk[r]);
}
function ok(t, r, e) {
  const i = ["left", "right"], n = ["right", "left"], s = ["top", "bottom"], l = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return e ? r ? n : i : r ? i : n;
    case "left":
    case "right":
      return r ? s : l;
    default:
      return [];
  }
}
function lk(t, r, e, i) {
  const n = ds(t);
  let s = ok(Ni(t), e === "start", i);
  return n && (s = s.map((l) => l + "-" + n), r && (s = s.concat(s.map(ko)))), s;
}
function Qs(t) {
  return t.replace(/left|right|bottom|top/g, (r) => ik[r]);
}
function ck(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function eu(t) {
  return typeof t != "number" ? ck(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function Vs(t) {
  return {
    ...t,
    top: t.y,
    left: t.x,
    right: t.x + t.width,
    bottom: t.y + t.height
  };
}
function Wc(t, r, e) {
  let {
    reference: i,
    floating: n
  } = t;
  const s = ha(r), l = tl(r), m = el(l), A = Ni(r), Y = s === "y", q = i.x + i.width / 2 - n.width / 2, T = i.y + i.height / 2 - n.height / 2, B = i[m] / 2 - n[m] / 2;
  let O;
  switch (A) {
    case "top":
      O = {
        x: q,
        y: i.y - n.height
      };
      break;
    case "bottom":
      O = {
        x: q,
        y: i.y + i.height
      };
      break;
    case "right":
      O = {
        x: i.x + i.width,
        y: T
      };
      break;
    case "left":
      O = {
        x: i.x - n.width,
        y: T
      };
      break;
    default:
      O = {
        x: i.x,
        y: i.y
      };
  }
  switch (ds(r)) {
    case "start":
      O[l] -= B * (e && Y ? -1 : 1);
      break;
    case "end":
      O[l] += B * (e && Y ? -1 : 1);
      break;
  }
  return O;
}
const hk = async (t, r, e) => {
  const {
    placement: i = "bottom",
    strategy: n = "absolute",
    middleware: s = [],
    platform: l
  } = e, m = s.filter(Boolean), A = await (l.isRTL == null ? void 0 : l.isRTL(r));
  let Y = await l.getElementRects({
    reference: t,
    floating: r,
    strategy: n
  }), {
    x: q,
    y: T
  } = Wc(Y, i, A), B = i, O = {}, b = 0;
  for (let v = 0; v < m.length; v++) {
    const {
      name: E,
      fn: M
    } = m[v], {
      x: g,
      y: C,
      data: j,
      reset: D
    } = await M({
      x: q,
      y: T,
      initialPlacement: i,
      placement: B,
      strategy: n,
      middlewareData: O,
      rects: Y,
      platform: l,
      elements: {
        reference: t,
        floating: r
      }
    });
    q = g ?? q, T = C ?? T, O = {
      ...O,
      [E]: {
        ...O[E],
        ...j
      }
    }, D && b <= 50 && (b++, typeof D == "object" && (D.placement && (B = D.placement), D.rects && (Y = D.rects === !0 ? await l.getElementRects({
      reference: t,
      floating: r,
      strategy: n
    }) : D.rects), {
      x: q,
      y: T
    } = Wc(Y, B, A)), v = -1);
  }
  return {
    x: q,
    y: T,
    placement: B,
    strategy: n,
    middlewareData: O
  };
};
async function tu(t, r) {
  var e;
  r === void 0 && (r = {});
  const {
    x: i,
    y: n,
    platform: s,
    rects: l,
    elements: m,
    strategy: A
  } = t, {
    boundary: Y = "clippingAncestors",
    rootBoundary: q = "viewport",
    elementContext: T = "floating",
    altBoundary: B = !1,
    padding: O = 0
  } = hs(r, t), b = eu(O), E = m[B ? T === "floating" ? "reference" : "floating" : T], M = Vs(await s.getClippingRect({
    element: (e = await (s.isElement == null ? void 0 : s.isElement(E))) == null || e ? E : E.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(m.floating)),
    boundary: Y,
    rootBoundary: q,
    strategy: A
  })), g = T === "floating" ? {
    ...l.floating,
    x: i,
    y: n
  } : l.reference, C = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(m.floating)), j = await (s.isElement == null ? void 0 : s.isElement(C)) ? await (s.getScale == null ? void 0 : s.getScale(C)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, D = Vs(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: m,
    rect: g,
    offsetParent: C,
    strategy: A
  }) : g);
  return {
    top: (M.top - D.top + b.top) / j.y,
    bottom: (D.bottom - M.bottom + b.bottom) / j.y,
    left: (M.left - D.left + b.left) / j.x,
    right: (D.right - M.right + b.right) / j.x
  };
}
const dk = (t) => ({
  name: "arrow",
  options: t,
  async fn(r) {
    const {
      x: e,
      y: i,
      placement: n,
      rects: s,
      platform: l,
      elements: m,
      middlewareData: A
    } = r, {
      element: Y,
      padding: q = 0
    } = hs(t, r) || {};
    if (Y == null)
      return {};
    const T = eu(q), B = {
      x: e,
      y: i
    }, O = tl(n), b = el(O), v = await l.getDimensions(Y), E = O === "y", M = E ? "top" : "left", g = E ? "bottom" : "right", C = E ? "clientHeight" : "clientWidth", j = s.reference[b] + s.reference[O] - B[O] - s.floating[b], D = B[O] - s.reference[O], u = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(Y));
    let R = u ? u[C] : 0;
    (!R || !await (l.isElement == null ? void 0 : l.isElement(u))) && (R = m.floating[C] || s.floating[b]);
    const K = j / 2 - D / 2, I = R / 2 - v[b] / 2 - 1, z = xn(T[M], I), k = xn(T[g], I), h = z, F = R - v[b] - k, o = R / 2 - v[b] / 2 + K, a = wo(h, o, F), c = !A.arrow && ds(n) != null && o !== a && s.reference[b] / 2 - (o < h ? z : k) - v[b] / 2 < 0, d = c ? o < h ? o - h : o - F : 0;
    return {
      [O]: B[O] + d,
      data: {
        [O]: a,
        centerOffset: o - a - d,
        ...c && {
          alignmentOffset: d
        }
      },
      reset: c
    };
  }
}), uk = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(r) {
      var e, i;
      const {
        placement: n,
        middlewareData: s,
        rects: l,
        initialPlacement: m,
        platform: A,
        elements: Y
      } = r, {
        mainAxis: q = !0,
        crossAxis: T = !0,
        fallbackPlacements: B,
        fallbackStrategy: O = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: v = !0,
        ...E
      } = hs(t, r);
      if ((e = s.arrow) != null && e.alignmentOffset)
        return {};
      const M = Ni(n), g = Ni(m) === m, C = await (A.isRTL == null ? void 0 : A.isRTL(Y.floating)), j = B || (g || !v ? [Qs(m)] : ak(m));
      !B && b !== "none" && j.push(...lk(m, v, b, C));
      const D = [m, ...j], u = await tu(r, E), R = [];
      let K = ((i = s.flip) == null ? void 0 : i.overflows) || [];
      if (q && R.push(u[M]), T) {
        const h = sk(n, l, C);
        R.push(u[h[0]], u[h[1]]);
      }
      if (K = [...K, {
        placement: n,
        overflows: R
      }], !R.every((h) => h <= 0)) {
        var I, z;
        const h = (((I = s.flip) == null ? void 0 : I.index) || 0) + 1, F = D[h];
        if (F)
          return {
            data: {
              index: h,
              overflows: K
            },
            reset: {
              placement: F
            }
          };
        let o = (z = K.filter((a) => a.overflows[0] <= 0).sort((a, c) => a.overflows[1] - c.overflows[1])[0]) == null ? void 0 : z.placement;
        if (!o)
          switch (O) {
            case "bestFit": {
              var k;
              const a = (k = K.map((c) => [c.placement, c.overflows.filter((d) => d > 0).reduce((d, S) => d + S, 0)]).sort((c, d) => c[1] - d[1])[0]) == null ? void 0 : k[0];
              a && (o = a);
              break;
            }
            case "initialPlacement":
              o = m;
              break;
          }
        if (n !== o)
          return {
            reset: {
              placement: o
            }
          };
      }
      return {};
    }
  };
};
async function fk(t, r) {
  const {
    placement: e,
    platform: i,
    elements: n
  } = t, s = await (i.isRTL == null ? void 0 : i.isRTL(n.floating)), l = Ni(e), m = ds(e), A = ha(e) === "y", Y = ["left", "top"].includes(l) ? -1 : 1, q = s && A ? -1 : 1, T = hs(r, t);
  let {
    mainAxis: B,
    crossAxis: O,
    alignmentAxis: b
  } = typeof T == "number" ? {
    mainAxis: T,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...T
  };
  return m && typeof b == "number" && (O = m === "end" ? b * -1 : b), A ? {
    x: O * q,
    y: B * Y
  } : {
    x: B * Y,
    y: O * q
  };
}
const pk = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(r) {
      var e, i;
      const {
        x: n,
        y: s,
        placement: l,
        middlewareData: m
      } = r, A = await fk(r, t);
      return l === ((e = m.offset) == null ? void 0 : e.placement) && (i = m.arrow) != null && i.alignmentOffset ? {} : {
        x: n + A.x,
        y: s + A.y,
        data: {
          ...A,
          placement: l
        }
      };
    }
  };
}, gk = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(r) {
      const {
        x: e,
        y: i,
        placement: n
      } = r, {
        mainAxis: s = !0,
        crossAxis: l = !1,
        limiter: m = {
          fn: (E) => {
            let {
              x: M,
              y: g
            } = E;
            return {
              x: M,
              y: g
            };
          }
        },
        ...A
      } = hs(t, r), Y = {
        x: e,
        y: i
      }, q = await tu(r, A), T = ha(Ni(n)), B = $d(T);
      let O = Y[B], b = Y[T];
      if (s) {
        const E = B === "y" ? "top" : "left", M = B === "y" ? "bottom" : "right", g = O + q[E], C = O - q[M];
        O = wo(g, O, C);
      }
      if (l) {
        const E = T === "y" ? "top" : "left", M = T === "y" ? "bottom" : "right", g = b + q[E], C = b - q[M];
        b = wo(g, b, C);
      }
      const v = m.fn({
        ...r,
        [B]: O,
        [T]: b
      });
      return {
        ...v,
        data: {
          x: v.x - e,
          y: v.y - i
        }
      };
    }
  };
};
function pi(t) {
  return ru(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function gr(t) {
  var r;
  return (t == null || (r = t.ownerDocument) == null ? void 0 : r.defaultView) || window;
}
function _r(t) {
  var r;
  return (r = (ru(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : r.documentElement;
}
function ru(t) {
  return t instanceof Node || t instanceof gr(t).Node;
}
function Jr(t) {
  return t instanceof Element || t instanceof gr(t).Element;
}
function zr(t) {
  return t instanceof HTMLElement || t instanceof gr(t).HTMLElement;
}
function Hc(t) {
  return typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof gr(t).ShadowRoot;
}
function us(t) {
  const {
    overflow: r,
    overflowX: e,
    overflowY: i,
    display: n
  } = wr(t);
  return /auto|scroll|overlay|hidden|clip/.test(r + i + e) && !["inline", "contents"].includes(n);
}
function mk(t) {
  return ["table", "td", "th"].includes(pi(t));
}
function rl(t) {
  const r = il(), e = wr(t);
  return e.transform !== "none" || e.perspective !== "none" || (e.containerType ? e.containerType !== "normal" : !1) || !r && (e.backdropFilter ? e.backdropFilter !== "none" : !1) || !r && (e.filter ? e.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((i) => (e.willChange || "").includes(i)) || ["paint", "layout", "strict", "content"].some((i) => (e.contain || "").includes(i));
}
function yk(t) {
  let r = wn(t);
  for (; zr(r) && !da(r); ) {
    if (rl(r))
      return r;
    r = wn(r);
  }
  return null;
}
function il() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function da(t) {
  return ["html", "body", "#document"].includes(pi(t));
}
function wr(t) {
  return gr(t).getComputedStyle(t);
}
function ua(t) {
  return Jr(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.pageXOffset,
    scrollTop: t.pageYOffset
  };
}
function wn(t) {
  if (pi(t) === "html")
    return t;
  const r = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    Hc(t) && t.host || // Fallback.
    _r(t)
  );
  return Hc(r) ? r.host : r;
}
function iu(t) {
  const r = wn(t);
  return da(r) ? t.ownerDocument ? t.ownerDocument.body : t.body : zr(r) && us(r) ? r : iu(r);
}
function Yn(t, r, e) {
  var i;
  r === void 0 && (r = []), e === void 0 && (e = !0);
  const n = iu(t), s = n === ((i = t.ownerDocument) == null ? void 0 : i.body), l = gr(n);
  return s ? r.concat(l, l.visualViewport || [], us(n) ? n : [], l.frameElement && e ? Yn(l.frameElement) : []) : r.concat(n, Yn(n, [], e));
}
function nu(t) {
  const r = wr(t);
  let e = parseFloat(r.width) || 0, i = parseFloat(r.height) || 0;
  const n = zr(t), s = n ? t.offsetWidth : e, l = n ? t.offsetHeight : i, m = Xs(e) !== s || Xs(i) !== l;
  return m && (e = s, i = l), {
    width: e,
    height: i,
    $: m
  };
}
function nl(t) {
  return Jr(t) ? t : t.contextElement;
}
function en(t) {
  const r = nl(t);
  if (!zr(r))
    return fi(1);
  const e = r.getBoundingClientRect(), {
    width: i,
    height: n,
    $: s
  } = nu(r);
  let l = (s ? Xs(e.width) : e.width) / i, m = (s ? Xs(e.height) : e.height) / n;
  return (!l || !Number.isFinite(l)) && (l = 1), (!m || !Number.isFinite(m)) && (m = 1), {
    x: l,
    y: m
  };
}
const bk = /* @__PURE__ */ fi(0);
function su(t) {
  const r = gr(t);
  return !il() || !r.visualViewport ? bk : {
    x: r.visualViewport.offsetLeft,
    y: r.visualViewport.offsetTop
  };
}
function vk(t, r, e) {
  return r === void 0 && (r = !1), !e || r && e !== gr(t) ? !1 : r;
}
function ji(t, r, e, i) {
  r === void 0 && (r = !1), e === void 0 && (e = !1);
  const n = t.getBoundingClientRect(), s = nl(t);
  let l = fi(1);
  r && (i ? Jr(i) && (l = en(i)) : l = en(t));
  const m = vk(s, e, i) ? su(s) : fi(0);
  let A = (n.left + m.x) / l.x, Y = (n.top + m.y) / l.y, q = n.width / l.x, T = n.height / l.y;
  if (s) {
    const B = gr(s), O = i && Jr(i) ? gr(i) : i;
    let b = B, v = b.frameElement;
    for (; v && i && O !== b; ) {
      const E = en(v), M = v.getBoundingClientRect(), g = wr(v), C = M.left + (v.clientLeft + parseFloat(g.paddingLeft)) * E.x, j = M.top + (v.clientTop + parseFloat(g.paddingTop)) * E.y;
      A *= E.x, Y *= E.y, q *= E.x, T *= E.y, A += C, Y += j, b = gr(v), v = b.frameElement;
    }
  }
  return Vs({
    width: q,
    height: T,
    x: A,
    y: Y
  });
}
const xk = [":popover-open", ":modal"];
function au(t) {
  return xk.some((r) => {
    try {
      return t.matches(r);
    } catch {
      return !1;
    }
  });
}
function wk(t) {
  let {
    elements: r,
    rect: e,
    offsetParent: i,
    strategy: n
  } = t;
  const s = n === "fixed", l = _r(i), m = r ? au(r.floating) : !1;
  if (i === l || m && s)
    return e;
  let A = {
    scrollLeft: 0,
    scrollTop: 0
  }, Y = fi(1);
  const q = fi(0), T = zr(i);
  if ((T || !T && !s) && ((pi(i) !== "body" || us(l)) && (A = ua(i)), zr(i))) {
    const B = ji(i);
    Y = en(i), q.x = B.x + i.clientLeft, q.y = B.y + i.clientTop;
  }
  return {
    width: e.width * Y.x,
    height: e.height * Y.y,
    x: e.x * Y.x - A.scrollLeft * Y.x + q.x,
    y: e.y * Y.y - A.scrollTop * Y.y + q.y
  };
}
function kk(t) {
  return Array.from(t.getClientRects());
}
function ou(t) {
  return ji(_r(t)).left + ua(t).scrollLeft;
}
function Ck(t) {
  const r = _r(t), e = ua(t), i = t.ownerDocument.body, n = Li(r.scrollWidth, r.clientWidth, i.scrollWidth, i.clientWidth), s = Li(r.scrollHeight, r.clientHeight, i.scrollHeight, i.clientHeight);
  let l = -e.scrollLeft + ou(t);
  const m = -e.scrollTop;
  return wr(i).direction === "rtl" && (l += Li(r.clientWidth, i.clientWidth) - n), {
    width: n,
    height: s,
    x: l,
    y: m
  };
}
function Sk(t, r) {
  const e = gr(t), i = _r(t), n = e.visualViewport;
  let s = i.clientWidth, l = i.clientHeight, m = 0, A = 0;
  if (n) {
    s = n.width, l = n.height;
    const Y = il();
    (!Y || Y && r === "fixed") && (m = n.offsetLeft, A = n.offsetTop);
  }
  return {
    width: s,
    height: l,
    x: m,
    y: A
  };
}
function Mk(t, r) {
  const e = ji(t, !0, r === "fixed"), i = e.top + t.clientTop, n = e.left + t.clientLeft, s = zr(t) ? en(t) : fi(1), l = t.clientWidth * s.x, m = t.clientHeight * s.y, A = n * s.x, Y = i * s.y;
  return {
    width: l,
    height: m,
    x: A,
    y: Y
  };
}
function zc(t, r, e) {
  let i;
  if (r === "viewport")
    i = Sk(t, e);
  else if (r === "document")
    i = Ck(_r(t));
  else if (Jr(r))
    i = Mk(r, e);
  else {
    const n = su(t);
    i = {
      ...r,
      x: r.x - n.x,
      y: r.y - n.y
    };
  }
  return Vs(i);
}
function lu(t, r) {
  const e = wn(t);
  return e === r || !Jr(e) || da(e) ? !1 : wr(e).position === "fixed" || lu(e, r);
}
function Tk(t, r) {
  const e = r.get(t);
  if (e)
    return e;
  let i = Yn(t, [], !1).filter((m) => Jr(m) && pi(m) !== "body"), n = null;
  const s = wr(t).position === "fixed";
  let l = s ? wn(t) : t;
  for (; Jr(l) && !da(l); ) {
    const m = wr(l), A = rl(l);
    !A && m.position === "fixed" && (n = null), (s ? !A && !n : !A && m.position === "static" && !!n && ["absolute", "fixed"].includes(n.position) || us(l) && !A && lu(t, l)) ? i = i.filter((q) => q !== l) : n = m, l = wn(l);
  }
  return r.set(t, i), i;
}
function Ok(t) {
  let {
    element: r,
    boundary: e,
    rootBoundary: i,
    strategy: n
  } = t;
  const l = [...e === "clippingAncestors" ? Tk(r, this._c) : [].concat(e), i], m = l[0], A = l.reduce((Y, q) => {
    const T = zc(r, q, n);
    return Y.top = Li(T.top, Y.top), Y.right = xn(T.right, Y.right), Y.bottom = xn(T.bottom, Y.bottom), Y.left = Li(T.left, Y.left), Y;
  }, zc(r, m, n));
  return {
    width: A.right - A.left,
    height: A.bottom - A.top,
    x: A.left,
    y: A.top
  };
}
function Ak(t) {
  const {
    width: r,
    height: e
  } = nu(t);
  return {
    width: r,
    height: e
  };
}
function Ek(t, r, e) {
  const i = zr(r), n = _r(r), s = e === "fixed", l = ji(t, !0, s, r);
  let m = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const A = fi(0);
  if (i || !i && !s)
    if ((pi(r) !== "body" || us(n)) && (m = ua(r)), i) {
      const T = ji(r, !0, s, r);
      A.x = T.x + r.clientLeft, A.y = T.y + r.clientTop;
    } else
      n && (A.x = ou(n));
  const Y = l.left + m.scrollLeft - A.x, q = l.top + m.scrollTop - A.y;
  return {
    x: Y,
    y: q,
    width: l.width,
    height: l.height
  };
}
function Yc(t, r) {
  return !zr(t) || wr(t).position === "fixed" ? null : r ? r(t) : t.offsetParent;
}
function cu(t, r) {
  const e = gr(t);
  if (!zr(t) || au(t))
    return e;
  let i = Yc(t, r);
  for (; i && mk(i) && wr(i).position === "static"; )
    i = Yc(i, r);
  return i && (pi(i) === "html" || pi(i) === "body" && wr(i).position === "static" && !rl(i)) ? e : i || yk(t) || e;
}
const Pk = async function(t) {
  const r = this.getOffsetParent || cu, e = this.getDimensions;
  return {
    reference: Ek(t.reference, await r(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await e(t.floating)
    }
  };
};
function Dk(t) {
  return wr(t).direction === "rtl";
}
const Lk = {
  convertOffsetParentRelativeRectToViewportRelativeRect: wk,
  getDocumentElement: _r,
  getClippingRect: Ok,
  getOffsetParent: cu,
  getElementRects: Pk,
  getClientRects: kk,
  getDimensions: Ak,
  getScale: en,
  isElement: Jr,
  isRTL: Dk
};
function Rk(t, r) {
  let e = null, i;
  const n = _r(t);
  function s() {
    var m;
    clearTimeout(i), (m = e) == null || m.disconnect(), e = null;
  }
  function l(m, A) {
    m === void 0 && (m = !1), A === void 0 && (A = 1), s();
    const {
      left: Y,
      top: q,
      width: T,
      height: B
    } = t.getBoundingClientRect();
    if (m || r(), !T || !B)
      return;
    const O = Cs(q), b = Cs(n.clientWidth - (Y + T)), v = Cs(n.clientHeight - (q + B)), E = Cs(Y), g = {
      rootMargin: -O + "px " + -b + "px " + -v + "px " + -E + "px",
      threshold: Li(0, xn(1, A)) || 1
    };
    let C = !0;
    function j(D) {
      const u = D[0].intersectionRatio;
      if (u !== A) {
        if (!C)
          return l();
        u ? l(!1, u) : i = setTimeout(() => {
          l(!1, 1e-7);
        }, 100);
      }
      C = !1;
    }
    try {
      e = new IntersectionObserver(j, {
        ...g,
        // Handle <iframe>s
        root: n.ownerDocument
      });
    } catch {
      e = new IntersectionObserver(j, g);
    }
    e.observe(t);
  }
  return l(!0), s;
}
function Nk(t, r, e, i) {
  i === void 0 && (i = {});
  const {
    ancestorScroll: n = !0,
    ancestorResize: s = !0,
    elementResize: l = typeof ResizeObserver == "function",
    layoutShift: m = typeof IntersectionObserver == "function",
    animationFrame: A = !1
  } = i, Y = nl(t), q = n || s ? [...Y ? Yn(Y) : [], ...Yn(r)] : [];
  q.forEach((M) => {
    n && M.addEventListener("scroll", e, {
      passive: !0
    }), s && M.addEventListener("resize", e);
  });
  const T = Y && m ? Rk(Y, e) : null;
  let B = -1, O = null;
  l && (O = new ResizeObserver((M) => {
    let [g] = M;
    g && g.target === Y && O && (O.unobserve(r), cancelAnimationFrame(B), B = requestAnimationFrame(() => {
      var C;
      (C = O) == null || C.observe(r);
    })), e();
  }), Y && !A && O.observe(Y), O.observe(r));
  let b, v = A ? ji(t) : null;
  A && E();
  function E() {
    const M = ji(t);
    v && (M.x !== v.x || M.y !== v.y || M.width !== v.width || M.height !== v.height) && e(), v = M, b = requestAnimationFrame(E);
  }
  return e(), () => {
    var M;
    q.forEach((g) => {
      n && g.removeEventListener("scroll", e), s && g.removeEventListener("resize", e);
    }), T == null || T(), (M = O) == null || M.disconnect(), O = null, A && cancelAnimationFrame(b);
  };
}
const jk = gk, Ik = uk, Fk = dk, Uc = (t, r, e) => {
  const i = /* @__PURE__ */ new Map(), n = {
    platform: Lk,
    ...e
  }, s = {
    ...n.platform,
    _c: i
  };
  return hk(t, r, {
    ...n,
    platform: s
  });
};
var hu = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(t) {
  (function() {
    var r = {}.hasOwnProperty;
    function e() {
      for (var s = "", l = 0; l < arguments.length; l++) {
        var m = arguments[l];
        m && (s = n(s, i(m)));
      }
      return s;
    }
    function i(s) {
      if (typeof s == "string" || typeof s == "number")
        return s;
      if (typeof s != "object")
        return "";
      if (Array.isArray(s))
        return e.apply(null, s);
      if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
        return s.toString();
      var l = "";
      for (var m in s)
        r.call(s, m) && s[m] && (l = n(l, m));
      return l;
    }
    function n(s, l) {
      return l ? s ? s + " " + l : s + l : s;
    }
    t.exports ? (e.default = e, t.exports = e) : window.classNames = e;
  })();
})(hu);
var Bk = hu.exports;
const Co = /* @__PURE__ */ To(Bk);
/*
* React Tooltip
* {@link https://github.com/ReactTooltip/react-tooltip}
* @copyright ReactTooltip Team
* @license MIT
*/
const Wk = "react-tooltip-core-styles", Hk = "react-tooltip-base-styles", Gc = { core: !1, base: !1 };
function qc({ css: t, id: r = Hk, type: e = "base", ref: i }) {
  var n, s;
  if (!t || typeof document > "u" || Gc[e] || e === "core" && typeof process < "u" && (!((n = process == null ? void 0 : process.env) === null || n === void 0) && n.REACT_TOOLTIP_DISABLE_CORE_STYLES) || e !== "base" && typeof process < "u" && (!((s = process == null ? void 0 : process.env) === null || s === void 0) && s.REACT_TOOLTIP_DISABLE_BASE_STYLES))
    return;
  e === "core" && (r = Wk), i || (i = {});
  const { insertAt: l } = i;
  if (document.getElementById(r))
    return void console.warn(`[react-tooltip] Element with id '${r}' already exists. Call \`removeStyle()\` first`);
  const m = document.head || document.getElementsByTagName("head")[0], A = document.createElement("style");
  A.id = r, A.type = "text/css", l === "top" && m.firstChild ? m.insertBefore(A, m.firstChild) : m.appendChild(A), A.styleSheet ? A.styleSheet.cssText = t : A.appendChild(document.createTextNode(t)), Gc[e] = !0;
}
const Xc = async ({ elementReference: t = null, tooltipReference: r = null, tooltipArrowReference: e = null, place: i = "top", offset: n = 10, strategy: s = "absolute", middlewares: l = [pk(Number(n)), Ik({ fallbackAxisSideDirection: "start" }), jk({ padding: 5 })], border: m }) => {
  if (!t)
    return { tooltipStyles: {}, tooltipArrowStyles: {}, place: i };
  if (r === null)
    return { tooltipStyles: {}, tooltipArrowStyles: {}, place: i };
  const A = l;
  return e ? (A.push(Fk({ element: e, padding: 5 })), Uc(t, r, { placement: i, strategy: s, middleware: A }).then(({ x: Y, y: q, placement: T, middlewareData: B }) => {
    var O, b;
    const v = { left: `${Y}px`, top: `${q}px`, border: m }, { x: E, y: M } = (O = B.arrow) !== null && O !== void 0 ? O : { x: 0, y: 0 }, g = (b = { top: "bottom", right: "left", bottom: "top", left: "right" }[T.split("-")[0]]) !== null && b !== void 0 ? b : "bottom", C = m && { borderBottom: m, borderRight: m };
    let j = 0;
    if (m) {
      const D = `${m}`.match(/(\d+)px/);
      j = D != null && D[1] ? Number(D[1]) : 1;
    }
    return { tooltipStyles: v, tooltipArrowStyles: { left: E != null ? `${E}px` : "", top: M != null ? `${M}px` : "", right: "", bottom: "", ...C, [g]: `-${4 + j}px` }, place: T };
  })) : Uc(t, r, { placement: "bottom", strategy: s, middleware: A }).then(({ x: Y, y: q, placement: T }) => ({ tooltipStyles: { left: `${Y}px`, top: `${q}px` }, tooltipArrowStyles: {}, place: T }));
}, Qc = (t, r) => !("CSS" in window && "supports" in window.CSS) || window.CSS.supports(t, r), Vc = (t, r, e) => {
  let i = null;
  const n = function(...s) {
    const l = () => {
      i = null, e || t.apply(this, s);
    };
    e && !i && (t.apply(this, s), i = setTimeout(l, r)), e || (i && clearTimeout(i), i = setTimeout(l, r));
  };
  return n.cancel = () => {
    i && (clearTimeout(i), i = null);
  }, n;
}, Kc = (t) => t !== null && !Array.isArray(t) && typeof t == "object", So = (t, r) => {
  if (t === r)
    return !0;
  if (Array.isArray(t) && Array.isArray(r))
    return t.length === r.length && t.every((n, s) => So(n, r[s]));
  if (Array.isArray(t) !== Array.isArray(r))
    return !1;
  if (!Kc(t) || !Kc(r))
    return t === r;
  const e = Object.keys(t), i = Object.keys(r);
  return e.length === i.length && e.every((n) => So(t[n], r[n]));
}, zk = (t) => {
  if (!(t instanceof HTMLElement || t instanceof SVGElement))
    return !1;
  const r = getComputedStyle(t);
  return ["overflow", "overflow-x", "overflow-y"].some((e) => {
    const i = r.getPropertyValue(e);
    return i === "auto" || i === "scroll";
  });
}, Zc = (t) => {
  if (!t)
    return null;
  let r = t.parentElement;
  for (; r; ) {
    if (zk(r))
      return r;
    r = r.parentElement;
  }
  return document.scrollingElement || document.documentElement;
}, Yk = typeof window < "u" ? Gg : Nt, Uk = "DEFAULT_TOOLTIP_ID", Gk = { anchorRefs: /* @__PURE__ */ new Set(), activeAnchor: { current: null }, attach: () => {
}, detach: () => {
}, setActiveAnchor: () => {
} }, qk = Hg({ getTooltipData: () => Gk });
function du(t = Uk) {
  return zg(qk).getTooltipData(t);
}
var Ki = { tooltip: "core-styles-module_tooltip__3vRRp", fixed: "core-styles-module_fixed__pcSol", arrow: "core-styles-module_arrow__cvMwQ", noArrow: "core-styles-module_noArrow__xock6", clickable: "core-styles-module_clickable__ZuTTB", show: "core-styles-module_show__Nt9eE", closing: "core-styles-module_closing__sGnxF" }, Za = { tooltip: "styles-module_tooltip__mnnfp", arrow: "styles-module_arrow__K0L3T", dark: "styles-module_dark__xNqje", light: "styles-module_light__Z6W-X", success: "styles-module_success__A2AKt", warning: "styles-module_warning__SCK0X", error: "styles-module_error__JvumD", info: "styles-module_info__BWdHW" };
const Xk = ({ forwardRef: t, id: r, className: e, classNameArrow: i, variant: n = "dark", anchorId: s, anchorSelect: l, place: m = "top", offset: A = 10, events: Y = ["hover"], openOnClick: q = !1, positionStrategy: T = "absolute", middlewares: B, wrapper: O, delayShow: b = 0, delayHide: v = 0, float: E = !1, hidden: M = !1, noArrow: g = !1, clickable: C = !1, closeOnEsc: j = !1, closeOnScroll: D = !1, closeOnResize: u = !1, openEvents: R, closeEvents: K, globalCloseEvents: I, imperativeModeOnly: z, style: k, position: h, afterShow: F, afterHide: o, content: a, contentWrapperRef: c, isOpen: d, defaultIsOpen: S = !1, setIsOpen: P, activeAnchor: G, setActiveAnchor: x, border: Q, opacity: J, arrowColor: ie, role: te = "tooltip" }) => {
  var $;
  const oe = Tr(null), p = Tr(null), W = Tr(null), X = Tr(null), f = Tr(null), [L, w] = At({ tooltipStyles: {}, tooltipArrowStyles: {}, place: m }), [H, U] = At(!1), [ee, ae] = At(!1), [ne, he] = At(null), me = Tr(!1), ve = Tr(null), { anchorRefs: Me, setActiveAnchor: Z } = du(r), V = Tr(!1), [re, le] = At([]), be = Tr(!1), de = q || Y.includes("click"), ge = de || (R == null ? void 0 : R.click) || (R == null ? void 0 : R.dblclick) || (R == null ? void 0 : R.mousedown), fe = R ? { ...R } : { mouseenter: !0, focus: !0, click: !1, dblclick: !1, mousedown: !1 };
  !R && de && Object.assign(fe, { mouseenter: !1, focus: !1, click: !0 });
  const ke = K ? { ...K } : { mouseleave: !0, blur: !0, click: !1, dblclick: !1, mouseup: !1 };
  !K && de && Object.assign(ke, { mouseleave: !1, blur: !1 });
  const Pe = I ? { ...I } : { escape: j || !1, scroll: D || !1, resize: u || !1, clickOutsideAnchor: ge || !1 };
  z && (Object.assign(fe, { mouseenter: !1, focus: !1, click: !1, dblclick: !1, mousedown: !1 }), Object.assign(ke, { mouseleave: !1, blur: !1, click: !1, dblclick: !1, mouseup: !1 }), Object.assign(Pe, { escape: !1, scroll: !1, resize: !1, clickOutsideAnchor: !1 })), Yk(() => (be.current = !0, () => {
    be.current = !1;
  }), []);
  const Ae = (Be) => {
    be.current && (Be && ae(!0), setTimeout(() => {
      be.current && (P == null || P(Be), d === void 0 && U(Be));
    }, 10));
  };
  Nt(() => {
    if (d === void 0)
      return () => null;
    d && ae(!0);
    const Be = setTimeout(() => {
      U(d);
    }, 10);
    return () => {
      clearTimeout(Be);
    };
  }, [d]), Nt(() => {
    if (H !== me.current)
      if (f.current && clearTimeout(f.current), me.current = H, H)
        F == null || F();
      else {
        const Be = ((Ve) => {
          const Je = Ve.match(/^([\d.]+)(ms|s)$/);
          if (!Je)
            return 0;
          const [, Dt, It] = Je;
          return Number(Dt) * (It === "ms" ? 1 : 1e3);
        })(getComputedStyle(document.body).getPropertyValue("--rt-transition-show-delay"));
        f.current = setTimeout(() => {
          ae(!1), he(null), o == null || o();
        }, Be + 25);
      }
  }, [H]);
  const Le = (Be) => {
    w((Ve) => So(Ve, Be) ? Ve : Be);
  }, Ee = (Be = b) => {
    W.current && clearTimeout(W.current), ee ? Ae(!0) : W.current = setTimeout(() => {
      Ae(!0);
    }, Be);
  }, Ye = (Be = v) => {
    X.current && clearTimeout(X.current), X.current = setTimeout(() => {
      V.current || Ae(!1);
    }, Be);
  }, We = (Be) => {
    var Ve;
    if (!Be)
      return;
    const Je = (Ve = Be.currentTarget) !== null && Ve !== void 0 ? Ve : Be.target;
    if (!(Je != null && Je.isConnected))
      return x(null), void Z({ current: null });
    b ? Ee() : Ae(!0), x(Je), Z({ current: Je }), X.current && clearTimeout(X.current);
  }, Ne = () => {
    C ? Ye(v || 100) : v ? Ye() : Ae(!1), W.current && clearTimeout(W.current);
  }, Xe = ({ x: Be, y: Ve }) => {
    var Je;
    const Dt = { getBoundingClientRect: () => ({ x: Be, y: Ve, width: 0, height: 0, top: Ve, left: Be, right: Be, bottom: Ve }) };
    Xc({ place: (Je = ne == null ? void 0 : ne.place) !== null && Je !== void 0 ? Je : m, offset: A, elementReference: Dt, tooltipReference: oe.current, tooltipArrowReference: p.current, strategy: T, middlewares: B, border: Q }).then((It) => {
      Le(It);
    });
  }, et = (Be) => {
    if (!Be)
      return;
    const Ve = Be, Je = { x: Ve.clientX, y: Ve.clientY };
    Xe(Je), ve.current = Je;
  }, Ze = (Be) => {
    var Ve;
    if (!H)
      return;
    const Je = Be.target;
    Je.isConnected && (!((Ve = oe.current) === null || Ve === void 0) && Ve.contains(Je) || [document.querySelector(`[id='${s}']`), ...re].some((Dt) => Dt == null ? void 0 : Dt.contains(Je)) || (Ae(!1), W.current && clearTimeout(W.current)));
  }, ut = Vc(We, 50, !0), it = Vc(Ne, 50, !0), kt = (Be) => {
    it.cancel(), ut(Be);
  }, ze = () => {
    ut.cancel(), it();
  }, nt = Yg(() => {
    var Be, Ve;
    const Je = (Be = ne == null ? void 0 : ne.position) !== null && Be !== void 0 ? Be : h;
    Je ? Xe(Je) : E ? ve.current && Xe(ve.current) : G != null && G.isConnected && Xc({ place: (Ve = ne == null ? void 0 : ne.place) !== null && Ve !== void 0 ? Ve : m, offset: A, elementReference: G, tooltipReference: oe.current, tooltipArrowReference: p.current, strategy: T, middlewares: B, border: Q }).then((Dt) => {
      be.current && Le(Dt);
    });
  }, [H, G, a, k, m, ne == null ? void 0 : ne.place, A, T, h, ne == null ? void 0 : ne.position, E]);
  Nt(() => {
    var Be, Ve;
    const Je = new Set(Me);
    re.forEach((st) => {
      Je.add({ current: st });
    });
    const Dt = document.querySelector(`[id='${s}']`);
    Dt && Je.add({ current: Dt });
    const It = () => {
      Ae(!1);
    }, _t = Zc(G), $t = Zc(oe.current);
    Pe.scroll && (window.addEventListener("scroll", It), _t == null || _t.addEventListener("scroll", It), $t == null || $t.addEventListener("scroll", It));
    let Bt = null;
    Pe.resize ? window.addEventListener("resize", It) : G && oe.current && (Bt = Nk(G, oe.current, nt, { ancestorResize: !0, elementResize: !0, layoutShift: !0 }));
    const ue = (st) => {
      st.key === "Escape" && Ae(!1);
    };
    Pe.escape && window.addEventListener("keydown", ue), Pe.clickOutsideAnchor && window.addEventListener("click", Ze);
    const Oe = [], He = (st) => {
      H && (st == null ? void 0 : st.target) === G || We(st);
    }, tt = (st) => {
      H && (st == null ? void 0 : st.target) === G && Ne();
    }, ct = ["mouseenter", "mouseleave", "focus", "blur"], mt = ["click", "dblclick", "mousedown", "mouseup"];
    Object.entries(fe).forEach(([st, ft]) => {
      ft && (ct.includes(st) ? Oe.push({ event: st, listener: kt }) : mt.includes(st) && Oe.push({ event: st, listener: He }));
    }), Object.entries(ke).forEach(([st, ft]) => {
      ft && (ct.includes(st) ? Oe.push({ event: st, listener: ze }) : mt.includes(st) && Oe.push({ event: st, listener: tt }));
    }), E && Oe.push({ event: "pointermove", listener: et });
    const ot = () => {
      V.current = !0;
    }, at = () => {
      V.current = !1, Ne();
    };
    return C && !ge && ((Be = oe.current) === null || Be === void 0 || Be.addEventListener("mouseenter", ot), (Ve = oe.current) === null || Ve === void 0 || Ve.addEventListener("mouseleave", at)), Oe.forEach(({ event: st, listener: ft }) => {
      Je.forEach((Pt) => {
        var Gt;
        (Gt = Pt.current) === null || Gt === void 0 || Gt.addEventListener(st, ft);
      });
    }), () => {
      var st, ft;
      Pe.scroll && (window.removeEventListener("scroll", It), _t == null || _t.removeEventListener("scroll", It), $t == null || $t.removeEventListener("scroll", It)), Pe.resize ? window.removeEventListener("resize", It) : Bt == null || Bt(), Pe.clickOutsideAnchor && window.removeEventListener("click", Ze), Pe.escape && window.removeEventListener("keydown", ue), C && !ge && ((st = oe.current) === null || st === void 0 || st.removeEventListener("mouseenter", ot), (ft = oe.current) === null || ft === void 0 || ft.removeEventListener("mouseleave", at)), Oe.forEach(({ event: Pt, listener: Gt }) => {
        Je.forEach((Er) => {
          var Ur;
          (Ur = Er.current) === null || Ur === void 0 || Ur.removeEventListener(Pt, Gt);
        });
      });
    };
  }, [G, nt, ee, Me, re, R, K, I, de, b, v]), Nt(() => {
    var Be, Ve;
    let Je = (Ve = (Be = ne == null ? void 0 : ne.anchorSelect) !== null && Be !== void 0 ? Be : l) !== null && Ve !== void 0 ? Ve : "";
    !Je && r && (Je = `[data-tooltip-id='${r}']`);
    const Dt = new MutationObserver((It) => {
      const _t = [], $t = [];
      It.forEach((Bt) => {
        if (Bt.type === "attributes" && Bt.attributeName === "data-tooltip-id" && (Bt.target.getAttribute("data-tooltip-id") === r ? _t.push(Bt.target) : Bt.oldValue === r && $t.push(Bt.target)), Bt.type === "childList") {
          if (G) {
            const ue = [...Bt.removedNodes].filter((Oe) => Oe.nodeType === 1);
            if (Je)
              try {
                $t.push(...ue.filter((Oe) => Oe.matches(Je))), $t.push(...ue.flatMap((Oe) => [...Oe.querySelectorAll(Je)]));
              } catch {
              }
            ue.some((Oe) => {
              var He;
              return !!(!((He = Oe == null ? void 0 : Oe.contains) === null || He === void 0) && He.call(Oe, G)) && (ae(!1), Ae(!1), x(null), W.current && clearTimeout(W.current), X.current && clearTimeout(X.current), !0);
            });
          }
          if (Je)
            try {
              const ue = [...Bt.addedNodes].filter((Oe) => Oe.nodeType === 1);
              _t.push(...ue.filter((Oe) => Oe.matches(Je))), _t.push(...ue.flatMap((Oe) => [...Oe.querySelectorAll(Je)]));
            } catch {
            }
        }
      }), (_t.length || $t.length) && le((Bt) => [...Bt.filter((ue) => !$t.includes(ue)), ..._t]);
    });
    return Dt.observe(document.body, { childList: !0, subtree: !0, attributes: !0, attributeFilter: ["data-tooltip-id"], attributeOldValue: !0 }), () => {
      Dt.disconnect();
    };
  }, [r, l, ne == null ? void 0 : ne.anchorSelect, G]), Nt(() => {
    nt();
  }, [nt]), Nt(() => {
    if (!(c != null && c.current))
      return () => null;
    const Be = new ResizeObserver(() => {
      setTimeout(() => nt());
    });
    return Be.observe(c.current), () => {
      Be.disconnect();
    };
  }, [a, c == null ? void 0 : c.current]), Nt(() => {
    var Be;
    const Ve = document.querySelector(`[id='${s}']`), Je = [...re, Ve];
    G && Je.includes(G) || x((Be = re[0]) !== null && Be !== void 0 ? Be : Ve);
  }, [s, re, G]), Nt(() => (S && Ae(!0), () => {
    W.current && clearTimeout(W.current), X.current && clearTimeout(X.current);
  }), []), Nt(() => {
    var Be;
    let Ve = (Be = ne == null ? void 0 : ne.anchorSelect) !== null && Be !== void 0 ? Be : l;
    if (!Ve && r && (Ve = `[data-tooltip-id='${r}']`), Ve)
      try {
        const Je = Array.from(document.querySelectorAll(Ve));
        le(Je);
      } catch {
        le([]);
      }
  }, [r, l, ne == null ? void 0 : ne.anchorSelect]), Nt(() => {
    W.current && (clearTimeout(W.current), Ee(b));
  }, [b]);
  const jt = ($ = ne == null ? void 0 : ne.content) !== null && $ !== void 0 ? $ : a, Vt = H && Object.keys(L.tooltipStyles).length > 0;
  return Ug(t, () => ({ open: (Be) => {
    if (Be != null && Be.anchorSelect)
      try {
        document.querySelector(Be.anchorSelect);
      } catch {
        return void console.warn(`[react-tooltip] "${Be.anchorSelect}" is not a valid CSS selector`);
      }
    he(Be ?? null), Be != null && Be.delay ? Ee(Be.delay) : Ae(!0);
  }, close: (Be) => {
    Be != null && Be.delay ? Ye(Be.delay) : Ae(!1);
  }, activeAnchor: G, place: L.place, isOpen: !!(ee && !M && jt && Vt) })), ee && !M && jt ? Qt.createElement(O, { id: r, role: te, className: Co("react-tooltip", Ki.tooltip, Za.tooltip, Za[n], e, `react-tooltip__place-${L.place}`, Ki[Vt ? "show" : "closing"], Vt ? "react-tooltip__show" : "react-tooltip__closing", T === "fixed" && Ki.fixed, C && Ki.clickable), onTransitionEnd: (Be) => {
    f.current && clearTimeout(f.current), H || Be.propertyName !== "opacity" || (ae(!1), he(null), o == null || o());
  }, style: { ...k, ...L.tooltipStyles, opacity: J !== void 0 && Vt ? J : void 0 }, ref: oe }, jt, Qt.createElement(O, { className: Co("react-tooltip-arrow", Ki.arrow, Za.arrow, i, g && Ki.noArrow), style: { ...L.tooltipArrowStyles, background: ie ? `linear-gradient(to right bottom, transparent 50%, ${ie} 50%)` : void 0 }, ref: p })) : null;
}, Qk = ({ content: t }) => Qt.createElement("span", { dangerouslySetInnerHTML: { __html: t } }), sl = Qt.forwardRef(({ id: t, anchorId: r, anchorSelect: e, content: i, html: n, render: s, className: l, classNameArrow: m, variant: A = "dark", place: Y = "top", offset: q = 10, wrapper: T = "div", children: B = null, events: O = ["hover"], openOnClick: b = !1, positionStrategy: v = "absolute", middlewares: E, delayShow: M = 0, delayHide: g = 0, float: C = !1, hidden: j = !1, noArrow: D = !1, clickable: u = !1, closeOnEsc: R = !1, closeOnScroll: K = !1, closeOnResize: I = !1, openEvents: z, closeEvents: k, globalCloseEvents: h, imperativeModeOnly: F = !1, style: o, position: a, isOpen: c, defaultIsOpen: d = !1, disableStyleInjection: S = !1, border: P, opacity: G, arrowColor: x, setIsOpen: Q, afterShow: J, afterHide: ie, role: te = "tooltip" }, $) => {
  const [oe, p] = At(i), [W, X] = At(n), [f, L] = At(Y), [w, H] = At(A), [U, ee] = At(q), [ae, ne] = At(M), [he, me] = At(g), [ve, Me] = At(C), [Z, V] = At(j), [re, le] = At(T), [be, de] = At(O), [ge, fe] = At(v), [ke, Pe] = At(null), [Ae, Le] = At(null), Ee = Tr(S), { anchorRefs: Ye, activeAnchor: We } = du(t), Ne = (it) => it == null ? void 0 : it.getAttributeNames().reduce((kt, ze) => {
    var nt;
    return ze.startsWith("data-tooltip-") && (kt[ze.replace(/^data-tooltip-/, "")] = (nt = it == null ? void 0 : it.getAttribute(ze)) !== null && nt !== void 0 ? nt : null), kt;
  }, {}), Xe = (it) => {
    const kt = { place: (ze) => {
      var nt;
      L((nt = ze) !== null && nt !== void 0 ? nt : Y);
    }, content: (ze) => {
      p(ze ?? i);
    }, html: (ze) => {
      X(ze ?? n);
    }, variant: (ze) => {
      var nt;
      H((nt = ze) !== null && nt !== void 0 ? nt : A);
    }, offset: (ze) => {
      ee(ze === null ? q : Number(ze));
    }, wrapper: (ze) => {
      var nt;
      le((nt = ze) !== null && nt !== void 0 ? nt : T);
    }, events: (ze) => {
      const nt = ze == null ? void 0 : ze.split(" ");
      de(nt ?? O);
    }, "position-strategy": (ze) => {
      var nt;
      fe((nt = ze) !== null && nt !== void 0 ? nt : v);
    }, "delay-show": (ze) => {
      ne(ze === null ? M : Number(ze));
    }, "delay-hide": (ze) => {
      me(ze === null ? g : Number(ze));
    }, float: (ze) => {
      Me(ze === null ? C : ze === "true");
    }, hidden: (ze) => {
      V(ze === null ? j : ze === "true");
    }, "class-name": (ze) => {
      Pe(ze);
    } };
    Object.values(kt).forEach((ze) => ze(null)), Object.entries(it).forEach(([ze, nt]) => {
      var jt;
      (jt = kt[ze]) === null || jt === void 0 || jt.call(kt, nt);
    });
  };
  Nt(() => {
    p(i);
  }, [i]), Nt(() => {
    X(n);
  }, [n]), Nt(() => {
    L(Y);
  }, [Y]), Nt(() => {
    H(A);
  }, [A]), Nt(() => {
    ee(q);
  }, [q]), Nt(() => {
    ne(M);
  }, [M]), Nt(() => {
    me(g);
  }, [g]), Nt(() => {
    Me(C);
  }, [C]), Nt(() => {
    V(j);
  }, [j]), Nt(() => {
    fe(v);
  }, [v]), Nt(() => {
    Ee.current !== S && console.warn("[react-tooltip] Do not change `disableStyleInjection` dynamically.");
  }, [S]), Nt(() => {
    typeof window < "u" && window.dispatchEvent(new CustomEvent("react-tooltip-inject-styles", { detail: { disableCore: S === "core", disableBase: S } }));
  }, []), Nt(() => {
    var it;
    const kt = new Set(Ye);
    let ze = e;
    if (!ze && t && (ze = `[data-tooltip-id='${t}']`), ze)
      try {
        document.querySelectorAll(ze).forEach((Ve) => {
          kt.add({ current: Ve });
        });
      } catch {
        console.warn(`[react-tooltip] "${ze}" is not a valid CSS selector`);
      }
    const nt = document.querySelector(`[id='${r}']`);
    if (nt && kt.add({ current: nt }), !kt.size)
      return () => null;
    const jt = (it = Ae ?? nt) !== null && it !== void 0 ? it : We.current, Vt = new MutationObserver((Ve) => {
      Ve.forEach((Je) => {
        var Dt;
        if (!jt || Je.type !== "attributes" || !(!((Dt = Je.attributeName) === null || Dt === void 0) && Dt.startsWith("data-tooltip-")))
          return;
        const It = Ne(jt);
        Xe(It);
      });
    }), Be = { attributes: !0, childList: !1, subtree: !1 };
    if (jt) {
      const Ve = Ne(jt);
      Xe(Ve), Vt.observe(jt, Be);
    }
    return () => {
      Vt.disconnect();
    };
  }, [Ye, We, Ae, r, e]), Nt(() => {
    o != null && o.border && console.warn("[react-tooltip] Do not set `style.border`. Use `border` prop instead."), P && !Qc("border", `${P}`) && console.warn(`[react-tooltip] "${P}" is not a valid \`border\`.`), o != null && o.opacity && console.warn("[react-tooltip] Do not set `style.opacity`. Use `opacity` prop instead."), G && !Qc("opacity", `${G}`) && console.warn(`[react-tooltip] "${G}" is not a valid \`opacity\`.`);
  }, []);
  let et = B;
  const Ze = Tr(null);
  if (s) {
    const it = s({ content: (Ae == null ? void 0 : Ae.getAttribute("data-tooltip-content")) || oe || null, activeAnchor: Ae });
    et = it ? Qt.createElement("div", { ref: Ze, className: "react-tooltip-content-wrapper" }, it) : null;
  } else
    oe && (et = oe);
  W && (et = Qt.createElement(Qk, { content: W }));
  const ut = { forwardRef: $, id: t, anchorId: r, anchorSelect: e, className: Co(l, ke), classNameArrow: m, content: et, contentWrapperRef: Ze, place: f, variant: w, offset: U, wrapper: re, events: be, openOnClick: b, positionStrategy: ge, middlewares: E, delayShow: ae, delayHide: he, float: ve, hidden: Z, noArrow: D, clickable: u, closeOnEsc: R, closeOnScroll: K, closeOnResize: I, openEvents: z, closeEvents: k, globalCloseEvents: h, imperativeModeOnly: F, style: o, position: a, isOpen: c, defaultIsOpen: d, border: P, opacity: G, arrowColor: x, setIsOpen: Q, afterShow: J, afterHide: ie, activeAnchor: Ae, setActiveAnchor: (it) => Le(it), role: te };
  return Qt.createElement(Xk, { ...ut });
});
typeof window < "u" && window.addEventListener("react-tooltip-inject-styles", (t) => {
  t.detail.disableCore || qc({ css: ":root{--rt-color-white:#fff;--rt-color-dark:#222;--rt-color-success:#8dc572;--rt-color-error:#be6464;--rt-color-warning:#f0ad4e;--rt-color-info:#337ab7;--rt-opacity:0.9;--rt-transition-show-delay:0.15s;--rt-transition-closing-delay:0.15s}.core-styles-module_tooltip__3vRRp{position:absolute;top:0;left:0;pointer-events:none;opacity:0;will-change:opacity}.core-styles-module_fixed__pcSol{position:fixed}.core-styles-module_arrow__cvMwQ{position:absolute;background:inherit}.core-styles-module_noArrow__xock6{display:none}.core-styles-module_clickable__ZuTTB{pointer-events:auto}.core-styles-module_show__Nt9eE{opacity:var(--rt-opacity);transition:opacity var(--rt-transition-show-delay)ease-out}.core-styles-module_closing__sGnxF{opacity:0;transition:opacity var(--rt-transition-closing-delay)ease-in}", type: "core" }), t.detail.disableBase || qc({ css: `
.styles-module_tooltip__mnnfp{padding:8px 16px;border-radius:3px;font-size:90%;width:max-content}.styles-module_arrow__K0L3T{width:8px;height:8px}[class*='react-tooltip__place-top']>.styles-module_arrow__K0L3T{transform:rotate(45deg)}[class*='react-tooltip__place-right']>.styles-module_arrow__K0L3T{transform:rotate(135deg)}[class*='react-tooltip__place-bottom']>.styles-module_arrow__K0L3T{transform:rotate(225deg)}[class*='react-tooltip__place-left']>.styles-module_arrow__K0L3T{transform:rotate(315deg)}.styles-module_dark__xNqje{background:var(--rt-color-dark);color:var(--rt-color-white)}.styles-module_light__Z6W-X{background-color:var(--rt-color-white);color:var(--rt-color-dark)}.styles-module_success__A2AKt{background-color:var(--rt-color-success);color:var(--rt-color-white)}.styles-module_warning__SCK0X{background-color:var(--rt-color-warning);color:var(--rt-color-white)}.styles-module_error__JvumD{background-color:var(--rt-color-error);color:var(--rt-color-white)}.styles-module_info__BWdHW{background-color:var(--rt-color-info);color:var(--rt-color-white)}`, type: "base" });
});
const Vk = ({
  data: t,
  selectedYear: r,
  setSelectedYear: e
}) => {
  const {
    submissionCalendar: i,
    activeYears: n,
    dccBadges: s,
    streak: l,
    totalActiveDays: m
  } = (t == null ? void 0 : t.userCalendar) || {}, A = Lw(n || []), { submissionCalendarData: Y, submissionsCount: q } = Dw(i || "{}", r), T = Rw(s || []);
  return /* @__PURE__ */ se.jsxs(se.Fragment, { children: [
    /* @__PURE__ */ se.jsxs("div", { className: "flex justify-between items-center", children: [
      /* @__PURE__ */ se.jsxs("div", { children: [
        /* @__PURE__ */ se.jsx("span", { className: "text-dark-label-1 text-xl", children: q }),
        " ",
        /* @__PURE__ */ se.jsx("span", { className: "text-dark-label-3 text-base", children: "submissions in the past one year" })
      ] }),
      /* @__PURE__ */ se.jsxs("div", { className: "flex gap-1 text-xs text-dark-label-3 gap-4 items-center", children: [
        /* @__PURE__ */ se.jsxs("p", { children: [
          "Total active days:",
          " ",
          /* @__PURE__ */ se.jsx("span", { className: "text-dark-label-2 text-xs", children: m })
        ] }),
        /* @__PURE__ */ se.jsxs("p", { children: [
          "Max streak:",
          " ",
          /* @__PURE__ */ se.jsx("span", { className: "text-dark-label-2 text-xs ", children: l })
        ] }),
        /* @__PURE__ */ se.jsx(
          mm,
          {
            options: A,
            selectedOption: r,
            onOptionClick: e
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ se.jsxs("div", { className: "flex overflow-x-auto gap-2 pb-4", children: [
      Object.values(Y).map((B) => Object.entries(B).map(
        ({ 0: O, 1: b }) => /* @__PURE__ */ se.jsxs("div", { className: "flex flex-col gap-2", children: [
          /* @__PURE__ */ se.jsx(
            _d,
            {
              data: b,
              theme: {
                dark: [
                  "#ffffff14",
                  "#004d1b",
                  "#008024",
                  "#01b328",
                  "#aff0b4"
                ]
              },
              colorScheme: "dark",
              blockSize: 8,
              blockMargin: 4,
              hideMonthLabels: !1,
              weekStart: 0,
              renderBlock: (v, E) => qg(v, {
                "data-tooltip-id": "react-tooltip",
                "data-tooltip-html": `${E.count} submission${E.count > 1 ? "s" : ""} on ${mw(E.date)}`
              })
            }
          ),
          /* @__PURE__ */ se.jsx(Et, { when: !T[Number(O)], children: /* @__PURE__ */ se.jsx("div", { className: "text-center text-xs text-[#AFB4BD] mt-2", children: jn(Number(O)) }) }),
          /* @__PURE__ */ se.jsx(Et, { when: !!T[Number(O)], children: /* @__PURE__ */ se.jsx(
            hm,
            {
              badge: T[Number(O)],
              className: "mx-auto h-6 w-6"
            }
          ) })
        ] }, crypto.randomUUID())
      )),
      /* @__PURE__ */ se.jsx(
        sl,
        {
          id: "react-tooltip",
          style: {
            backgroundColor: "rgb(58, 58, 58)",
            zIndex: 40,
            borderRadius: 6,
            padding: "6px 8px",
            fontSize: "12px"
          },
          className: "bg-dark-overlay-3 text-xs",
          noArrow: !0,
          delayShow: 100
        }
      )
    ] })
  ] });
}, o2 = ({
  username: t
}) => {
  const [r, e] = At(
    Aw
  ), { data: i, isLoading: n, isError: s } = Ew(
    t,
    r.value
  );
  return s ? /* @__PURE__ */ se.jsx(se.Fragment, { children: "Error" }) : /* @__PURE__ */ se.jsxs("div", { className: "w-full bg-dark-layer-1 p-4 shadow-dark-down-01 rounded-lg", children: [
    /* @__PURE__ */ se.jsx(Et, { when: !n && !s && !!i, children: /* @__PURE__ */ se.jsx(
      Vk,
      {
        data: i,
        selectedYear: r,
        setSelectedYear: e
      }
    ) }),
    /* @__PURE__ */ se.jsx(Et, { when: n, children: /* @__PURE__ */ se.jsx(rk, {}) })
  ] });
}, Kk = ({ onClose: t, backgroundUrl: r, gifUrl: e }) => /* @__PURE__ */ se.jsxs(
  "div",
  {
    className: "z-modal-5 fixed bottom-0 left-0 right-0 top-0",
    style: { background: "rgba(0, 0, 0, 0.5)" },
    onClick: t,
    children: [
      /* @__PURE__ */ se.jsx(lh, { className: "absolute right-2 top-2 text-white cursor-pointer" }),
      /* @__PURE__ */ se.jsx("div", { className: "flex h-full w-full items-center justify-center", children: /* @__PURE__ */ se.jsxs("div", { className: "relative flex h-[160px] w-[160px] items-center justify-center", children: [
        /* @__PURE__ */ se.jsx(
          "img",
          {
            src: r,
            alt: "badge background",
            className: "absolute left-0 right-0 h-[160px] w-[160px]"
          }
        ),
        /* @__PURE__ */ se.jsx(
          "img",
          {
            src: e,
            alt: "badge gif",
            className: "z-modal-6 h-[120px] w-[120px]"
          }
        )
      ] }) })
    ]
  }
), Qr = ({
  badge: {
    name: t,
    displayName: r,
    medal: {
      config: { iconGif: e, iconGifBackground: i }
    },
    icon: n,
    hoverText: s,
    creationDate: l
  },
  className: m,
  showFooter: A
}) => {
  const Y = () => (n || "").startsWith("https://") ? n : `https://leetcode.com${n}`, [q, T] = Qt.useState(!1), B = () => T((O) => !O);
  return n ? /* @__PURE__ */ se.jsxs("div", { className: "flex flex-col items-center justify-center", children: [
    /* @__PURE__ */ se.jsx(
      "img",
      {
        "data-tooltip-id": "badge-tooltip",
        "data-tooltip-content": s,
        src: Y(),
        alt: t,
        className: `h-auto min-w-[30px] max-w-[80px] cursor-pointer ${m || ""}`,
        onClick: B
      }
    ),
    /* @__PURE__ */ se.jsx(Et, { when: !!A, children: /* @__PURE__ */ se.jsxs("div", { className: "h-[40px] space-y-1", children: [
      /* @__PURE__ */ se.jsx("p", { className: "text-sm mt-2 max-w-[96px] overflow-hidden truncate text-center cursor-pointer text-dark-label-1", children: r }),
      /* @__PURE__ */ se.jsx("p", { className: "text-xs text-center text-dark-label-3 font-medium", children: l })
    ] }) }),
    /* @__PURE__ */ se.jsx(Et, { when: q, children: Xg(
      /* @__PURE__ */ se.jsx(
        Kk,
        {
          onClose: B,
          backgroundUrl: i,
          gifUrl: e
        }
      ),
      document.body
    ) }),
    /* @__PURE__ */ se.jsx(
      sl,
      {
        id: "badge-tooltip",
        style: {
          backgroundColor: "rgb(48, 48, 48, 0.4)",
          color: "#fff",
          borderRadius: 6,
          fontSize: 12,
          border: "1px solid #fff"
        },
        noArrow: !0
      }
    )
  ] }) : null;
}, Zk = ({ data: t, category: r }) => {
  const e = r.split("_").map((i) => i.charAt(0) + i.slice(1).toLowerCase()).join(" ");
  return /* @__PURE__ */ se.jsxs("div", { className: "mt-[24px]", children: [
    /* @__PURE__ */ se.jsxs("div", { className: "text-xs text-dark-label-2", children: [
      e,
      " Medals"
    ] }),
    /* @__PURE__ */ se.jsx("div", { className: "w-full px-2", children: /* @__PURE__ */ se.jsx("div", { className: "grid grid-cols-4 gap-x-[50px]", children: t.map((i) => /* @__PURE__ */ se.jsx(Qr, { badge: i, className: "w-[56px] h-[56px] mt-6", showFooter: !0 }, e)) }) })
  ] });
}, Jk = ({ data: t, showModal: r, toggleModal: e }) => {
  const i = t.reduce((n, s) => (n[s.category] || (n[s.category] = []), n[s.category].push(s), n), {});
  return /* @__PURE__ */ se.jsx("div", { children: /* @__PURE__ */ se.jsx(
    "div",
    {
      "aria-modal": "true",
      role: "dialog",
      className: "z-modal fixed inset-0 overflow-y-auto",
      hidden: !r,
      children: /* @__PURE__ */ se.jsxs("div", { className: "flex min-h-screen items-center justify-center px-4", children: [
        /* @__PURE__ */ se.jsx("div", { className: "opacity-100", onClick: e, children: /* @__PURE__ */ se.jsx(
          "div",
          {
            "aria-hidden": "true",
            className: "bg-gray-8 fixed inset-0 opacity-60"
          }
        ) }),
        /* @__PURE__ */ se.jsxs("div", { className: "my-8 inline-block min-w-full transform overflow-hidden rounded-[13px] text-left transition-all bg-dark-overlay-3 md:min-w-[420px] shadow-dark-level4 w-[100%] max-w-[600px] p-5 opacity-100 scale-100", children: [
          /* @__PURE__ */ se.jsxs("div", { className: "flex items-center justify-between border-b-1 border-dark-divider-border-2", children: [
            /* @__PURE__ */ se.jsx("h3", { className: "text-lg font-medium text-dark-label-1", children: "Badge List" }),
            /* @__PURE__ */ se.jsx("button", { className: "cursor-pointer rounded transition-all hover:bg-dark-fill-3", children: /* @__PURE__ */ se.jsx(lh, { onClick: e, className: "text-dark-label-1" }) })
          ] }),
          /* @__PURE__ */ se.jsx("div", { className: "max-h-[600px] overflow-y-auto", children: Object.entries(i).map(({ 0: n, 1: s }) => /* @__PURE__ */ se.jsx(Zk, { data: s, category: n }, n)) })
        ] })
      ] })
    }
  ) });
}, _k = ({ data: t }) => {
  var A, Y;
  const [r, e] = At(!1), [i, n] = At("left"), s = () => {
    e((q) => !q);
  }, l = () => {
    n((q) => q === "left" ? "right" : "left");
  }, m = (q) => q != null && q.startsWith("https://") ? q : `https://leetcode.com${q}`;
  return (t == null ? void 0 : t.length) === 0 ? /* @__PURE__ */ se.jsx(se.Fragment, { children: "User doesn't have any badge  " }) : /* @__PURE__ */ se.jsxs("div", { children: [
    /* @__PURE__ */ se.jsxs(Et, { when: i === "left", children: [
      /* @__PURE__ */ se.jsxs("div", { className: "flex items-start justify-between", children: [
        /* @__PURE__ */ se.jsxs("div", { className: "flex flex-col", children: [
          /* @__PURE__ */ se.jsx("p", { className: "text-xs text-dark-label-3 font-medium", children: "Badges" }),
          /* @__PURE__ */ se.jsx("p", { className: "text-base leading-[22px] text-dark-label-1", children: t == null ? void 0 : t.length })
        ] }),
        /* @__PURE__ */ se.jsx(
          am,
          {
            onClick: l,
            className: "cursor-pointer text-xl text-dark-label-3"
          }
        )
      ] }),
      /* @__PURE__ */ se.jsx(Et, { when: (t == null ? void 0 : t.length) < 3, children: /* @__PURE__ */ se.jsx(Qr, { badge: t == null ? void 0 : t[0], className: "w-[72px] h-[72px]" }) }),
      /* @__PURE__ */ se.jsx(Et, { when: (t == null ? void 0 : t.length) >= 3, children: /* @__PURE__ */ se.jsxs("div", { className: "flex items-center justify-center gap-2", children: [
        /* @__PURE__ */ se.jsx(Qr, { badge: t == null ? void 0 : t[1], className: "w-[56px] h-[56px]" }),
        /* @__PURE__ */ se.jsx(Qr, { badge: t == null ? void 0 : t[0], className: "w-[72px] h-[72px]" }),
        /* @__PURE__ */ se.jsx(Qr, { badge: t == null ? void 0 : t[2], className: "w-[56px] h-[56px]" })
      ] }) }),
      /* @__PURE__ */ se.jsxs("div", { className: "flex flex-col", children: [
        /* @__PURE__ */ se.jsx("p", { className: "text-xs text-dark-label-3 font-medium", children: "Most Recent Badge" }),
        /* @__PURE__ */ se.jsx("p", { className: "text-base leading-[22px] text-dark-label-1", children: (A = t == null ? void 0 : t[0]) == null ? void 0 : A.name })
      ] })
    ] }),
    /* @__PURE__ */ se.jsxs(Et, { when: i === "right", children: [
      /* @__PURE__ */ se.jsxs("div", { className: "flex items-start justify-between mb-4", children: [
        /* @__PURE__ */ se.jsx("div", { className: "flex flex-col", children: /* @__PURE__ */ se.jsx("p", { className: "text-xs text-dark-label-3 font-medium", children: "History Awards" }) }),
        /* @__PURE__ */ se.jsx(
          sm,
          {
            onClick: l,
            className: "cursor-pointer text-xl text-dark-label-3"
          }
        )
      ] }),
      /* @__PURE__ */ se.jsx(Et, { when: (t == null ? void 0 : t.length) <= 3, children: t == null ? void 0 : t.map((q) => /* @__PURE__ */ se.jsx(
        Qr,
        {
          badge: q,
          className: "w-[56px] h-[56px]"
        },
        q.name
      )) }),
      /* @__PURE__ */ se.jsx(Et, { when: (t == null ? void 0 : t.length) > 3, children: /* @__PURE__ */ se.jsxs("div", { className: "flex items-start justify-center gap-6", children: [
        /* @__PURE__ */ se.jsx(
          Qr,
          {
            badge: t == null ? void 0 : t[1],
            className: "w-[56px] h-[56px]",
            showFooter: !0
          }
        ),
        /* @__PURE__ */ se.jsx(
          Qr,
          {
            badge: t == null ? void 0 : t[0],
            className: "w-[56px] h-[56px]",
            showFooter: !0
          }
        ),
        /* @__PURE__ */ se.jsx(
          Qr,
          {
            badge: t == null ? void 0 : t[2],
            className: "w-[56px] h-[56px]",
            showFooter: !0
          }
        ),
        /* @__PURE__ */ se.jsx(Et, { when: !!(t != null && t[3]), children: /* @__PURE__ */ se.jsxs("div", { className: "relative", onClick: s, children: [
          /* @__PURE__ */ se.jsx(
            "img",
            {
              "data-tooltip-id": "all-badges-tooltip",
              "data-tooltip-content": "Show more badges",
              src: m((Y = t == null ? void 0 : t[3]) == null ? void 0 : Y.icon),
              alt: "badge gif",
              className: "w-[56px] h-[56px] cursor-pointer opacity-50"
            }
          ),
          /* @__PURE__ */ se.jsx("div", { className: "absolute top-[50%] left-[50%] translate-x-[-50%] translate-y-[-50%]", children: /* @__PURE__ */ se.jsx(cm, { className: "text-xl text-white cursor-pointer" }) }),
          /* @__PURE__ */ se.jsx(
            sl,
            {
              id: "all-badges-tooltip",
              style: {
                backgroundColor: "rgb(48, 48, 48, 0.4)",
                color: "#fff",
                borderRadius: 6,
                fontSize: 12,
                border: "1px solid #fff"
              },
              noArrow: !0
            }
          )
        ] }) })
      ] }) })
    ] }),
    /* @__PURE__ */ se.jsx(
      Jk,
      {
        data: t,
        showModal: r,
        toggleModal: s
      }
    )
  ] });
}, $k = () => /* @__PURE__ */ se.jsxs("div", { className: "flex flex-col gap-6 border-[#ffffff14] shadow rounded w-full animate-pulse", children: [
  /* @__PURE__ */ se.jsxs("div", { className: "flex justify-between", children: [
    /* @__PURE__ */ se.jsx("div", { className: "bg-[#ffffff14] rounded-full w-32 h-3.5" }),
    /* @__PURE__ */ se.jsx("div", { className: "bg-[#ffffff14] rounded-full w-12 h-3.5" })
  ] }),
  /* @__PURE__ */ se.jsxs("div", { className: "flex justify-center gap-4 w-full", children: [
    /* @__PURE__ */ se.jsx("div", { className: "bg-[#ffffff14] after:border-t-[#ffffff14] before:border-r-transparent before:border-r-[30px] after:border-r-transparent after:border-r-[30px] before:border-b-[#ffffff14] before:border-l-transparent before:border-l-[30px] after:border-l-transparent after:border-l-[30px] w-[60px] h-[35px] hexagon" }),
    /* @__PURE__ */ se.jsx("div", { className: "bg-[#ffffff14] after:border-t-[#ffffff14] after:border-r-transparent after:border-r-[35px] after:border-l-transparent after:border-l-[35px] w-[72px] h-[40px] pentagon" }),
    /* @__PURE__ */ se.jsx("div", { className: "bg-[#ffffff14] after:border-t-[#ffffff14] before:border-r-transparent before:border-r-[30px] after:border-r-transparent after:border-r-[30px] before:border-b-[#ffffff14] before:border-l-transparent before:border-l-[30px] after:border-l-transparent after:border-l-[30px] w-[60px] h-[35px] hexagon" })
  ] }),
  /* @__PURE__ */ se.jsx("div", { className: "bg-[#ffffff14] rounded-full w-32 h-3.5" })
] }), l2 = ({ username: t }) => {
  const { data: r, isLoading: e, isError: i } = Nw(t);
  return i ? /* @__PURE__ */ se.jsx("div", { children: "Error" }) : /* @__PURE__ */ se.jsxs("div", { className: "max-w-[600px] w-full min-h-[150px] bg-dark-layer-1 p-4 shadow-dark-down-01 rounded-lg mt-2", children: [
    /* @__PURE__ */ se.jsx(Et, { when: !e && !i && !!r, children: /* @__PURE__ */ se.jsx(_k, { data: r || [] }) }),
    /* @__PURE__ */ se.jsx(Et, { when: e, children: /* @__PURE__ */ se.jsx($k, {}) }),
    /* @__PURE__ */ se.jsx("div", { id: "badge-gif" })
  ] });
};
export {
  l2 as LeetcodeBadges,
  n2 as LeetcodeContestRatingGraph,
  i2 as LeetcodeProfilerProvider,
  a2 as LeetcodeSolvedProblemsStats,
  o2 as LeetcodeSubmissionsHeatmap,
  s2 as LeetcodeTopRatingHistogram,
  by as queryClient,
  Nw as useBadges,
  Qd as useContestRatingGraph,
  Ow as useSolvedProblemsStats,
  Ew as useSubmissionsCalendar,
  Tw as useTopRatingHistogram
};
